=== Iteration 1 (Fri Jan 23 21:01:33 CST 2026) ===
{"type":"system","subtype":"init","cwd":"/Users/juliacosmiano/code/gymnastics-graphics","session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","tools":["Task","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","BashOutput","KillShell","Skill","SlashCommand","EnterPlanMode","mcp__gymnastics__aws_list_instances","mcp__gymnastics__aws_start_instance","mcp__gymnastics__aws_stop_instance","mcp__gymnastics__aws_create_ami","mcp__gymnastics__aws_list_amis","mcp__gymnastics__ssh_exec","mcp__gymnastics__ssh_multi_exec","mcp__gymnastics__ssh_upload_file","mcp__gymnastics__ssh_download_file","mcp__gymnastics__firebase_get","mcp__gymnastics__firebase_set","mcp__gymnastics__firebase_update","mcp__gymnastics__firebase_delete","mcp__gymnastics__firebase_export","mcp__gymnastics__firebase_list_paths","mcp__gymnastics__aws_list_security_group_rules","mcp__gymnastics__aws_open_port","mcp__gymnastics__aws_close_port","mcp__playwright__browser_close","mcp__playwright__browser_resize","mcp__playwright__browser_console_messages","mcp__playwright__browser_handle_dialog","mcp__playwright__browser_evaluate","mcp__playwright__browser_file_upload","mcp__playwright__browser_fill_form","mcp__playwright__browser_install","mcp__playwright__browser_press_key","mcp__playwright__browser_type","mcp__playwright__browser_navigate","mcp__playwright__browser_navigate_back","mcp__playwright__browser_network_requests","mcp__playwright__browser_run_code","mcp__playwright__browser_take_screenshot","mcp__playwright__browser_snapshot","mcp__playwright__browser_click","mcp__playwright__browser_drag","mcp__playwright__browser_hover","mcp__playwright__browser_select_option","mcp__playwright__browser_tabs","mcp__playwright__browser_wait_for"],"mcp_servers":[{"name":"gymnastics","status":"connected"},{"name":"playwright","status":"connected"}],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["compact","context","cost","init","pr-comments","release-notes","todos","review","security-review","plan"],"apiKeySource":"none","claude_code_version":"2.0.57","output_style":"default","agents":["general-purpose","statusline-setup","Explore","Plan"],"skills":[],"plugins":[],"uuid":"676d49ae-0eee-4dca-9ec6-7f125cce29c6"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C21GYFLR2A1eVoYiC4trZr","type":"message","role":"assistant","content":[{"type":"text","text":"I'll start the PRD-Rundown-System implementation workflow. Let me begin with Phase 1: Load Context.\n\n## Phase 1: Load Context\n\n### Step 1.1 - Read PRD"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":26829,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":26829,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"4099028b-6f54-409b-8d42-92f75ca86cba"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C21GYFLR2A1eVoYiC4trZr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C74p26C6oLXgFA92Pf61r9","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PRD-Rundown-System-2026-01-23.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":26829,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":26829,"ephemeral_1h_input_tokens":0},"output_tokens":143,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"fbccc405-ba54-4dbe-a832-df7336a29260"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C74p26C6oLXgFA92Pf61r9","type":"tool_result","content":"     1→# PRD: Rundown System\n     2→\n     3→**Version:** 1.0\n     4→**Date:** 2026-01-23\n     5→**Status:** Active\n     6→\n     7→---\n     8→\n     9→## 1. Problem Statement\n    10→\n    11→The production system has two disconnected pieces:\n    12→\n    13→1. **Rundown Editor** - UI for planning show segments (exists, works)\n    14→2. **Timesheet Engine** - Server-side show execution (code exists, not wired)\n    15→\n    16→Producers can create rundowns but cannot execute them. There's no bridge between planning and execution, and the engine doesn't support multiple simultaneous competitions.\n    17→\n    18→---\n    19→\n    20→## 2. Goals\n    21→\n    22→| Goal | Description |\n    23→|------|-------------|\n    24→| **Connect Planning to Execution** | Load saved rundowns into the execution engine |\n    25→| **Multi-Competition Support** | Run multiple shows independently on different VMs |\n    26→| **Talent Support** | Simplified view for commentators |\n    27→| **Rehearsal Capability** | Dry-run shows without firing real graphics/OBS |\n    28→\n    29→---\n    30→\n    31→## 3. User Stories\n    32→\n    33→### Story 1: Producer Creates a Rundown\n    34→\n    35→**As a** Producer planning a UCLA vs Oregon meet\n    36→**I want to** create segments in the Rundown Editor\n    37→**So that** I have a structured plan for the show\n    38→\n    39→**Flow:**\n    40→1. Navigate to `/{compId}/rundown`\n    41→2. Add segments (Pre-Show Graphics, Welcome, Team Introductions, etc.)\n    42→3. Assign scenes, graphics, timing to each segment\n    43→4. Click Save\n    44→5. Segments saved to Firebase\n    45→\n    46→**Status:** ✅ Works today\n    47→\n    48→---\n    49→\n    50→### Story 2: Producer Loads Rundown for Execution\n    51→\n    52→**As a** Producer ready to run the show\n    53→**I want to** load my saved rundown into the execution engine\n    54→**So that** I can start the show with all my segments ready\n    55→\n    56→**Flow:**\n    57→1. Navigate to `/{compId}/producer` (Producer View)\n    58→2. See \"No rundown loaded\" indicator\n    59→3. Click \"Load Rundown\" button\n    60→4. Segments appear in the \"Show Progress\" panel\n    61→5. See \"Rundown loaded: 24 segments\" confirmation\n    62→6. \"Start Show\" button becomes active\n    63→\n    64→**Status:** ❌ Not implemented\n    65→\n    66→---\n    67→\n    68→### Story 3: Producer Runs the Show\n    69→\n    70→**As a** Producer executing a live broadcast\n    71→**I want** segments to progress automatically or manually\n    72→**So that** the show flows smoothly with proper timing\n    73→\n    74→**Flow:**\n    75→1. Click \"Start Show\"\n    76→2. First segment activates:\n    77→   - Timer counts down\n    78→   - OBS switches to assigned scene\n    79→   - Graphics fire if configured\n    80→   - Progress bar shows completion\n    81→3. Auto-advance segments progress automatically\n    82→4. Manual segments wait for producer to click \"Next\"\n    83→5. Show continues through all segments\n    84→\n    85→**Status:** ⚠️ Engine logic exists, but can't load segments\n    86→\n    87→---\n    88→\n    89→### Story 4: Multiple Competitions Run Independently\n    90→\n    91→**As a** Production company running two meets simultaneously\n    92→**I want** each competition to have independent show control\n    93→**So that** one show doesn't interfere with the other\n    94→\n    95→**Scenario:**\n    96→- Competition A: UCLA vs Oregon on VM 50.19.137.152\n    97→- Competition B: Stanford vs Cal on VM 54.210.98.89\n    98→\n    99→**Expected behavior:**\n   100→- Each producer sees only their competition's segments\n   101→- OBS commands route to the correct VM\n   102→- No interference between shows\n   103→\n   104→**Status:** ❌ Not implemented (single global engine)\n   105→\n   106→---\n   107→\n   108→### Story 5: Producer Reloads Modified Rundown (Pre-Show)\n   109→\n   110→**As a** Producer who made last-minute changes before starting\n   111→**I want to** reload the rundown after editing\n   112→**So that** I can incorporate changes before the show begins\n   113→\n   114→**Flow:**\n   115→1. Show is loaded but not started\n   116→2. Open Rundown Editor in new tab, make changes, save\n   117→3. Return to Producer View\n   118→4. Click \"Reload Rundown\"\n   119→5. Updated segments appear\n   120→\n   121→**Status:** ❌ Not implemented\n   122→\n   123→---\n   124→\n   125→### Story 6: Producer Runs Rehearsal\n   126→\n   127→**As a** Producer preparing for a show\n   128→**I want to** run through the show without firing real graphics or OBS\n   129→**So that** I can verify timing and flow before going live\n   130→\n   131→**Flow:**\n   132→1. Load rundown\n   133→2. Enable \"Rehearsal Mode\"\n   134→3. Start show - segments progress with timing\n   135→4. OBS and graphics do NOT fire\n   136→5. \"REHEARSAL\" indicator visible throughout\n   137→\n   138→**Status:** ❌ Not implemented\n   139→\n   140→---\n   141→\n   142→### Story 7: Talent Views Their Segments\n   143→\n   144→**As a** Commentator\n   145→**I want** a simplified view showing my current segment and time remaining\n   146→**So that** I can pace my commentary appropriately\n   147→\n   148→**Flow:**\n   149→1. Navigate to `/{compId}/talent`\n   150→2. See current segment with large countdown timer\n   151→3. See notes for current segment\n   152→4. See preview of next segment\n   153→5. Quick scene-switch buttons available\n   154→\n   155→**Status:** ❌ Not implemented\n   156→\n   157→---\n   158→\n   159→### Story 8: Producer Modifies Rundown During Live Show\n   160→\n   161→**As a** Producer running a live broadcast\n   162→**I want to** add, remove, or modify upcoming segments mid-show\n   163→**So that** I can adapt to unexpected situations (injury, schedule change, breaking news)\n   164→\n   165→**Flow:**\n   166→1. Show is running, currently on segment 12 of 24\n   167→2. Producer opens Rundown Editor in a new tab\n   168→3. Adds a new segment between 15 and 16 (e.g., \"Breaking: Injury Update\")\n   169→4. Saves changes\n   170→5. Returns to Producer View\n   171→6. Sees \"Rundown Modified\" warning badge\n   172→7. Clicks \"Reload Rundown\"\n   173→8. Confirmation dialog: \"Reload will add 1 segment. Current position preserved.\"\n   174→9. Confirms → segment list updates, show continues from current position\n   175→\n   176→**Edge Cases:**\n   177→- Current segment was deleted → Stay on it until manual advance, warn producer\n   178→- Segments before current were reordered → Ignore past segments, preserve position\n   179→- Multiple producers editing simultaneously → Last-write-wins with conflict warning\n   180→\n   181→**Status:** ❌ Not implemented (Phase I)\n   182→\n   183→---\n   184→\n   185→## 4. Phase Overview\n   186→\n   187→| Phase | Name | Priority | Goal |\n   188→|-------|------|----------|------|\n   189→| **A** | Connect Editor to Engine | P0 | Load rundown, execute show, multi-competition support |\n   190→| **H** | Rehearsal Mode | P1 | Dry-run without firing OBS/graphics |\n   191→| **B** | Talent View | P1 | Simplified commentator interface |\n   192→| **I** | Live Rundown Sync | P2 | Hot-reload changes during show |\n   193→| **J** | Timing Analytics | P2 | Track actual vs planned duration |\n   194→| **D** | AI Suggestions (Planning) | P2 | Suggest segments based on competition context |\n   195→| **E** | Script & Talent Flow | P2 | Pipe scripts to Talent View |\n   196→| **C** | AI Context (Live) | P3 | Real-time talking points during show |\n   197→| **F** | Audio Cue Integration | P3 | Trigger audio from segments |\n   198→| **G** | Production Tracking | P3 | Equipment and sponsor reports |\n   199→\n   200→---\n   201→\n   202→## 5. Success Criteria\n   203→\n   204→### Phase A Complete When:\n   205→- [ ] Producer can click \"Load Rundown\" and segments appear in Producer View\n   206→- [ ] \"Start Show\" begins execution with loaded segments\n   207→- [ ] Segment progression works (auto-advance and manual)\n   208→- [ ] OBS scene switching works when segment changes\n   209→- [ ] Graphics fire when segment has a graphic configured\n   210→- [ ] Changes in Rundown Editor can be re-loaded\n   211→- [ ] Two competitions can run independently without interference\n   212→\n   213→### Phase H Complete When:\n   214→- [ ] Rehearsal mode runs full show without firing OBS/graphics\n   215→- [ ] \"REHEARSAL\" indicator visible in all views\n   216→- [ ] Timing proceeds normally for practice\n   217→\n   218→### Phase B Complete When:\n   219→- [ ] Talent View accessible at `/{compId}/talent`\n   220→- [ ] Shows current segment with prominent time remaining\n   221→- [ ] Scene switching buttons work\n   222→- [ ] Notes visible to talent\n   223→\n   224→### Phase I Complete When:\n   225→- [ ] Producer sees \"Rundown Modified\" warning badge when rundown changes during show\n   226→- [ ] \"Reload Rundown\" updates segments without losing current position\n   227→- [ ] Confirmation dialog shows summary of changes (added/removed/modified segments)\n   228→- [ ] Deleted current segment is handled gracefully (stay on it, warn producer)\n   229→- [ ] Past segments (already completed) are not affected by reload\n   230→\n   231→### Phase J Complete When:\n   232→- [ ] Actual segment durations logged during show\n   233→- [ ] Historical timing data available in Rundown Editor\n   234→\n   235→---\n   236→\n   237→## 6. Terminology\n   238→\n   239→| Term | Definition |\n   240→|------|------------|\n   241→| **Segment** | A unit of show content (e.g., \"UCLA Introduction\", \"Rotation 1 Start\") |\n   242→| **Rundown** | The complete list of segments for a show |\n   243→| **Rundown Editor** | UI for creating/editing segments (`/{compId}/rundown`) |\n   244→| **Timesheet Engine** | Server-side code that executes the show |\n   245→| **Producer View** | Full production control page (`/{compId}/producer`) |\n   246→| **Talent View** | Simplified commentator interface (`/{compId}/talent`) |\n   247→| **Hold Segment** | A segment that waits for manual advance |\n   248→| **Coordinator** | Central server managing all competitions |\n   249→| **Competition VM** | EC2 instance assigned to a competition (runs OBS) |\n   250→\n   251→---\n   252→\n   253→## 7. Related Documents\n   254→\n   255→| Document | Purpose |\n   256→|----------|---------|\n   257→| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Implementation details, architecture, task breakdown |\n   258→| [PRD-Rundown-01-EditorPrototype/](../PRD-Rundown-01-EditorPrototype/) | Rundown Editor UI implementation (Phases 0-12) |\n   259→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"92d28331-45bd-4c76-a1db-68071b8fd27a","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PRD-Rundown-System-2026-01-23.md","content":"# PRD: Rundown System\n\n**Version:** 1.0\n**Date:** 2026-01-23\n**Status:** Active\n\n---\n\n## 1. Problem Statement\n\nThe production system has two disconnected pieces:\n\n1. **Rundown Editor** - UI for planning show segments (exists, works)\n2. **Timesheet Engine** - Server-side show execution (code exists, not wired)\n\nProducers can create rundowns but cannot execute them. There's no bridge between planning and execution, and the engine doesn't support multiple simultaneous competitions.\n\n---\n\n## 2. Goals\n\n| Goal | Description |\n|------|-------------|\n| **Connect Planning to Execution** | Load saved rundowns into the execution engine |\n| **Multi-Competition Support** | Run multiple shows independently on different VMs |\n| **Talent Support** | Simplified view for commentators |\n| **Rehearsal Capability** | Dry-run shows without firing real graphics/OBS |\n\n---\n\n## 3. User Stories\n\n### Story 1: Producer Creates a Rundown\n\n**As a** Producer planning a UCLA vs Oregon meet\n**I want to** create segments in the Rundown Editor\n**So that** I have a structured plan for the show\n\n**Flow:**\n1. Navigate to `/{compId}/rundown`\n2. Add segments (Pre-Show Graphics, Welcome, Team Introductions, etc.)\n3. Assign scenes, graphics, timing to each segment\n4. Click Save\n5. Segments saved to Firebase\n\n**Status:** ✅ Works today\n\n---\n\n### Story 2: Producer Loads Rundown for Execution\n\n**As a** Producer ready to run the show\n**I want to** load my saved rundown into the execution engine\n**So that** I can start the show with all my segments ready\n\n**Flow:**\n1. Navigate to `/{compId}/producer` (Producer View)\n2. See \"No rundown loaded\" indicator\n3. Click \"Load Rundown\" button\n4. Segments appear in the \"Show Progress\" panel\n5. See \"Rundown loaded: 24 segments\" confirmation\n6. \"Start Show\" button becomes active\n\n**Status:** ❌ Not implemented\n\n---\n\n### Story 3: Producer Runs the Show\n\n**As a** Producer executing a live broadcast\n**I want** segments to progress automatically or manually\n**So that** the show flows smoothly with proper timing\n\n**Flow:**\n1. Click \"Start Show\"\n2. First segment activates:\n   - Timer counts down\n   - OBS switches to assigned scene\n   - Graphics fire if configured\n   - Progress bar shows completion\n3. Auto-advance segments progress automatically\n4. Manual segments wait for producer to click \"Next\"\n5. Show continues through all segments\n\n**Status:** ⚠️ Engine logic exists, but can't load segments\n\n---\n\n### Story 4: Multiple Competitions Run Independently\n\n**As a** Production company running two meets simultaneously\n**I want** each competition to have independent show control\n**So that** one show doesn't interfere with the other\n\n**Scenario:**\n- Competition A: UCLA vs Oregon on VM 50.19.137.152\n- Competition B: Stanford vs Cal on VM 54.210.98.89\n\n**Expected behavior:**\n- Each producer sees only their competition's segments\n- OBS commands route to the correct VM\n- No interference between shows\n\n**Status:** ❌ Not implemented (single global engine)\n\n---\n\n### Story 5: Producer Reloads Modified Rundown (Pre-Show)\n\n**As a** Producer who made last-minute changes before starting\n**I want to** reload the rundown after editing\n**So that** I can incorporate changes before the show begins\n\n**Flow:**\n1. Show is loaded but not started\n2. Open Rundown Editor in new tab, make changes, save\n3. Return to Producer View\n4. Click \"Reload Rundown\"\n5. Updated segments appear\n\n**Status:** ❌ Not implemented\n\n---\n\n### Story 6: Producer Runs Rehearsal\n\n**As a** Producer preparing for a show\n**I want to** run through the show without firing real graphics or OBS\n**So that** I can verify timing and flow before going live\n\n**Flow:**\n1. Load rundown\n2. Enable \"Rehearsal Mode\"\n3. Start show - segments progress with timing\n4. OBS and graphics do NOT fire\n5. \"REHEARSAL\" indicator visible throughout\n\n**Status:** ❌ Not implemented\n\n---\n\n### Story 7: Talent Views Their Segments\n\n**As a** Commentator\n**I want** a simplified view showing my current segment and time remaining\n**So that** I can pace my commentary appropriately\n\n**Flow:**\n1. Navigate to `/{compId}/talent`\n2. See current segment with large countdown timer\n3. See notes for current segment\n4. See preview of next segment\n5. Quick scene-switch buttons available\n\n**Status:** ❌ Not implemented\n\n---\n\n### Story 8: Producer Modifies Rundown During Live Show\n\n**As a** Producer running a live broadcast\n**I want to** add, remove, or modify upcoming segments mid-show\n**So that** I can adapt to unexpected situations (injury, schedule change, breaking news)\n\n**Flow:**\n1. Show is running, currently on segment 12 of 24\n2. Producer opens Rundown Editor in a new tab\n3. Adds a new segment between 15 and 16 (e.g., \"Breaking: Injury Update\")\n4. Saves changes\n5. Returns to Producer View\n6. Sees \"Rundown Modified\" warning badge\n7. Clicks \"Reload Rundown\"\n8. Confirmation dialog: \"Reload will add 1 segment. Current position preserved.\"\n9. Confirms → segment list updates, show continues from current position\n\n**Edge Cases:**\n- Current segment was deleted → Stay on it until manual advance, warn producer\n- Segments before current were reordered → Ignore past segments, preserve position\n- Multiple producers editing simultaneously → Last-write-wins with conflict warning\n\n**Status:** ❌ Not implemented (Phase I)\n\n---\n\n## 4. Phase Overview\n\n| Phase | Name | Priority | Goal |\n|-------|------|----------|------|\n| **A** | Connect Editor to Engine | P0 | Load rundown, execute show, multi-competition support |\n| **H** | Rehearsal Mode | P1 | Dry-run without firing OBS/graphics |\n| **B** | Talent View | P1 | Simplified commentator interface |\n| **I** | Live Rundown Sync | P2 | Hot-reload changes during show |\n| **J** | Timing Analytics | P2 | Track actual vs planned duration |\n| **D** | AI Suggestions (Planning) | P2 | Suggest segments based on competition context |\n| **E** | Script & Talent Flow | P2 | Pipe scripts to Talent View |\n| **C** | AI Context (Live) | P3 | Real-time talking points during show |\n| **F** | Audio Cue Integration | P3 | Trigger audio from segments |\n| **G** | Production Tracking | P3 | Equipment and sponsor reports |\n\n---\n\n## 5. Success Criteria\n\n### Phase A Complete When:\n- [ ] Producer can click \"Load Rundown\" and segments appear in Producer View\n- [ ] \"Start Show\" begins execution with loaded segments\n- [ ] Segment progression works (auto-advance and manual)\n- [ ] OBS scene switching works when segment changes\n- [ ] Graphics fire when segment has a graphic configured\n- [ ] Changes in Rundown Editor can be re-loaded\n- [ ] Two competitions can run independently without interference\n\n### Phase H Complete When:\n- [ ] Rehearsal mode runs full show without firing OBS/graphics\n- [ ] \"REHEARSAL\" indicator visible in all views\n- [ ] Timing proceeds normally for practice\n\n### Phase B Complete When:\n- [ ] Talent View accessible at `/{compId}/talent`\n- [ ] Shows current segment with prominent time remaining\n- [ ] Scene switching buttons work\n- [ ] Notes visible to talent\n\n### Phase I Complete When:\n- [ ] Producer sees \"Rundown Modified\" warning badge when rundown changes during show\n- [ ] \"Reload Rundown\" updates segments without losing current position\n- [ ] Confirmation dialog shows summary of changes (added/removed/modified segments)\n- [ ] Deleted current segment is handled gracefully (stay on it, warn producer)\n- [ ] Past segments (already completed) are not affected by reload\n\n### Phase J Complete When:\n- [ ] Actual segment durations logged during show\n- [ ] Historical timing data available in Rundown Editor\n\n---\n\n## 6. Terminology\n\n| Term | Definition |\n|------|------------|\n| **Segment** | A unit of show content (e.g., \"UCLA Introduction\", \"Rotation 1 Start\") |\n| **Rundown** | The complete list of segments for a show |\n| **Rundown Editor** | UI for creating/editing segments (`/{compId}/rundown`) |\n| **Timesheet Engine** | Server-side code that executes the show |\n| **Producer View** | Full production control page (`/{compId}/producer`) |\n| **Talent View** | Simplified commentator interface (`/{compId}/talent`) |\n| **Hold Segment** | A segment that waits for manual advance |\n| **Coordinator** | Central server managing all competitions |\n| **Competition VM** | EC2 instance assigned to a competition (runs OBS) |\n\n---\n\n## 7. Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Implementation details, architecture, task breakdown |\n| [PRD-Rundown-01-EditorPrototype/](../PRD-Rundown-01-EditorPrototype/) | Rundown Editor UI implementation (Phases 0-12) |\n","numLines":259,"startLine":1,"totalLines":259}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AWxiy4jWsC1NAGwfBLyNvi","type":"message","role":"assistant","content":[{"type":"text","text":"```\n1.1 PRD Read\n- Feature name: Rundown System\n- Current PRD status: Active\n- Acceptance criteria count: 16 (across Phases A, H, B, I, J)\n```\n\n### Step 1.2 - Read Implementation Plan"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3410,"cache_read_input_tokens":26829,"cache_creation":{"ephemeral_5m_input_tokens":3410,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"bb278ed1-f851-43c3-bda5-2a04ed155f69"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AWxiy4jWsC1NAGwfBLyNvi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016TyxUNoWgwZ3a2PtPd64q5","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":3410,"cache_read_input_tokens":26829,"cache_creation":{"ephemeral_5m_input_tokens":3410,"ephemeral_1h_input_tokens":0},"output_tokens":156,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"a5a857ff-f882-4f11-ac6f-d2b549d1b622"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016TyxUNoWgwZ3a2PtPd64q5","type":"tool_result","content":"     1→# PLAN-Rundown-System-Implementation\n     2→\n     3→**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n     4→**Status:** NOT STARTED\n     5→**Created:** 2026-01-23\n     6→**Last Updated:** 2026-01-23\n     7→\n     8→---\n     9→\n    10→## Overview\n    11→\n    12→This implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n    13→\n    14→---\n    15→\n    16→## Related Documents\n    17→\n    18→| Document | Purpose |\n    19→|----------|---------|\n    20→| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n    21→| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n    22→\n    23→---\n    24→\n    25→## IMPORTANT: Task Execution Rules\n    26→\n    27→**ONE TASK = ONE ITERATION**\n    28→\n    29→Each row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n    30→\n    31→1. Pick the first NOT STARTED or IN PROGRESS task\n    32→2. Implement that ONE task\n    33→3. Commit, deploy, verify\n    34→4. STOP - the next iteration will handle the next task\n    35→\n    36→**Do NOT:**\n    37→- Complete multiple tasks in one iteration\n    38→- Batch \"related\" tasks together\n    39→- Complete an entire phase in one iteration\n    40→\n    41→**Task Numbering:**\n    42→- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n    43→- Each task number is unique and independent\n    44→- Example: \"Task 8\" is ONE task, not a subtask\n    45→\n    46→---\n    47→\n    48→## Phase Summary\n    49→\n    50→| Phase | Name | Priority | Status | Tasks |\n    51→|-------|------|----------|--------|-------|\n    52→| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n    53→| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n    54→| B | Talent View | P1 | NOT STARTED | 22-27 |\n    55→| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n    56→| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n    57→| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n    58→| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n    59→| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n    60→| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n    61→| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n    62→\n    63→---\n    64→\n    65→## Task Summary by Phase\n    66→\n    67→### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n    68→\n    69→| Task | Description | Status | Notes |\n    70→|------|-------------|--------|-------|\n    71→| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |\n    72→| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |\n    73→| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n    74→| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n    75→| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n    76→| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n    77→| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n    78→| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n    79→| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n    80→| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n    81→| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n    82→| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n    83→| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n    84→| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n    85→| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n    86→| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n    87→\n    88→### Phase H: Rehearsal Mode (P1) - NOT STARTED\n    89→\n    90→| Task | Description | Status | Notes |\n    91→|------|-------------|--------|-------|\n    92→| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n    93→| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n    94→| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n    95→| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n    96→| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n    97→\n    98→### Phase B: Talent View (P1) - NOT STARTED\n    99→\n   100→| Task | Description | Status | Notes |\n   101→|------|-------------|--------|-------|\n   102→| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n   103→| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n   104→| Task 24 | Scene switching buttons | NOT STARTED | |\n   105→| Task 25 | Next segment preview | NOT STARTED | |\n   106→| Task 26 | Notes display | NOT STARTED | |\n   107→| Task 27 | Add `/talent` route | NOT STARTED | |\n   108→\n   109→### Phase I: Live Rundown Sync (P2) - NOT STARTED\n   110→\n   111→| Task | Description | Status | Notes |\n   112→|------|-------------|--------|-------|\n   113→| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n   114→| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n   115→| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n   116→| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n   117→| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n   118→| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n   119→| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n   120→| Task 35 | Handle deleted current segment | NOT STARTED | |\n   121→| Task 36 | Handle reordered past segments | NOT STARTED | |\n   122→| Task 37 | Handle ID conflicts | NOT STARTED | |\n   123→\n   124→### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n   125→\n   126→| Task | Description | Status | Notes |\n   127→|------|-------------|--------|-------|\n   128→| Task 38 | Log actual segment durations during show | NOT STARTED | |\n   129→| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n   130→| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n   131→| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n   132→| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n   133→\n   134→### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n   135→\n   136→| Task | Description | Status | Notes |\n   137→|------|-------------|--------|-------|\n   138→| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n   139→| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n   140→| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n   141→| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n   142→| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n   143→| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n   144→\n   145→### Phase E: Script & Talent Flow (P2) - NOT STARTED\n   146→\n   147→| Task | Description | Status | Notes |\n   148→|------|-------------|--------|-------|\n   149→| Task 49 | Add script field to segment data model | NOT STARTED | |\n   150→| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n   151→| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n   152→| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n   153→| Task 53 | Create talent schedule view | NOT STARTED | |\n   154→| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n   155→\n   156→### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n   157→\n   158→| Task | Description | Status | Notes |\n   159→|------|-------------|--------|-------|\n   160→| Task 55 | Create AIContextService stub | NOT STARTED | |\n   161→| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n   162→| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n   163→| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n   164→| Task 59 | Generate talking points in real-time | NOT STARTED | |\n   165→| Task 60 | Detect career highs, records during show | NOT STARTED | |\n   166→| Task 61 | Display AI context in Talent View | NOT STARTED | |\n   167→| Task 62 | Display AI context in Producer View | NOT STARTED | |\n   168→\n   169→### Phase F: Audio Cue Integration (P3) - NOT STARTED\n   170→\n   171→| Task | Description | Status | Notes |\n   172→|------|-------------|--------|-------|\n   173→| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n   174→| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n   175→| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n   176→| Task 66 | Add audio control to Producer View | NOT STARTED | |\n   177→\n   178→### Phase G: Production Tracking (P3) - NOT STARTED\n   179→\n   180→| Task | Description | Status | Notes |\n   181→|------|-------------|--------|-------|\n   182→| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n   183→| Task 68 | Generate equipment schedule report | NOT STARTED | |\n   184→| Task 69 | Detect equipment conflicts | NOT STARTED | |\n   185→| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n   186→| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n   187→\n   188→---\n   189→\n   190→## Detailed Tasks - Phase A (P0)\n   191→\n   192→### Task 1: Update TimesheetEngine constructor\n   193→\n   194→**Status:** NOT STARTED\n   195→**File:** `server/lib/timesheetEngine.js`\n   196→\n   197→**Description:**\n   198→Update the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n   199→\n   200→**Checklist:**\n   201→- [ ] Add `compId` parameter to constructor\n   202→- [ ] Add `obsConnectionManager` parameter to constructor\n   203→- [ ] Store both as instance properties\n   204→- [ ] Remove dependency on global `obs` singleton\n   205→\n   206→---\n   207→\n   208→### Task 2: Create timesheetEngines Map\n   209→\n   210→**Status:** NOT STARTED\n   211→**File:** `server/index.js`\n   212→\n   213→**Description:**\n   214→Create a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n   215→\n   216→**Checklist:**\n   217→- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n   218→- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n   219→- [ ] Update existing engine initialization logic\n   220→\n   221→---\n   222→\n   223→### Task 3: Update _applyTransitionAndSwitchScene()\n   224→\n   225→**Status:** NOT STARTED\n   226→**File:** `server/lib/timesheetEngine.js`\n   227→\n   228→**Description:**\n   229→Update the scene switching method to use per-competition OBS connection via obsConnectionManager.\n   230→\n   231→**Checklist:**\n   232→- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n   233→- [ ] Handle case when connection doesn't exist\n   234→- [ ] Add error handling for disconnected state\n   235→\n   236→---\n   237→\n   238→### Task 4: Update _playVideo()\n   239→\n   240→**Status:** NOT STARTED\n   241→**File:** `server/lib/timesheetEngine.js`\n   242→\n   243→**Description:**\n   244→Update the video playback method to use per-competition OBS connection.\n   245→\n   246→**Checklist:**\n   247→- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n   248→- [ ] Handle case when connection doesn't exist\n   249→\n   250→---\n   251→\n   252→### Task 5: Update _applyAudioOverrides()\n   253→\n   254→**Status:** NOT STARTED\n   255→**File:** `server/lib/timesheetEngine.js`\n   256→\n   257→**Description:**\n   258→Update the audio override method to use per-competition OBS connection.\n   259→\n   260→**Checklist:**\n   261→- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n   262→- [ ] Handle case when connection doesn't exist\n   263→\n   264→---\n   265→\n   266→### Task 6: Update socket event broadcasts\n   267→\n   268→**Status:** NOT STARTED\n   269→**File:** `server/lib/timesheetEngine.js`\n   270→\n   271→**Description:**\n   272→Update all socket.io event emissions to target the competition-specific room.\n   273→\n   274→**Checklist:**\n   275→- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n   276→- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n   277→- [ ] Verify room naming matches existing convention\n   278→\n   279→---\n   280→\n   281→### Task 7: Pass Firebase Admin to engine\n   282→\n   283→**Status:** NOT STARTED\n   284→**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n   285→\n   286→**Description:**\n   287→Pass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n   288→\n   289→**Checklist:**\n   290→- [ ] Add `firebase` parameter to constructor\n   291→- [ ] Export `db` from productionConfigService.js\n   292→- [ ] Pass Firebase instance when creating engine\n   293→- [ ] Update `_triggerGraphic()` to use `this.firebase`\n   294→\n   295→---\n   296→\n   297→### Task 8: Add loadRundown socket handler\n   298→\n   299→**Status:** NOT STARTED\n   300→**File:** `server/index.js`\n   301→\n   302→**Description:**\n   303→Add socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n   304→\n   305→**Checklist:**\n   306→- [ ] Add `socket.on('loadRundown', ...)` handler\n   307→- [ ] Extract `compId` from payload\n   308→- [ ] Call `getOrCreateEngine()` to get engine instance\n   309→- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n   310→- [ ] Call engine's load method with segments\n   311→- [ ] Emit `timesheetState` with loaded segments\n   312→\n   313→---\n   314→\n   315→### Task 9: Add loadRundown action in ShowContext\n   316→\n   317→**Status:** NOT STARTED\n   318→**File:** `show-controller/src/context/ShowContext.jsx`\n   319→\n   320→**Description:**\n   321→Add `loadRundown` action to emit the socket event from client.\n   322→\n   323→**Checklist:**\n   324→- [ ] Add `loadRundown` function that emits `loadRundown` event\n   325→- [ ] Pass `compId` from context\n   326→- [ ] Export function from context\n   327→\n   328→---\n   329→\n   330→### Task 10: Add \"Load Rundown\" button\n   331→\n   332→**Status:** NOT STARTED\n   333→**File:** `show-controller/src/views/ProducerView.jsx`\n   334→\n   335→**Description:**\n   336→Add \"Load Rundown\" button in Producer View header/toolbar.\n   337→\n   338→**Checklist:**\n   339→- [ ] Add \"Load Rundown\" button to Producer View\n   340→- [ ] Wire button to `loadRundown` action from ShowContext\n   341→- [ ] Show loading state while loading\n   342→- [ ] Show toast on success/failure\n   343→\n   344→---\n   345→\n   346→### Task 11: Create segment mapper\n   347→\n   348→**Status:** NOT STARTED\n   349→**File:** `server/lib/segmentMapper.js` (new file)\n   350→\n   351→**Description:**\n   352→Create utility to map Rundown Editor segment format to Timesheet Engine format.\n   353→\n   354→**Checklist:**\n   355→- [ ] Create `server/lib/segmentMapper.js`\n   356→- [ ] Map `scene` → `obsScene`\n   357→- [ ] Map `graphic.graphicId` → `graphic`\n   358→- [ ] Map `graphic.params` → `graphicData`\n   359→- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n   360→- [ ] Preserve all other fields\n   361→\n   362→---\n   363→\n   364→### Task 12: Verify Firebase passed to engine\n   365→\n   366→**Status:** NOT STARTED\n   367→**File:** `server/index.js`\n   368→\n   369→**Description:**\n   370→Verify Firebase Admin is correctly passed and usable in engine.\n   371→\n   372→**Checklist:**\n   373→- [ ] Add logging to confirm Firebase instance received\n   374→- [ ] Test that `_triggerGraphic()` can write to Firebase\n   375→- [ ] Handle missing Firebase gracefully\n   376→\n   377→---\n   378→\n   379→### Task 13: Show rundown status indicator\n   380→\n   381→**Status:** NOT STARTED\n   382→**File:** `show-controller/src/views/ProducerView.jsx`\n   383→\n   384→**Description:**\n   385→Add status indicator showing rundown state (idle, loaded, modified).\n   386→\n   387→**Checklist:**\n   388→- [ ] Add status badge component\n   389→- [ ] Show \"No Rundown\" when state is IDLE\n   390→- [ ] Show \"Rundown Loaded\" when state is LOADED\n   391→- [ ] Show segment count in badge\n   392→\n   393→---\n   394→\n   395→### Task 14: Verify scene picker uses OBS state\n   396→\n   397→**Status:** NOT STARTED\n   398→**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n   399→\n   400→**Description:**\n   401→Verify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n   402→\n   403→**Checklist:**\n   404→- [ ] Check current implementation of scene picker\n   405→- [ ] If hardcoded, plan integration with OBS scene list\n   406→- [ ] Document current state\n   407→\n   408→---\n   409→\n   410→### Task 15: Verify graphics picker uses Registry\n   411→\n   412→**Status:** NOT STARTED\n   413→**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n   414→\n   415→**Description:**\n   416→Verify that the graphics picker dropdown uses graphicsRegistry.js.\n   417→\n   418→**Checklist:**\n   419→- [ ] Check current implementation of graphics picker\n   420→- [ ] Verify graphicsRegistry.js is imported and used\n   421→- [ ] Confirm graphics filtered by competition type\n   422→\n   423→---\n   424→\n   425→### Task 16: Fix hardcoded picker data\n   426→\n   427→**Status:** NOT STARTED\n   428→**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n   429→\n   430→**Description:**\n   431→Replace any hardcoded picker data with live data sources.\n   432→\n   433→**Checklist:**\n   434→- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n   435→- [ ] Verify graphics come from registry\n   436→- [ ] Test with actual competition data\n   437→\n   438→---\n   439→\n   440→## Bugs & Issues\n   441→\n   442→| Bug ID | Description | Status | Task |\n   443→|--------|-------------|--------|------|\n   444→\n   445→---\n   446→\n   447→## Notes\n   448→\n   449→### Dependencies\n   450→- **Phase A** is the prerequisite for all other phases\n   451→- **Phase H** and **Phase B** can run in parallel after Phase A\n   452→- **Phase I-G** depend on Phase A completion\n   453→\n   454→### Architecture Considerations\n   455→- Multi-competition support requires Map-based engine instances\n   456→- Socket.io rooms isolate competition events\n   457→- Firebase Admin must be passed to engine (not just client SDK)\n   458→- OBS connections managed by existing obsConnectionManager\n   459→\n   460→### Critical Gap Identified\n   461→Current `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n   462→\n   463→### Key Files Reference\n   464→See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n   465→\n   466→---\n   467→\n   468→## Completion Criteria\n   469→\n   470→**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n   471→\n   472→**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n   473→\n   474→**Full System:** All phases complete.\n   475→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"634ec50d-0eb0-4423-add5-2aaef663f5b1","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","content":"# PLAN-Rundown-System-Implementation\n\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n**Status:** NOT STARTED\n**Created:** 2026-01-23\n**Last Updated:** 2026-01-23\n\n---\n\n## Overview\n\nThis implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n\n---\n\n## IMPORTANT: Task Execution Rules\n\n**ONE TASK = ONE ITERATION**\n\nEach row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n\n1. Pick the first NOT STARTED or IN PROGRESS task\n2. Implement that ONE task\n3. Commit, deploy, verify\n4. STOP - the next iteration will handle the next task\n\n**Do NOT:**\n- Complete multiple tasks in one iteration\n- Batch \"related\" tasks together\n- Complete an entire phase in one iteration\n\n**Task Numbering:**\n- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n- Each task number is unique and independent\n- Example: \"Task 8\" is ONE task, not a subtask\n\n---\n\n## Phase Summary\n\n| Phase | Name | Priority | Status | Tasks |\n|-------|------|----------|--------|-------|\n| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n| B | Talent View | P1 | NOT STARTED | 22-27 |\n| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n\n---\n\n## Task Summary by Phase\n\n### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |\n| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |\n| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n\n### Phase H: Rehearsal Mode (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n\n### Phase B: Talent View (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n| Task 24 | Scene switching buttons | NOT STARTED | |\n| Task 25 | Next segment preview | NOT STARTED | |\n| Task 26 | Notes display | NOT STARTED | |\n| Task 27 | Add `/talent` route | NOT STARTED | |\n\n### Phase I: Live Rundown Sync (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n| Task 35 | Handle deleted current segment | NOT STARTED | |\n| Task 36 | Handle reordered past segments | NOT STARTED | |\n| Task 37 | Handle ID conflicts | NOT STARTED | |\n\n### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 38 | Log actual segment durations during show | NOT STARTED | |\n| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n\n### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n\n### Phase E: Script & Talent Flow (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 49 | Add script field to segment data model | NOT STARTED | |\n| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n| Task 53 | Create talent schedule view | NOT STARTED | |\n| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n\n### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 55 | Create AIContextService stub | NOT STARTED | |\n| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n| Task 59 | Generate talking points in real-time | NOT STARTED | |\n| Task 60 | Detect career highs, records during show | NOT STARTED | |\n| Task 61 | Display AI context in Talent View | NOT STARTED | |\n| Task 62 | Display AI context in Producer View | NOT STARTED | |\n\n### Phase F: Audio Cue Integration (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n| Task 66 | Add audio control to Producer View | NOT STARTED | |\n\n### Phase G: Production Tracking (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n| Task 68 | Generate equipment schedule report | NOT STARTED | |\n| Task 69 | Detect equipment conflicts | NOT STARTED | |\n| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n\n---\n\n## Detailed Tasks - Phase A (P0)\n\n### Task 1: Update TimesheetEngine constructor\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n\n**Checklist:**\n- [ ] Add `compId` parameter to constructor\n- [ ] Add `obsConnectionManager` parameter to constructor\n- [ ] Store both as instance properties\n- [ ] Remove dependency on global `obs` singleton\n\n---\n\n### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic\n\n---\n\n### Task 3: Update _applyTransitionAndSwitchScene()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the scene switching method to use per-competition OBS connection via obsConnectionManager.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n- [ ] Add error handling for disconnected state\n\n---\n\n### Task 4: Update _playVideo()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the video playback method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 5: Update _applyAudioOverrides()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the audio override method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 6: Update socket event broadcasts\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate all socket.io event emissions to target the competition-specific room.\n\n**Checklist:**\n- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n- [ ] Verify room naming matches existing convention\n\n---\n\n### Task 7: Pass Firebase Admin to engine\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n\n**Description:**\nPass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n\n**Checklist:**\n- [ ] Add `firebase` parameter to constructor\n- [ ] Export `db` from productionConfigService.js\n- [ ] Pass Firebase instance when creating engine\n- [ ] Update `_triggerGraphic()` to use `this.firebase`\n\n---\n\n### Task 8: Add loadRundown socket handler\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nAdd socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n\n**Checklist:**\n- [ ] Add `socket.on('loadRundown', ...)` handler\n- [ ] Extract `compId` from payload\n- [ ] Call `getOrCreateEngine()` to get engine instance\n- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n- [ ] Call engine's load method with segments\n- [ ] Emit `timesheetState` with loaded segments\n\n---\n\n### Task 9: Add loadRundown action in ShowContext\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/context/ShowContext.jsx`\n\n**Description:**\nAdd `loadRundown` action to emit the socket event from client.\n\n**Checklist:**\n- [ ] Add `loadRundown` function that emits `loadRundown` event\n- [ ] Pass `compId` from context\n- [ ] Export function from context\n\n---\n\n### Task 10: Add \"Load Rundown\" button\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd \"Load Rundown\" button in Producer View header/toolbar.\n\n**Checklist:**\n- [ ] Add \"Load Rundown\" button to Producer View\n- [ ] Wire button to `loadRundown` action from ShowContext\n- [ ] Show loading state while loading\n- [ ] Show toast on success/failure\n\n---\n\n### Task 11: Create segment mapper\n\n**Status:** NOT STARTED\n**File:** `server/lib/segmentMapper.js` (new file)\n\n**Description:**\nCreate utility to map Rundown Editor segment format to Timesheet Engine format.\n\n**Checklist:**\n- [ ] Create `server/lib/segmentMapper.js`\n- [ ] Map `scene` → `obsScene`\n- [ ] Map `graphic.graphicId` → `graphic`\n- [ ] Map `graphic.params` → `graphicData`\n- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n- [ ] Preserve all other fields\n\n---\n\n### Task 12: Verify Firebase passed to engine\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nVerify Firebase Admin is correctly passed and usable in engine.\n\n**Checklist:**\n- [ ] Add logging to confirm Firebase instance received\n- [ ] Test that `_triggerGraphic()` can write to Firebase\n- [ ] Handle missing Firebase gracefully\n\n---\n\n### Task 13: Show rundown status indicator\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd status indicator showing rundown state (idle, loaded, modified).\n\n**Checklist:**\n- [ ] Add status badge component\n- [ ] Show \"No Rundown\" when state is IDLE\n- [ ] Show \"Rundown Loaded\" when state is LOADED\n- [ ] Show segment count in badge\n\n---\n\n### Task 14: Verify scene picker uses OBS state\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n\n**Checklist:**\n- [ ] Check current implementation of scene picker\n- [ ] If hardcoded, plan integration with OBS scene list\n- [ ] Document current state\n\n---\n\n### Task 15: Verify graphics picker uses Registry\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the graphics picker dropdown uses graphicsRegistry.js.\n\n**Checklist:**\n- [ ] Check current implementation of graphics picker\n- [ ] Verify graphicsRegistry.js is imported and used\n- [ ] Confirm graphics filtered by competition type\n\n---\n\n### Task 16: Fix hardcoded picker data\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nReplace any hardcoded picker data with live data sources.\n\n**Checklist:**\n- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n- [ ] Verify graphics come from registry\n- [ ] Test with actual competition data\n\n---\n\n## Bugs & Issues\n\n| Bug ID | Description | Status | Task |\n|--------|-------------|--------|------|\n\n---\n\n## Notes\n\n### Dependencies\n- **Phase A** is the prerequisite for all other phases\n- **Phase H** and **Phase B** can run in parallel after Phase A\n- **Phase I-G** depend on Phase A completion\n\n### Architecture Considerations\n- Multi-competition support requires Map-based engine instances\n- Socket.io rooms isolate competition events\n- Firebase Admin must be passed to engine (not just client SDK)\n- OBS connections managed by existing obsConnectionManager\n\n### Critical Gap Identified\nCurrent `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n\n### Key Files Reference\nSee [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n\n---\n\n## Completion Criteria\n\n**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n\n**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n\n**Full System:** All phases complete.\n","numLines":475,"startLine":1,"totalLines":475}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SDS8qyWxB9mkQurELGg28G","type":"message","role":"assistant","content":[{"type":"text","text":"```\n1.2 Implementation Plan Read\n- Total tasks: 71\n- Tasks NOT STARTED: 71\n- Tasks IN PROGRESS: 0\n- Tasks COMPLETE: 0\n```\n\n### Step 1.3 - Read Detailed Plan"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6715,"cache_read_input_tokens":30239,"cache_creation":{"ephemeral_5m_input_tokens":6715,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"0482c7ac-cce1-4495-ad4d-a2705e2441a0"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SDS8qyWxB9mkQurELGg28G","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KwoCSZ1FXrrpPxd71N1YrK","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-2026-01-23.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":6715,"cache_read_input_tokens":30239,"cache_creation":{"ephemeral_5m_input_tokens":6715,"ephemeral_1h_input_tokens":0},"output_tokens":154,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"8d50ae06-a1a2-4828-8f7a-9c44f2474f59"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KwoCSZ1FXrrpPxd71N1YrK","type":"tool_result","content":"     1→# Implementation Plan: Rundown System\n     2→\n     3→**Version:** 1.0\n     4→**Date:** 2026-01-23\n     5→**Status:** Active\n     6→**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n     7→\n     8→---\n     9→\n    10→## Related Documents\n    11→\n    12→| Document | Purpose |\n    13→|----------|---------|\n    14→| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n    15→| [PLAN-Rundown-System-Implementation.md](./PLAN-Rundown-System-Implementation.md) | Implementation task tracking (use this for day-to-day execution) |\n    16→\n    17→**Note:** This document serves as the technical reference for architecture, state machine, socket events, error handling, and testing. For task execution and progress tracking, see the Implementation Plan.\n    18→\n    19→---\n    20→\n    21→## 1. Architecture Overview\n    22→\n    23→### 1.1 System Components\n    24→\n    25→```\n    26→RUNDOWN (planning)              TIMESHEET (execution)\n    27→──────────────────              ─────────────────────\n    28→Rundown Editor UI        →      Timesheet Engine (server)\n    29→Firebase storage         →      useTimesheet hook (client)\n    30→                                Timesheet UI (Producer View)\n    31→```\n    32→\n    33→### 1.2 Data Flow\n    34→\n    35→```\n    36→┌─────────────────────────────────────────────────────────────────────────────┐\n    37→│  PLANNING                                                                    │\n    38→│                                                                              │\n    39→│  Rundown Editor (/{compId}/rundown)                                         │\n    40→│  └── Saves to: competitions/{compId}/production/rundown/segments            │\n    41→│                                                                              │\n    42→└─────────────────────────────────────────────────────────────────────────────┘\n    43→                                    │\n    44→                                    │ \"Load Rundown\" (Phase A)\n    45→                                    ▼\n    46→┌─────────────────────────────────────────────────────────────────────────────┐\n    47→│  EXECUTION                                                                   │\n    48→│                                                                              │\n    49→│  Timesheet Engine (server/lib/timesheetEngine.js)                           │\n    50→│  ├── Runs segments with timing                                               │\n    51→│  ├── Fires OBS scene changes (via obsConnectionManager)                      │\n    52→│  ├── Triggers graphics                                                       │\n    53→│  └── Broadcasts state via Socket.io (to competition room)                   │\n    54→│                                                                              │\n    55→└─────────────────────────────────────────────────────────────────────────────┘\n    56→                                    │\n    57→                                    │ Socket.io events\n    58→                                    ▼\n    59→┌─────────────────────────────────────────────────────────────────────────────┐\n    60→│  VIEWS                                                                       │\n    61→│                                                                              │\n    62→│  Producer View (/{compId}/producer)    Talent View (/{compId}/talent)       │\n    63→│  ├── Now Playing                        ├── Time remaining                   │\n    64→│  ├── Up Next                            ├── Current/Next segment             │\n    65→│  ├── Show Control                       ├── Scene switching                  │\n    66→│  └── Show Progress                      └── Notes                            │\n    67→│                                                                              │\n    68→└─────────────────────────────────────────────────────────────────────────────┘\n    69→```\n    70→\n    71→### 1.3 Multi-Competition Architecture\n    72→\n    73→```\n    74→┌──────────────────────────────────────────────────────────────────────────────┐\n    75→│  COORDINATOR (api.commentarygraphic.com)                                     │\n    76→│                                                                               │\n    77→│  ┌─────────────────────────────────────────────────────────────────────────┐ │\n    78→│  │  obsConnectionManager (per-competition OBS connections)                  │ │\n    79→│  │  ├── compId: abc123 → OBS WebSocket to VM 50.19.137.152:4455            │ │\n    80→│  │  └── compId: xyz789 → OBS WebSocket to VM 54.210.98.89:4455             │ │\n    81→│  └─────────────────────────────────────────────────────────────────────────┘ │\n    82→│                                                                               │\n    83→│  ┌─────────────────────────────────────────────────────────────────────────┐ │\n    84→│  │  timesheetEngines Map (per-competition execution)                        │ │\n    85→│  │  ├── compId: abc123 → TimesheetEngine instance                          │ │\n    86→│  │  └── compId: xyz789 → TimesheetEngine instance                          │ │\n    87→│  └─────────────────────────────────────────────────────────────────────────┘ │\n    88→│                                                                               │\n    89→│  Socket.io rooms: competition:abc123, competition:xyz789                     │\n    90→└──────────────────────────────────────────────────────────────────────────────┘\n    91→```\n    92→\n    93→---\n    94→\n    95→## 2. Show State Machine\n    96→\n    97→```\n    98→                              ┌─────────────────────────────────────────┐\n    99→                              │                                         │\n   100→                              ▼                                         │\n   101→┌─────────┐  loadRundown  ┌────────┐  startShow  ┌─────────┐           │\n   102→│  IDLE   │──────────────▶│ LOADED │────────────▶│ RUNNING │           │\n   103→└─────────┘               └────────┘             └─────────┘           │\n   104→     ▲                         ▲                      │                │\n   105→     │                         │                      │ pauseShow      │\n   106→     │                         │                      ▼                │\n   107→     │                         │                 ┌─────────┐           │\n   108→     │                         │ resumeShow      │ PAUSED  │           │\n   109→     │                         │◀────────────────┴─────────┘           │\n   110→     │                         │                      │                │\n   111→     │                    reloadRundown               │                │\n   112→     │                         │                      │                │\n   113→     │                         │                      │ stopShow       │\n   114→     │   resetShow        ┌────────┐                  │                │\n   115→     │◀───────────────────│STOPPED │◀─────────────────┘                │\n   116→     │                    └────────┘                                   │\n   117→     │                         │                                       │\n   118→     │                         │ segment reaches end                   │\n   119→     │                         ▼                                       │\n   120→     │                    ┌──────────┐  (auto if last segment)         │\n   121→     └────────────────────│ COMPLETE │─────────────────────────────────┘\n   122→                          └──────────┘\n   123→```\n   124→\n   125→### State Definitions\n   126→\n   127→| State | Description | Valid Actions |\n   128→|-------|-------------|---------------|\n   129→| `IDLE` | No rundown loaded | `loadRundown` |\n   130→| `LOADED` | Rundown loaded, ready to start | `startShow`, `reloadRundown`, `resetShow` |\n   131→| `RUNNING` | Show in progress, timer active | `pauseShow`, `stopShow`, `nextSegment`, `prevSegment`, `jumpToSegment` |\n   132→| `PAUSED` | Show paused, timer frozen | `resumeShow`, `stopShow`, `reloadRundown` |\n   133→| `STOPPED` | Show stopped before completion | `resetShow`, `reloadRundown` |\n   134→| `COMPLETE` | All segments finished | `resetShow`, `reloadRundown` |\n   135→\n   136→### State Transitions\n   137→\n   138→| From | Event | To | Side Effects |\n   139→|------|-------|----|--------------|\n   140→| IDLE | `loadRundown` | LOADED | Fetch segments from Firebase, initialize engine |\n   141→| LOADED | `startShow` | RUNNING | Activate first segment, start timer, fire OBS/graphics |\n   142→| RUNNING | `pauseShow` | PAUSED | Freeze timer, keep current segment |\n   143→| PAUSED | `resumeShow` | RUNNING | Resume timer |\n   144→| RUNNING | `stopShow` | STOPPED | Stop timer, log analytics |\n   145→| PAUSED | `stopShow` | STOPPED | Log analytics |\n   146→| RUNNING | segment ends (last) | COMPLETE | Log analytics, show complete indicator |\n   147→| STOPPED | `resetShow` | IDLE | Clear segments, reset state |\n   148→| COMPLETE | `resetShow` | IDLE | Clear segments, reset state |\n   149→| LOADED/PAUSED/STOPPED | `reloadRundown` | LOADED | Re-fetch segments, preserve position if possible |\n   150→\n   151→---\n   152→\n   153→## 3. Task Dependency Graph\n   154→\n   155→```\n   156→PHASE A (P0): Connect Editor to Engine\n   157→═══════════════════════════════════════\n   158→\n   159→A.0.1 ──┬──▶ A.0.3 ──┐\n   160→        │            │\n   161→A.0.2 ──┼──▶ A.0.4 ──┼──▶ A.0.6 ──┐\n   162→        │            │            │\n   163→        └──▶ A.0.5 ──┘            │\n   164→                                  │\n   165→A.0.7 ────────────────────────────┼──▶ A.1 ──▶ A.2 ──▶ A.3\n   166→                                  │            │\n   167→                                  │            ▼\n   168→                                  │           A.4 ──▶ A.5 ──▶ A.6\n   169→                                  │\n   170→                                  └──▶ A.5.1 ──┬──▶ A.5.3\n   171→                                       A.5.2 ──┘\n   172→\n   173→PHASE H (P1): Rehearsal Mode          PHASE B (P1): Talent View\n   174→══════════════════════════════        ════════════════════════════\n   175→\n   176→     ┌──▶ H.2 ──┐                          B.1 ──▶ B.2 ──┐\n   177→     │          │                                        │\n   178→H.1 ─┼──▶ H.3 ──┼──▶ H.4 ──▶ H.5               B.3 ──────┤\n   179→     │          │                                        │\n   180→     └──────────┘                          B.4 ──▶ B.5 ──┼──▶ B.6\n   181→                                                         │\n   182→                                                         ▼\n   183→PHASE I (P2): Live Rundown Sync       ◄───── DEPENDS ON PHASE A\n   184→══════════════════════════════════\n   185→\n   186→I.1 ──▶ I.2 ──▶ I.3 ──┬──▶ I.5 ──▶ I.6 ──▶ I.7\n   187→                      │\n   188→                      └──▶ I.4\n   189→```\n   190→\n   191→### Critical Path (Minimum for MVP)\n   192→\n   193→```\n   194→A.0.1 → A.0.2 → A.0.3 → A.0.6 → A.1 → A.2 → A.3 → A.4 → A.6\n   195→  │\n   196→  └──▶ \"Producer can load rundown and start show\"\n   197→```\n   198→\n   199→### Parallel Work Opportunities\n   200→\n   201→| Can Run In Parallel | Reason |\n   202→|---------------------|--------|\n   203→| A.0.3, A.0.4, A.0.5 | Independent OBS method updates |\n   204→| A.5.1, A.5.2 | Independent picker verification |\n   205→| Phase H, Phase B | No dependencies on each other (both depend on A) |\n   206→| H.2, H.3 | Independent skip logic |\n   207→\n   208→---\n   209→\n   210→## 4. Key Files\n   211→\n   212→### Server\n   213→| File | Purpose | Changes Required |\n   214→|------|---------|------------------|\n   215→| `server/index.js` | Coordinator entry point, socket handlers | Add `timesheetEngines` Map, `loadRundown` handler |\n   216→| `server/lib/timesheetEngine.js` | Show execution engine (~1187 lines) | Accept `compId`, `obsConnectionManager`; update OBS calls |\n   217→| `server/lib/obsConnectionManager.js` | Per-competition OBS WebSocket connections | Already supports multi-competition ✅ |\n   218→| `server/lib/vmPoolManager.js` | EC2 VM assignment and lifecycle | No changes needed |\n   219→| `server/lib/productionConfigService.js` | Firebase Admin initialization | Export `db` for engine use |\n   220→\n   221→### Client\n   222→| File | Purpose | Changes Required |\n   223→|------|---------|------------------|\n   224→| `show-controller/src/hooks/useTimesheet.js` | Client hook for timesheet state | Add `loadRundown`, `reloadRundown` actions |\n   225→| `show-controller/src/context/ShowContext.jsx` | Shared state, socket connection | Emit `loadRundown` event |\n   226→| `show-controller/src/pages/RundownEditorPage.jsx` | Rundown planning UI | Verify pickers use live data |\n   227→| `show-controller/src/views/ProducerView.jsx` | Production control + Timesheet UI | Add Load/Reload buttons, status indicator |\n   228→| `show-controller/src/components/CurrentSegment.jsx` | Now Playing display | No changes needed |\n   229→| `show-controller/src/components/NextSegment.jsx` | Up Next display | No changes needed |\n   230→| `show-controller/src/components/RunOfShow.jsx` | Show Progress list | Add \"modified\" badge |\n   231→\n   232→---\n   233→\n   234→## 5. Code Audit (2026-01-23)\n   235→\n   236→### 5.1 Current State\n   237→\n   238→| Component | Code Exists | Actually Works |\n   239→|-----------|-------------|----------------|\n   240→| Timesheet Engine | ✅ ~1200 lines | ⚠️ Not wired to Firebase/OBS properly |\n   241→| useTimesheet Hook | ✅ | ✅ Works |\n   242→| Timesheet UI | ✅ | ✅ Works |\n   243→| Rundown Editor | ✅ | ⚠️ Pickers need verification |\n   244→\n   245→### 5.2 Critical Gap: Single Global Instance\n   246→\n   247→**Current (Wrong):** `server/index.js` lines 250-255\n   248→```javascript\n   249→// Single global instance - can only control one competition\n   250→let timesheetEngine;\n   251→\n   252→function initializeTimesheetEngine() {\n   253→  timesheetEngine = new TimesheetEngine({\n   254→    showConfig,\n   255→    obs,        // ❌ Single OBS connection\n   256→    io\n   257→    // MISSING: firebase, compId, obsConnectionManager\n   258→  });\n   259→}\n   260→```\n   261→\n   262→**Required (Correct):**\n   263→```javascript\n   264→// Map of per-competition instances\n   265→const timesheetEngines = new Map();\n   266→\n   267→function getOrCreateEngine(compId, obsConnectionManager, firebase, io) {\n   268→  if (!timesheetEngines.has(compId)) {\n   269→    const engine = new TimesheetEngine({\n   270→      compId,\n   271→      obsConnectionManager,\n   272→      firebase,\n   273→      io\n   274→    });\n   275→    timesheetEngines.set(compId, engine);\n   276→  }\n   277→  return timesheetEngines.get(compId);\n   278→}\n   279→```\n   280→\n   281→### 5.3 Methods Requiring Updates\n   282→\n   283→| Method | Current | Required Change |\n   284→|--------|---------|-----------------|\n   285→| `_applyTransitionAndSwitchScene()` | `this.obs.call(...)` | Use `obsConnectionManager.getConnection(compId)` |\n   286→| `_triggerGraphic()` | `this.firebase` (never provided) | Pass Firebase Admin in constructor |\n   287→| `_playVideo()` | `this.obs.call(...)` | Use per-competition OBS |\n   288→| `_applyAudioOverrides()` | `this.obs.call(...)` | Use per-competition OBS |\n   289→| Event broadcasts | `this.io.emit(...)` | `this.io.to('competition:${compId}').emit(...)` |\n   290→\n   291→---\n   292→\n   293→## 6. Socket Events\n   294→\n   295→### 6.1 Client → Server (Commands)\n   296→\n   297→#### `loadRundown`\n   298→Load segments from Firebase into the engine.\n   299→\n   300→```javascript\n   301→// Request\n   302→socket.emit('loadRundown', { compId: 'abc123' });\n   303→\n   304→// Response (via timesheetState)\n   305→// Engine state with segments loaded\n   306→```\n   307→\n   308→#### `startShow`\n   309→Begin show execution.\n   310→\n   311→```javascript\n   312→socket.emit('startShow', { compId: 'abc123' });\n   313→```\n   314→\n   315→#### `stopShow`\n   316→Stop show execution.\n   317→\n   318→```javascript\n   319→socket.emit('stopShow', { compId: 'abc123' });\n   320→```\n   321→\n   322→#### `pauseShow` / `resumeShow`\n   323→Pause or resume the current show.\n   324→\n   325→```javascript\n   326→socket.emit('pauseShow', { compId: 'abc123' });\n   327→socket.emit('resumeShow', { compId: 'abc123' });\n   328→```\n   329→\n   330→#### `nextSegment` / `prevSegment`\n   331→Advance to next or previous segment.\n   332→\n   333→```javascript\n   334→socket.emit('nextSegment', { compId: 'abc123' });\n   335→socket.emit('prevSegment', { compId: 'abc123' });\n   336→```\n   337→\n   338→#### `jumpToSegment`\n   339→Jump to a specific segment by ID.\n   340→\n   341→```javascript\n   342→socket.emit('jumpToSegment', { compId: 'abc123', segmentId: 'segment-5' });\n   343→```\n   344→\n   345→#### `reloadRundown`\n   346→Hot-reload rundown from Firebase (Phase I).\n   347→\n   348→```javascript\n   349→socket.emit('reloadRundown', { compId: 'abc123' });\n   350→```\n   351→\n   352→### 6.2 Server → Client (State Updates)\n   353→\n   354→#### `timesheetState`\n   355→Full state update (sent on load, major changes).\n   356→\n   357→```javascript\n   358→{\n   359→  showState: 'RUNNING',           // IDLE | LOADED | RUNNING | PAUSED | STOPPED | COMPLETE\n   360→  isRehearsalMode: false,\n   361→  segments: [\n   362→    {\n   363→      id: 'segment-1',\n   364→      name: 'Pre-Show Graphics',\n   365→      type: 'graphics',\n   366→      duration: 30,\n   367→      obsScene: 'Pre-Show',\n   368→      graphic: 'logos',\n   369→      graphicData: { teamIds: ['ucla', 'oregon'] },\n   370→      autoAdvance: true,\n   371→      notes: 'Wait for countdown'\n   372→    },\n   373→    // ... more segments\n   374→  ],\n   375→  currentSegmentIndex: 3,\n   376→  currentSegmentId: 'segment-4',\n   377→  elapsedTime: 45,                // seconds into current segment\n   378→  totalElapsed: 320,              // seconds since show start\n   379→  rundownModified: false,         // true if Firebase changed since load\n   380→  rundownModifiedSummary: null    // { added: [], removed: [], modified: [] }\n   381→}\n   382→```\n   383→\n   384→#### `timesheetTick`\n   385→Lightweight timing update (sent every second during RUNNING state).\n   386→\n   387→```javascript\n   388→{\n   389→  currentSegmentIndex: 3,\n   390→  elapsedTime: 46,                // seconds into current segment\n   391→  remainingTime: 14,              // seconds remaining in segment\n   392→  totalElapsed: 321,\n   393→  progress: 0.77                  // 0-1 progress through segment\n   394→}\n   395→```\n   396→\n   397→#### `timesheetSegmentActivated`\n   398→Sent when a new segment becomes active.\n   399→\n   400→```javascript\n   401→{\n   402→  previousSegmentId: 'segment-3',\n   403→  previousSegmentIndex: 2,\n   404→  currentSegmentId: 'segment-4',\n   405→  currentSegmentIndex: 3,\n   406→  segment: {\n   407→    id: 'segment-4',\n   408→    name: 'UCLA Introduction',\n   409→    duration: 30,\n   410→    obsScene: 'Team-Intro',\n   411→    // ... full segment data\n   412→  },\n   413→  nextSegment: {\n   414→    id: 'segment-5',\n   415→    name: 'Oregon Introduction',\n   416→    // ... preview of next\n   417→  }\n   418→}\n   419→```\n   420→\n   421→#### `timesheetShowStarted`\n   422→Show has started.\n   423→\n   424→```javascript\n   425→{\n   426→  startedAt: '2026-01-23T19:00:00.000Z',\n   427→  totalSegments: 24,\n   428→  firstSegment: { id: 'segment-1', name: 'Pre-Show Graphics' }\n   429→}\n   430→```\n   431→\n   432→#### `timesheetShowStopped`\n   433→Show was stopped (not complete).\n   434→\n   435→```javascript\n   436→{\n   437→  stoppedAt: '2026-01-23T19:45:00.000Z',\n   438→  lastSegmentIndex: 12,\n   439→  reason: 'manual'                // manual | error\n   440→}\n   441→```\n   442→\n   443→#### `timesheetShowComplete`\n   444→All segments finished.\n   445→\n   446→```javascript\n   447→{\n   448→  completedAt: '2026-01-23T20:30:00.000Z',\n   449→  totalDuration: 5400,            // seconds\n   450→  segmentCount: 24\n   451→}\n   452→```\n   453→\n   454→#### `rundownModified` (Phase I)\n   455→Firebase rundown changed while show is loaded/running.\n   456→\n   457→```javascript\n   458→{\n   459→  added: ['segment-25'],\n   460→  removed: [],\n   461→  modified: ['segment-12'],\n   462→  affectsCurrent: false,\n   463→  affectsUpcoming: true,\n   464→  timestamp: '2026-01-23T19:32:00.000Z'\n   465→}\n   466→```\n   467→\n   468→#### `obsError`\n   469→OBS operation failed (non-fatal).\n   470→\n   471→```javascript\n   472→{\n   473→  operation: 'sceneChange',\n   474→  scene: 'Team-Intro',\n   475→  error: 'Scene not found',\n   476→  segmentId: 'segment-4'\n   477→}\n   478→```\n   479→\n   480→---\n   481→\n   482→## 7. Segment Data Mapping\n   483→\n   484→| Editor Field | Engine Field | Notes |\n   485→|--------------|--------------|-------|\n   486→| `id` | `id` | Direct copy |\n   487→| `name` | `name` | Direct copy |\n   488→| `type` | `type` | Direct copy |\n   489→| `duration` | `duration` | In seconds |\n   490→| `scene` | `obsScene` | OBS scene name |\n   491→| `graphic.graphicId` | `graphic` | Graphic identifier |\n   492→| `graphic.params` | `graphicData` | Graphic parameters |\n   493→| `timingMode` | `autoAdvance` | 'fixed' → true, 'manual' → false |\n   494→| `notes` | `notes` | Direct copy |\n   495→\n   496→---\n   497→\n   498→## 8. Task Breakdown\n   499→\n   500→### Phase A: Connect Editor to Engine (P0)\n   501→\n   502→#### A.0: Refactor TimesheetEngine for Multi-Competition (PREREQUISITE)\n   503→\n   504→- [ ] **A.0.1** Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager`\n   505→- [ ] **A.0.2** Create `timesheetEngines` Map in server/index.js\n   506→- [ ] **A.0.3** Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)`\n   507→- [ ] **A.0.4** Update `_playVideo()` to use per-competition OBS connection\n   508→- [ ] **A.0.5** Update `_applyAudioOverrides()` to use per-competition OBS connection\n   509→- [ ] **A.0.6** Update all socket event broadcasts to target competition room: `io.to('competition:${compId}')`\n   510→- [ ] **A.0.7** Pass Firebase Admin instance to engine for `_triggerGraphic()`\n   511→\n   512→#### A.1-A.6: Build Load Rundown Feature\n   513→\n   514→- [ ] **A.1** Add `loadRundown` socket handler on server (creates/updates engine for compId)\n   515→- [ ] **A.2** Add `loadRundown` action in ShowContext\n   516→- [ ] **A.3** Add \"Load Rundown\" button in Producer View\n   517→- [ ] **A.4** Create segment mapper (Editor format → Engine format)\n   518→- [ ] **A.5** Verify Firebase is passed to engine\n   519→- [ ] **A.6** Show rundown status indicator (loaded, modified, etc.)\n   520→\n   521→#### A.5x: Verify Pickers\n   522→\n   523→- [ ] **A.5.1** Verify Rundown Editor scene picker uses OBS state\n   524→- [ ] **A.5.2** Verify Rundown Editor graphics picker uses Graphics Registry\n   525→- [ ] **A.5.3** Fix any hardcoded picker data\n   526→\n   527→---\n   528→\n   529→### Phase H: Rehearsal Mode (P1)\n   530→\n   531→- [ ] **H.1** Add rehearsal mode toggle to Timesheet Engine\n   532→- [ ] **H.2** Skip OBS scene changes in rehearsal mode\n   533→- [ ] **H.3** Skip graphics firing in rehearsal mode\n   534→- [ ] **H.4** Show \"REHEARSAL\" indicator in all views\n   535→- [ ] **H.5** Log timing data for post-rehearsal analysis\n   536→\n   537→---\n   538→\n   539→### Phase B: Talent View (P1)\n   540→\n   541→- [ ] **B.1** Create `TalentView.jsx` page\n   542→- [ ] **B.2** Current segment with prominent time remaining\n   543→- [ ] **B.3** Scene switching buttons\n   544→- [ ] **B.4** Next segment preview\n   545→- [ ] **B.5** Notes display\n   546→- [ ] **B.6** Add `/talent` route\n   547→\n   548→**Layout Reference:**\n   549→```\n   550→┌─────────────────────────────────────────────────────────────────┐\n   551→│  TALENT VIEW                                   [Scene Buttons]  │\n   552→├─────────────────────────────────────────────────────────────────┤\n   553→│  ┌─ CURRENT SEGMENT ──────────────────────────────────────────┐ │\n   554→│  │  UCLA Introduction                                          │ │\n   555→│  │                                                             │ │\n   556→│  │              0:22 REMAINING                                 │ │\n   557→│  │              (of 0:30)                                      │ │\n   558→│  │                                                             │ │\n   559→│  │  [████████████████████████░░░░░░░░░░░░] 73%                │ │\n   560→│  │                                                             │ │\n   561→│  │  NOTES: Wait for applause to die down                      │ │\n   562→│  └─────────────────────────────────────────────────────────────┘ │\n   563→│                                                                 │\n   564→│  ┌─ UP NEXT ──────────────────────────────────────────────────┐ │\n   565→│  │  Oregon Introduction (0:30)                                 │ │\n   566→│  └─────────────────────────────────────────────────────────────┘ │\n   567→└─────────────────────────────────────────────────────────────────┘\n   568→```\n   569→\n   570→---\n   571→\n   572→### Phase I: Live Rundown Sync (P2)\n   573→\n   574→#### I.1-I.3: Change Detection\n   575→\n   576→- [ ] **I.1** Subscribe to Firebase `rundown/segments` changes on server (use `onValue` listener)\n   577→- [ ] **I.2** Compare incoming segments to loaded segments (deep diff)\n   578→- [ ] **I.3** Emit `rundownModified` socket event with change summary:\n   579→  ```javascript\n   580→  {\n   581→    added: ['segment-id-1'],\n   582→    removed: ['segment-id-2'],\n   583→    modified: ['segment-id-3'],\n   584→    affectsCurrent: false,  // true if current segment was modified/deleted\n   585→    affectsUpcoming: true   // true if any future segment changed\n   586→  }\n   587→  ```\n   588→\n   589→#### I.4-I.5: UI Indicators\n   590→\n   591→- [ ] **I.4** Add `rundownModified` state to `useTimesheet` hook\n   592→- [ ] **I.5** Show \"Rundown Modified\" warning badge in Producer View header\n   593→  - Yellow badge if only future segments changed\n   594→  - Red badge if current segment affected\n   595→  - Show count: \"3 segments changed\"\n   596→\n   597→#### I.6-I.7: Reload Flow\n   598→\n   599→- [ ] **I.6** Add \"Reload Rundown\" button (appears when modified)\n   600→- [ ] **I.7** Confirmation dialog with change summary:\n   601→  ```\n   602→  ┌─────────────────────────────────────────────┐\n   603→  │  Reload Rundown?                            │\n   604→  ├─────────────────────────────────────────────┤\n   605→  │  Changes detected:                          │\n   606→  │  • 1 segment added                          │\n   607→  │  • 2 segments modified                      │\n   608→  │                                             │\n   609→  │  Current position will be preserved.        │\n   610→  │  You are on segment 12 of 24.               │\n   611→  │                                             │\n   612→  │  [Cancel]                    [Reload Now]   │\n   613→  └─────────────────────────────────────────────┘\n   614→  ```\n   615→\n   616→#### I.8-I.10: Edge Case Handling\n   617→\n   618→- [ ] **I.8** Handle deleted current segment:\n   619→  - Keep segment active until manual advance\n   620→  - Show warning: \"Current segment was deleted from rundown\"\n   621→  - On advance, skip to next valid segment\n   622→- [ ] **I.9** Handle reordered past segments:\n   623→  - Ignore changes to segments before current index\n   624→  - Only apply changes to current and future segments\n   625→- [ ] **I.10** Handle ID conflicts:\n   626→  - Match segments by ID, not index\n   627→  - If current segment ID still exists, stay on it regardless of new position\n   628→\n   629→---\n   630→\n   631→### Phase J: Segment Timing Analytics (P2)\n   632→\n   633→- [ ] **J.1** Log actual segment durations during show\n   634→- [ ] **J.2** Store timing data in Firebase post-show\n   635→- [ ] **J.3** Create timing analytics dashboard\n   636→- [ ] **J.4** Show historical average in Rundown Editor\n   637→- [ ] **J.5** AI-powered timing predictions based on history\n   638→\n   639→---\n   640→\n   641→### Phase D: AI Suggestions - Planning (P2)\n   642→\n   643→- [ ] **D.1** Create AI suggestion service on server\n   644→- [ ] **D.2** Analyze competition metadata (type, teams, date)\n   645→- [ ] **D.3** Query roster data for seniors, All-Americans, milestones\n   646→- [ ] **D.4** Generate segment suggestions with confidence scores\n   647→- [ ] **D.5** Add `getAISuggestions` API endpoint\n   648→- [ ] **D.6** Wire Rundown Editor to display suggestions\n   649→\n   650→---\n   651→\n   652→### Phase E: Script & Talent Flow (P2)\n   653→\n   654→- [ ] **E.1** Add script field to segment data model\n   655→- [ ] **E.2** Pipe script field through Timesheet Engine\n   656→- [ ] **E.3** Display script in Talent View (teleprompter-style)\n   657→- [ ] **E.4** Add talent assignment to segment data model\n   658→- [ ] **E.5** Create talent schedule view\n   659→- [ ] **E.6** Show \"you're on camera\" indicator in Talent View\n   660→\n   661→---\n   662→\n   663→### Phase C: AI Context - Live Execution (P3)\n   664→\n   665→- [ ] **C.1** Create AIContextService stub\n   666→- [ ] **C.2** Add `aiContextUpdated` socket event\n   667→- [ ] **C.3** Create `useAIContext` hook\n   668→- [ ] **C.4** Integrate with Virtius API for live stats\n   669→- [ ] **C.5** Generate talking points in real-time\n   670→- [ ] **C.6** Detect career highs, records during show\n   671→- [ ] **C.7** Display AI context in Talent View\n   672→- [ ] **C.8** Display AI context in Producer View\n   673→\n   674→---\n   675→\n   676→### Phase F: Audio Cue Integration (P3)\n   677→\n   678→- [ ] **F.1** Add audio cue fields to segment data model\n   679→- [ ] **F.2** Pipe audio cues through Timesheet Engine\n   680→- [ ] **F.3** Trigger audio playback on segment start\n   681→- [ ] **F.4** Add audio control to Producer View\n   682→\n   683→---\n   684→\n   685→### Phase G: Production Tracking (P3)\n   686→\n   687→- [ ] **G.1** Add equipment fields to segment data model\n   688→- [ ] **G.2** Generate equipment schedule report\n   689→- [ ] **G.3** Detect equipment conflicts\n   690→- [ ] **G.4** Add sponsor fields to segment data model\n   691→- [ ] **G.5** Generate sponsor fulfillment report\n   692→\n   693→---\n   694→\n   695→## 9. Error Handling\n   696→\n   697→### 9.1 OBS Connection Failures\n   698→\n   699→| Scenario | Detection | Response | User Feedback |\n   700→|----------|-----------|----------|---------------|\n   701→| OBS disconnects mid-show | `obsConnectionManager` emits `disconnected` | Continue show, queue scene changes | \"OBS Disconnected\" badge, retry button |\n   702→| OBS reconnects | `obsConnectionManager` emits `connected` | Replay last scene change | \"OBS Connected\" toast |\n   703→| Scene change fails | OBS WebSocket error | Log error, continue show | \"Scene change failed\" toast |\n   704→| Scene doesn't exist | OBS returns error | Skip scene change, log | \"Scene 'X' not found\" warning |\n   705→\n   706→### 9.2 Firebase Failures\n   707→\n   708→| Scenario | Detection | Response | User Feedback |\n   709→|----------|-----------|----------|---------------|\n   710→| Firebase read fails | Promise rejection in `loadRundown` | Retry 3x with backoff | \"Failed to load rundown\" error |\n   711→| Firebase write fails | Promise rejection in analytics | Queue for retry | Silent (non-critical) |\n   712→| Firebase listener disconnects | `onValue` error callback | Reconnect automatically | \"Sync paused\" indicator |\n   713→\n   714→### 9.3 Show Execution Errors\n   715→\n   716→| Scenario | Detection | Response | User Feedback |\n   717→|----------|-----------|----------|---------------|\n   718→| Segment has no duration | Validation on load | Default to 30s, warn | \"Segment X has no duration\" warning |\n   719→| Segment has invalid scene | Validation on load | Skip scene change | \"Invalid scene in segment X\" warning |\n   720→| Timer drift > 1s | Periodic sync check | Correct timer | Silent correction |\n   721→| Engine crashes | Uncaught exception | Restart engine, preserve state | \"Show engine restarted\" warning |\n   722→\n   723→### 9.4 Recovery Strategies\n   724→\n   725→```javascript\n   726→// Graceful degradation for OBS failures\n   727→async function executeSegmentWithFallback(segment) {\n   728→  try {\n   729→    await this._applyTransitionAndSwitchScene(segment.obsScene);\n   730→  } catch (error) {\n   731→    this._log('warn', `Scene change failed: ${error.message}`);\n   732→    this._emit('obsError', { segment: segment.id, error: error.message });\n   733→    // Continue show - don't block on OBS failures\n   734→  }\n   735→\n   736→  // Graphics are optional - don't block on failure\n   737→  if (segment.graphic) {\n   738→    try {\n   739→      await this._triggerGraphic(segment.graphic, segment.graphicData);\n   740→    } catch (error) {\n   741→      this._log('warn', `Graphic failed: ${error.message}`);\n   742→    }\n   743→  }\n   744→}\n   745→```\n   746→\n   747→---\n   748→\n   749→## 10. Testing Strategy\n   750→\n   751→### 10.1 Unit Tests\n   752→\n   753→| Component | Test File | Key Tests |\n   754→|-----------|-----------|-----------|\n   755→| TimesheetEngine | `server/lib/__tests__/timesheetEngine.test.js` | State transitions, timing accuracy, segment progression |\n   756→| Segment Mapper | `server/lib/__tests__/segmentMapper.test.js` | Editor → Engine format conversion |\n   757→| useTimesheet Hook | `show-controller/src/hooks/__tests__/useTimesheet.test.js` | State updates, action dispatching |\n   758→\n   759→### 10.2 Integration Tests\n   760→\n   761→| Scenario | Setup | Assertions |\n   762→|----------|-------|------------|\n   763→| Load rundown | Create test segments in Firebase | Segments appear in engine, state = LOADED |\n   764→| Start show | Load rundown, call startShow | First segment active, timer running |\n   765→| OBS integration | Mock OBS WebSocket | Scene change called with correct name |\n   766→| Multi-competition | Create 2 engines | Actions on one don't affect other |\n   767→| Live reload | Modify Firebase during show | Change detected, reload preserves position |\n   768→\n   769→### 10.3 End-to-End Tests (Playwright)\n   770→\n   771→```javascript\n   772→// E2E: Producer loads and runs show\n   773→test('producer can load and start show', async ({ page }) => {\n   774→  await page.goto('/comp123/producer');\n   775→\n   776→  // Load rundown\n   777→  await page.click('button:has-text(\"Load Rundown\")');\n   778→  await expect(page.locator('.segment-list')).toContainText('24 segments');\n   779→\n   780→  // Start show\n   781→  await page.click('button:has-text(\"Start Show\")');\n   782→  await expect(page.locator('.current-segment')).toContainText('Pre-Show');\n   783→  await expect(page.locator('.timer')).toBeVisible();\n   784→});\n   785→\n   786→// E2E: Live reload during show\n   787→test('producer can reload modified rundown', async ({ page }) => {\n   788→  await page.goto('/comp123/producer');\n   789→  await page.click('button:has-text(\"Load Rundown\")');\n   790→  await page.click('button:has-text(\"Start Show\")');\n   791→\n   792→  // Simulate Firebase change (via API)\n   793→  await addSegmentViaAPI('comp123', { name: 'Breaking News', duration: 60 });\n   794→\n   795→  // Verify warning appears\n   796→  await expect(page.locator('.rundown-modified-badge')).toBeVisible();\n   797→\n   798→  // Reload\n   799→  await page.click('button:has-text(\"Reload Rundown\")');\n   800→  await page.click('button:has-text(\"Reload Now\")');\n   801→\n   802→  // Verify new segment appears\n   803→  await expect(page.locator('.segment-list')).toContainText('Breaking News');\n   804→});\n   805→```\n   806→\n   807→### 10.4 Manual Test Checklist\n   808→\n   809→#### Phase A: Basic Flow\n   810→- [ ] Create rundown in Editor with 5 segments\n   811→- [ ] Navigate to Producer View\n   812→- [ ] Click \"Load Rundown\" - segments appear\n   813→- [ ] Click \"Start Show\" - timer starts, first segment active\n   814→- [ ] Wait for auto-advance - second segment activates\n   815→- [ ] Click \"Next\" on manual segment - advances\n   816→- [ ] Verify OBS scene changes (check OBS)\n   817→- [ ] Stop show - timer stops\n   818→\n   819→#### Phase H: Rehearsal\n   820→- [ ] Enable rehearsal mode\n   821→- [ ] Start show - timer runs\n   822→- [ ] Verify OBS does NOT change scenes\n   823→- [ ] Verify graphics do NOT fire\n   824→- [ ] \"REHEARSAL\" visible in all views\n   825→\n   826→#### Phase I: Live Sync\n   827→- [ ] Start show (not rehearsal)\n   828→- [ ] In new tab, edit rundown - add segment\n   829→- [ ] Return to Producer View - \"Modified\" badge visible\n   830→- [ ] Click \"Reload\" - new segment appears\n   831→- [ ] Position preserved (still on same segment)\n   832→\n   833→---\n   834→\n   835→## 11. Open Questions\n   836→\n   837→| Question | Status | Decision |\n   838→|----------|--------|----------|\n   839→| Quick scenes configuration - per-competition or global? | Open | Likely per-competition in Firebase |\n   840→| Should graphics fire via Firebase or socket.io? | Open | Currently socket.io only - may need both |\n   841→| AI service provider for suggestions/context? | Open | Claude API, OpenAI, or custom rules engine? |\n   842→| Audio playback mechanism? | Open | OBS media source, separate player, or browser? |\n   843→| Talent View mobile optimization? | Open | Responsive design or separate mobile app? |\n   844→| Rehearsal mode - same view or separate route? | Open | Likely same views with \"REHEARSAL\" badge |\n   845→\n   846→---\n   847→\n   848→## 12. Reference APIs\n   849→\n   850→### obsConnectionManager\n   851→\n   852→```javascript\n   853→obsConnectionManager.connectToVM(compId, vmAddress)  // Connect to competition's VM\n   854→obsConnectionManager.getConnection(compId)            // Get OBS WebSocket\n   855→obsConnectionManager.isConnected(compId)              // Check connection status\n   856→obsConnectionManager.getConnectionState(compId)       // Get full state\n   857→```\n   858→\n   859→### Firebase Paths\n   860→\n   861→```\n   862→competitions/{compId}/production/rundown/segments    # Rundown data\n   863→competitions/{compId}/production/rundown/metadata    # Rundown metadata\n   864→```\n   865→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"7cf9c903-89a7-4fb6-b3bf-1cf57626e419","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-2026-01-23.md","content":"# Implementation Plan: Rundown System\n\n**Version:** 1.0\n**Date:** 2026-01-23\n**Status:** Active\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-Implementation.md](./PLAN-Rundown-System-Implementation.md) | Implementation task tracking (use this for day-to-day execution) |\n\n**Note:** This document serves as the technical reference for architecture, state machine, socket events, error handling, and testing. For task execution and progress tracking, see the Implementation Plan.\n\n---\n\n## 1. Architecture Overview\n\n### 1.1 System Components\n\n```\nRUNDOWN (planning)              TIMESHEET (execution)\n──────────────────              ─────────────────────\nRundown Editor UI        →      Timesheet Engine (server)\nFirebase storage         →      useTimesheet hook (client)\n                                Timesheet UI (Producer View)\n```\n\n### 1.2 Data Flow\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│  PLANNING                                                                    │\n│                                                                              │\n│  Rundown Editor (/{compId}/rundown)                                         │\n│  └── Saves to: competitions/{compId}/production/rundown/segments            │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ \"Load Rundown\" (Phase A)\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────────┐\n│  EXECUTION                                                                   │\n│                                                                              │\n│  Timesheet Engine (server/lib/timesheetEngine.js)                           │\n│  ├── Runs segments with timing                                               │\n│  ├── Fires OBS scene changes (via obsConnectionManager)                      │\n│  ├── Triggers graphics                                                       │\n│  └── Broadcasts state via Socket.io (to competition room)                   │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ Socket.io events\n                                    ▼\n┌─────────────────────────────────────────────────────────────────────────────┐\n│  VIEWS                                                                       │\n│                                                                              │\n│  Producer View (/{compId}/producer)    Talent View (/{compId}/talent)       │\n│  ├── Now Playing                        ├── Time remaining                   │\n│  ├── Up Next                            ├── Current/Next segment             │\n│  ├── Show Control                       ├── Scene switching                  │\n│  └── Show Progress                      └── Notes                            │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### 1.3 Multi-Competition Architecture\n\n```\n┌──────────────────────────────────────────────────────────────────────────────┐\n│  COORDINATOR (api.commentarygraphic.com)                                     │\n│                                                                               │\n│  ┌─────────────────────────────────────────────────────────────────────────┐ │\n│  │  obsConnectionManager (per-competition OBS connections)                  │ │\n│  │  ├── compId: abc123 → OBS WebSocket to VM 50.19.137.152:4455            │ │\n│  │  └── compId: xyz789 → OBS WebSocket to VM 54.210.98.89:4455             │ │\n│  └─────────────────────────────────────────────────────────────────────────┘ │\n│                                                                               │\n│  ┌─────────────────────────────────────────────────────────────────────────┐ │\n│  │  timesheetEngines Map (per-competition execution)                        │ │\n│  │  ├── compId: abc123 → TimesheetEngine instance                          │ │\n│  │  └── compId: xyz789 → TimesheetEngine instance                          │ │\n│  └─────────────────────────────────────────────────────────────────────────┘ │\n│                                                                               │\n│  Socket.io rooms: competition:abc123, competition:xyz789                     │\n└──────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 2. Show State Machine\n\n```\n                              ┌─────────────────────────────────────────┐\n                              │                                         │\n                              ▼                                         │\n┌─────────┐  loadRundown  ┌────────┐  startShow  ┌─────────┐           │\n│  IDLE   │──────────────▶│ LOADED │────────────▶│ RUNNING │           │\n└─────────┘               └────────┘             └─────────┘           │\n     ▲                         ▲                      │                │\n     │                         │                      │ pauseShow      │\n     │                         │                      ▼                │\n     │                         │                 ┌─────────┐           │\n     │                         │ resumeShow      │ PAUSED  │           │\n     │                         │◀────────────────┴─────────┘           │\n     │                         │                      │                │\n     │                    reloadRundown               │                │\n     │                         │                      │                │\n     │                         │                      │ stopShow       │\n     │   resetShow        ┌────────┐                  │                │\n     │◀───────────────────│STOPPED │◀─────────────────┘                │\n     │                    └────────┘                                   │\n     │                         │                                       │\n     │                         │ segment reaches end                   │\n     │                         ▼                                       │\n     │                    ┌──────────┐  (auto if last segment)         │\n     └────────────────────│ COMPLETE │─────────────────────────────────┘\n                          └──────────┘\n```\n\n### State Definitions\n\n| State | Description | Valid Actions |\n|-------|-------------|---------------|\n| `IDLE` | No rundown loaded | `loadRundown` |\n| `LOADED` | Rundown loaded, ready to start | `startShow`, `reloadRundown`, `resetShow` |\n| `RUNNING` | Show in progress, timer active | `pauseShow`, `stopShow`, `nextSegment`, `prevSegment`, `jumpToSegment` |\n| `PAUSED` | Show paused, timer frozen | `resumeShow`, `stopShow`, `reloadRundown` |\n| `STOPPED` | Show stopped before completion | `resetShow`, `reloadRundown` |\n| `COMPLETE` | All segments finished | `resetShow`, `reloadRundown` |\n\n### State Transitions\n\n| From | Event | To | Side Effects |\n|------|-------|----|--------------|\n| IDLE | `loadRundown` | LOADED | Fetch segments from Firebase, initialize engine |\n| LOADED | `startShow` | RUNNING | Activate first segment, start timer, fire OBS/graphics |\n| RUNNING | `pauseShow` | PAUSED | Freeze timer, keep current segment |\n| PAUSED | `resumeShow` | RUNNING | Resume timer |\n| RUNNING | `stopShow` | STOPPED | Stop timer, log analytics |\n| PAUSED | `stopShow` | STOPPED | Log analytics |\n| RUNNING | segment ends (last) | COMPLETE | Log analytics, show complete indicator |\n| STOPPED | `resetShow` | IDLE | Clear segments, reset state |\n| COMPLETE | `resetShow` | IDLE | Clear segments, reset state |\n| LOADED/PAUSED/STOPPED | `reloadRundown` | LOADED | Re-fetch segments, preserve position if possible |\n\n---\n\n## 3. Task Dependency Graph\n\n```\nPHASE A (P0): Connect Editor to Engine\n═══════════════════════════════════════\n\nA.0.1 ──┬──▶ A.0.3 ──┐\n        │            │\nA.0.2 ──┼──▶ A.0.4 ──┼──▶ A.0.6 ──┐\n        │            │            │\n        └──▶ A.0.5 ──┘            │\n                                  │\nA.0.7 ────────────────────────────┼──▶ A.1 ──▶ A.2 ──▶ A.3\n                                  │            │\n                                  │            ▼\n                                  │           A.4 ──▶ A.5 ──▶ A.6\n                                  │\n                                  └──▶ A.5.1 ──┬──▶ A.5.3\n                                       A.5.2 ──┘\n\nPHASE H (P1): Rehearsal Mode          PHASE B (P1): Talent View\n══════════════════════════════        ════════════════════════════\n\n     ┌──▶ H.2 ──┐                          B.1 ──▶ B.2 ──┐\n     │          │                                        │\nH.1 ─┼──▶ H.3 ──┼──▶ H.4 ──▶ H.5               B.3 ──────┤\n     │          │                                        │\n     └──────────┘                          B.4 ──▶ B.5 ──┼──▶ B.6\n                                                         │\n                                                         ▼\nPHASE I (P2): Live Rundown Sync       ◄───── DEPENDS ON PHASE A\n══════════════════════════════════\n\nI.1 ──▶ I.2 ──▶ I.3 ──┬──▶ I.5 ──▶ I.6 ──▶ I.7\n                      │\n                      └──▶ I.4\n```\n\n### Critical Path (Minimum for MVP)\n\n```\nA.0.1 → A.0.2 → A.0.3 → A.0.6 → A.1 → A.2 → A.3 → A.4 → A.6\n  │\n  └──▶ \"Producer can load rundown and start show\"\n```\n\n### Parallel Work Opportunities\n\n| Can Run In Parallel | Reason |\n|---------------------|--------|\n| A.0.3, A.0.4, A.0.5 | Independent OBS method updates |\n| A.5.1, A.5.2 | Independent picker verification |\n| Phase H, Phase B | No dependencies on each other (both depend on A) |\n| H.2, H.3 | Independent skip logic |\n\n---\n\n## 4. Key Files\n\n### Server\n| File | Purpose | Changes Required |\n|------|---------|------------------|\n| `server/index.js` | Coordinator entry point, socket handlers | Add `timesheetEngines` Map, `loadRundown` handler |\n| `server/lib/timesheetEngine.js` | Show execution engine (~1187 lines) | Accept `compId`, `obsConnectionManager`; update OBS calls |\n| `server/lib/obsConnectionManager.js` | Per-competition OBS WebSocket connections | Already supports multi-competition ✅ |\n| `server/lib/vmPoolManager.js` | EC2 VM assignment and lifecycle | No changes needed |\n| `server/lib/productionConfigService.js` | Firebase Admin initialization | Export `db` for engine use |\n\n### Client\n| File | Purpose | Changes Required |\n|------|---------|------------------|\n| `show-controller/src/hooks/useTimesheet.js` | Client hook for timesheet state | Add `loadRundown`, `reloadRundown` actions |\n| `show-controller/src/context/ShowContext.jsx` | Shared state, socket connection | Emit `loadRundown` event |\n| `show-controller/src/pages/RundownEditorPage.jsx` | Rundown planning UI | Verify pickers use live data |\n| `show-controller/src/views/ProducerView.jsx` | Production control + Timesheet UI | Add Load/Reload buttons, status indicator |\n| `show-controller/src/components/CurrentSegment.jsx` | Now Playing display | No changes needed |\n| `show-controller/src/components/NextSegment.jsx` | Up Next display | No changes needed |\n| `show-controller/src/components/RunOfShow.jsx` | Show Progress list | Add \"modified\" badge |\n\n---\n\n## 5. Code Audit (2026-01-23)\n\n### 5.1 Current State\n\n| Component | Code Exists | Actually Works |\n|-----------|-------------|----------------|\n| Timesheet Engine | ✅ ~1200 lines | ⚠️ Not wired to Firebase/OBS properly |\n| useTimesheet Hook | ✅ | ✅ Works |\n| Timesheet UI | ✅ | ✅ Works |\n| Rundown Editor | ✅ | ⚠️ Pickers need verification |\n\n### 5.2 Critical Gap: Single Global Instance\n\n**Current (Wrong):** `server/index.js` lines 250-255\n```javascript\n// Single global instance - can only control one competition\nlet timesheetEngine;\n\nfunction initializeTimesheetEngine() {\n  timesheetEngine = new TimesheetEngine({\n    showConfig,\n    obs,        // ❌ Single OBS connection\n    io\n    // MISSING: firebase, compId, obsConnectionManager\n  });\n}\n```\n\n**Required (Correct):**\n```javascript\n// Map of per-competition instances\nconst timesheetEngines = new Map();\n\nfunction getOrCreateEngine(compId, obsConnectionManager, firebase, io) {\n  if (!timesheetEngines.has(compId)) {\n    const engine = new TimesheetEngine({\n      compId,\n      obsConnectionManager,\n      firebase,\n      io\n    });\n    timesheetEngines.set(compId, engine);\n  }\n  return timesheetEngines.get(compId);\n}\n```\n\n### 5.3 Methods Requiring Updates\n\n| Method | Current | Required Change |\n|--------|---------|-----------------|\n| `_applyTransitionAndSwitchScene()` | `this.obs.call(...)` | Use `obsConnectionManager.getConnection(compId)` |\n| `_triggerGraphic()` | `this.firebase` (never provided) | Pass Firebase Admin in constructor |\n| `_playVideo()` | `this.obs.call(...)` | Use per-competition OBS |\n| `_applyAudioOverrides()` | `this.obs.call(...)` | Use per-competition OBS |\n| Event broadcasts | `this.io.emit(...)` | `this.io.to('competition:${compId}').emit(...)` |\n\n---\n\n## 6. Socket Events\n\n### 6.1 Client → Server (Commands)\n\n#### `loadRundown`\nLoad segments from Firebase into the engine.\n\n```javascript\n// Request\nsocket.emit('loadRundown', { compId: 'abc123' });\n\n// Response (via timesheetState)\n// Engine state with segments loaded\n```\n\n#### `startShow`\nBegin show execution.\n\n```javascript\nsocket.emit('startShow', { compId: 'abc123' });\n```\n\n#### `stopShow`\nStop show execution.\n\n```javascript\nsocket.emit('stopShow', { compId: 'abc123' });\n```\n\n#### `pauseShow` / `resumeShow`\nPause or resume the current show.\n\n```javascript\nsocket.emit('pauseShow', { compId: 'abc123' });\nsocket.emit('resumeShow', { compId: 'abc123' });\n```\n\n#### `nextSegment` / `prevSegment`\nAdvance to next or previous segment.\n\n```javascript\nsocket.emit('nextSegment', { compId: 'abc123' });\nsocket.emit('prevSegment', { compId: 'abc123' });\n```\n\n#### `jumpToSegment`\nJump to a specific segment by ID.\n\n```javascript\nsocket.emit('jumpToSegment', { compId: 'abc123', segmentId: 'segment-5' });\n```\n\n#### `reloadRundown`\nHot-reload rundown from Firebase (Phase I).\n\n```javascript\nsocket.emit('reloadRundown', { compId: 'abc123' });\n```\n\n### 6.2 Server → Client (State Updates)\n\n#### `timesheetState`\nFull state update (sent on load, major changes).\n\n```javascript\n{\n  showState: 'RUNNING',           // IDLE | LOADED | RUNNING | PAUSED | STOPPED | COMPLETE\n  isRehearsalMode: false,\n  segments: [\n    {\n      id: 'segment-1',\n      name: 'Pre-Show Graphics',\n      type: 'graphics',\n      duration: 30,\n      obsScene: 'Pre-Show',\n      graphic: 'logos',\n      graphicData: { teamIds: ['ucla', 'oregon'] },\n      autoAdvance: true,\n      notes: 'Wait for countdown'\n    },\n    // ... more segments\n  ],\n  currentSegmentIndex: 3,\n  currentSegmentId: 'segment-4',\n  elapsedTime: 45,                // seconds into current segment\n  totalElapsed: 320,              // seconds since show start\n  rundownModified: false,         // true if Firebase changed since load\n  rundownModifiedSummary: null    // { added: [], removed: [], modified: [] }\n}\n```\n\n#### `timesheetTick`\nLightweight timing update (sent every second during RUNNING state).\n\n```javascript\n{\n  currentSegmentIndex: 3,\n  elapsedTime: 46,                // seconds into current segment\n  remainingTime: 14,              // seconds remaining in segment\n  totalElapsed: 321,\n  progress: 0.77                  // 0-1 progress through segment\n}\n```\n\n#### `timesheetSegmentActivated`\nSent when a new segment becomes active.\n\n```javascript\n{\n  previousSegmentId: 'segment-3',\n  previousSegmentIndex: 2,\n  currentSegmentId: 'segment-4',\n  currentSegmentIndex: 3,\n  segment: {\n    id: 'segment-4',\n    name: 'UCLA Introduction',\n    duration: 30,\n    obsScene: 'Team-Intro',\n    // ... full segment data\n  },\n  nextSegment: {\n    id: 'segment-5',\n    name: 'Oregon Introduction',\n    // ... preview of next\n  }\n}\n```\n\n#### `timesheetShowStarted`\nShow has started.\n\n```javascript\n{\n  startedAt: '2026-01-23T19:00:00.000Z',\n  totalSegments: 24,\n  firstSegment: { id: 'segment-1', name: 'Pre-Show Graphics' }\n}\n```\n\n#### `timesheetShowStopped`\nShow was stopped (not complete).\n\n```javascript\n{\n  stoppedAt: '2026-01-23T19:45:00.000Z',\n  lastSegmentIndex: 12,\n  reason: 'manual'                // manual | error\n}\n```\n\n#### `timesheetShowComplete`\nAll segments finished.\n\n```javascript\n{\n  completedAt: '2026-01-23T20:30:00.000Z',\n  totalDuration: 5400,            // seconds\n  segmentCount: 24\n}\n```\n\n#### `rundownModified` (Phase I)\nFirebase rundown changed while show is loaded/running.\n\n```javascript\n{\n  added: ['segment-25'],\n  removed: [],\n  modified: ['segment-12'],\n  affectsCurrent: false,\n  affectsUpcoming: true,\n  timestamp: '2026-01-23T19:32:00.000Z'\n}\n```\n\n#### `obsError`\nOBS operation failed (non-fatal).\n\n```javascript\n{\n  operation: 'sceneChange',\n  scene: 'Team-Intro',\n  error: 'Scene not found',\n  segmentId: 'segment-4'\n}\n```\n\n---\n\n## 7. Segment Data Mapping\n\n| Editor Field | Engine Field | Notes |\n|--------------|--------------|-------|\n| `id` | `id` | Direct copy |\n| `name` | `name` | Direct copy |\n| `type` | `type` | Direct copy |\n| `duration` | `duration` | In seconds |\n| `scene` | `obsScene` | OBS scene name |\n| `graphic.graphicId` | `graphic` | Graphic identifier |\n| `graphic.params` | `graphicData` | Graphic parameters |\n| `timingMode` | `autoAdvance` | 'fixed' → true, 'manual' → false |\n| `notes` | `notes` | Direct copy |\n\n---\n\n## 8. Task Breakdown\n\n### Phase A: Connect Editor to Engine (P0)\n\n#### A.0: Refactor TimesheetEngine for Multi-Competition (PREREQUISITE)\n\n- [ ] **A.0.1** Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager`\n- [ ] **A.0.2** Create `timesheetEngines` Map in server/index.js\n- [ ] **A.0.3** Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)`\n- [ ] **A.0.4** Update `_playVideo()` to use per-competition OBS connection\n- [ ] **A.0.5** Update `_applyAudioOverrides()` to use per-competition OBS connection\n- [ ] **A.0.6** Update all socket event broadcasts to target competition room: `io.to('competition:${compId}')`\n- [ ] **A.0.7** Pass Firebase Admin instance to engine for `_triggerGraphic()`\n\n#### A.1-A.6: Build Load Rundown Feature\n\n- [ ] **A.1** Add `loadRundown` socket handler on server (creates/updates engine for compId)\n- [ ] **A.2** Add `loadRundown` action in ShowContext\n- [ ] **A.3** Add \"Load Rundown\" button in Producer View\n- [ ] **A.4** Create segment mapper (Editor format → Engine format)\n- [ ] **A.5** Verify Firebase is passed to engine\n- [ ] **A.6** Show rundown status indicator (loaded, modified, etc.)\n\n#### A.5x: Verify Pickers\n\n- [ ] **A.5.1** Verify Rundown Editor scene picker uses OBS state\n- [ ] **A.5.2** Verify Rundown Editor graphics picker uses Graphics Registry\n- [ ] **A.5.3** Fix any hardcoded picker data\n\n---\n\n### Phase H: Rehearsal Mode (P1)\n\n- [ ] **H.1** Add rehearsal mode toggle to Timesheet Engine\n- [ ] **H.2** Skip OBS scene changes in rehearsal mode\n- [ ] **H.3** Skip graphics firing in rehearsal mode\n- [ ] **H.4** Show \"REHEARSAL\" indicator in all views\n- [ ] **H.5** Log timing data for post-rehearsal analysis\n\n---\n\n### Phase B: Talent View (P1)\n\n- [ ] **B.1** Create `TalentView.jsx` page\n- [ ] **B.2** Current segment with prominent time remaining\n- [ ] **B.3** Scene switching buttons\n- [ ] **B.4** Next segment preview\n- [ ] **B.5** Notes display\n- [ ] **B.6** Add `/talent` route\n\n**Layout Reference:**\n```\n┌─────────────────────────────────────────────────────────────────┐\n│  TALENT VIEW                                   [Scene Buttons]  │\n├─────────────────────────────────────────────────────────────────┤\n│  ┌─ CURRENT SEGMENT ──────────────────────────────────────────┐ │\n│  │  UCLA Introduction                                          │ │\n│  │                                                             │ │\n│  │              0:22 REMAINING                                 │ │\n│  │              (of 0:30)                                      │ │\n│  │                                                             │ │\n│  │  [████████████████████████░░░░░░░░░░░░] 73%                │ │\n│  │                                                             │ │\n│  │  NOTES: Wait for applause to die down                      │ │\n│  └─────────────────────────────────────────────────────────────┘ │\n│                                                                 │\n│  ┌─ UP NEXT ──────────────────────────────────────────────────┐ │\n│  │  Oregon Introduction (0:30)                                 │ │\n│  └─────────────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n### Phase I: Live Rundown Sync (P2)\n\n#### I.1-I.3: Change Detection\n\n- [ ] **I.1** Subscribe to Firebase `rundown/segments` changes on server (use `onValue` listener)\n- [ ] **I.2** Compare incoming segments to loaded segments (deep diff)\n- [ ] **I.3** Emit `rundownModified` socket event with change summary:\n  ```javascript\n  {\n    added: ['segment-id-1'],\n    removed: ['segment-id-2'],\n    modified: ['segment-id-3'],\n    affectsCurrent: false,  // true if current segment was modified/deleted\n    affectsUpcoming: true   // true if any future segment changed\n  }\n  ```\n\n#### I.4-I.5: UI Indicators\n\n- [ ] **I.4** Add `rundownModified` state to `useTimesheet` hook\n- [ ] **I.5** Show \"Rundown Modified\" warning badge in Producer View header\n  - Yellow badge if only future segments changed\n  - Red badge if current segment affected\n  - Show count: \"3 segments changed\"\n\n#### I.6-I.7: Reload Flow\n\n- [ ] **I.6** Add \"Reload Rundown\" button (appears when modified)\n- [ ] **I.7** Confirmation dialog with change summary:\n  ```\n  ┌─────────────────────────────────────────────┐\n  │  Reload Rundown?                            │\n  ├─────────────────────────────────────────────┤\n  │  Changes detected:                          │\n  │  • 1 segment added                          │\n  │  • 2 segments modified                      │\n  │                                             │\n  │  Current position will be preserved.        │\n  │  You are on segment 12 of 24.               │\n  │                                             │\n  │  [Cancel]                    [Reload Now]   │\n  └─────────────────────────────────────────────┘\n  ```\n\n#### I.8-I.10: Edge Case Handling\n\n- [ ] **I.8** Handle deleted current segment:\n  - Keep segment active until manual advance\n  - Show warning: \"Current segment was deleted from rundown\"\n  - On advance, skip to next valid segment\n- [ ] **I.9** Handle reordered past segments:\n  - Ignore changes to segments before current index\n  - Only apply changes to current and future segments\n- [ ] **I.10** Handle ID conflicts:\n  - Match segments by ID, not index\n  - If current segment ID still exists, stay on it regardless of new position\n\n---\n\n### Phase J: Segment Timing Analytics (P2)\n\n- [ ] **J.1** Log actual segment durations during show\n- [ ] **J.2** Store timing data in Firebase post-show\n- [ ] **J.3** Create timing analytics dashboard\n- [ ] **J.4** Show historical average in Rundown Editor\n- [ ] **J.5** AI-powered timing predictions based on history\n\n---\n\n### Phase D: AI Suggestions - Planning (P2)\n\n- [ ] **D.1** Create AI suggestion service on server\n- [ ] **D.2** Analyze competition metadata (type, teams, date)\n- [ ] **D.3** Query roster data for seniors, All-Americans, milestones\n- [ ] **D.4** Generate segment suggestions with confidence scores\n- [ ] **D.5** Add `getAISuggestions` API endpoint\n- [ ] **D.6** Wire Rundown Editor to display suggestions\n\n---\n\n### Phase E: Script & Talent Flow (P2)\n\n- [ ] **E.1** Add script field to segment data model\n- [ ] **E.2** Pipe script field through Timesheet Engine\n- [ ] **E.3** Display script in Talent View (teleprompter-style)\n- [ ] **E.4** Add talent assignment to segment data model\n- [ ] **E.5** Create talent schedule view\n- [ ] **E.6** Show \"you're on camera\" indicator in Talent View\n\n---\n\n### Phase C: AI Context - Live Execution (P3)\n\n- [ ] **C.1** Create AIContextService stub\n- [ ] **C.2** Add `aiContextUpdated` socket event\n- [ ] **C.3** Create `useAIContext` hook\n- [ ] **C.4** Integrate with Virtius API for live stats\n- [ ] **C.5** Generate talking points in real-time\n- [ ] **C.6** Detect career highs, records during show\n- [ ] **C.7** Display AI context in Talent View\n- [ ] **C.8** Display AI context in Producer View\n\n---\n\n### Phase F: Audio Cue Integration (P3)\n\n- [ ] **F.1** Add audio cue fields to segment data model\n- [ ] **F.2** Pipe audio cues through Timesheet Engine\n- [ ] **F.3** Trigger audio playback on segment start\n- [ ] **F.4** Add audio control to Producer View\n\n---\n\n### Phase G: Production Tracking (P3)\n\n- [ ] **G.1** Add equipment fields to segment data model\n- [ ] **G.2** Generate equipment schedule report\n- [ ] **G.3** Detect equipment conflicts\n- [ ] **G.4** Add sponsor fields to segment data model\n- [ ] **G.5** Generate sponsor fulfillment report\n\n---\n\n## 9. Error Handling\n\n### 9.1 OBS Connection Failures\n\n| Scenario | Detection | Response | User Feedback |\n|----------|-----------|----------|---------------|\n| OBS disconnects mid-show | `obsConnectionManager` emits `disconnected` | Continue show, queue scene changes | \"OBS Disconnected\" badge, retry button |\n| OBS reconnects | `obsConnectionManager` emits `connected` | Replay last scene change | \"OBS Connected\" toast |\n| Scene change fails | OBS WebSocket error | Log error, continue show | \"Scene change failed\" toast |\n| Scene doesn't exist | OBS returns error | Skip scene change, log | \"Scene 'X' not found\" warning |\n\n### 9.2 Firebase Failures\n\n| Scenario | Detection | Response | User Feedback |\n|----------|-----------|----------|---------------|\n| Firebase read fails | Promise rejection in `loadRundown` | Retry 3x with backoff | \"Failed to load rundown\" error |\n| Firebase write fails | Promise rejection in analytics | Queue for retry | Silent (non-critical) |\n| Firebase listener disconnects | `onValue` error callback | Reconnect automatically | \"Sync paused\" indicator |\n\n### 9.3 Show Execution Errors\n\n| Scenario | Detection | Response | User Feedback |\n|----------|-----------|----------|---------------|\n| Segment has no duration | Validation on load | Default to 30s, warn | \"Segment X has no duration\" warning |\n| Segment has invalid scene | Validation on load | Skip scene change | \"Invalid scene in segment X\" warning |\n| Timer drift > 1s | Periodic sync check | Correct timer | Silent correction |\n| Engine crashes | Uncaught exception | Restart engine, preserve state | \"Show engine restarted\" warning |\n\n### 9.4 Recovery Strategies\n\n```javascript\n// Graceful degradation for OBS failures\nasync function executeSegmentWithFallback(segment) {\n  try {\n    await this._applyTransitionAndSwitchScene(segment.obsScene);\n  } catch (error) {\n    this._log('warn', `Scene change failed: ${error.message}`);\n    this._emit('obsError', { segment: segment.id, error: error.message });\n    // Continue show - don't block on OBS failures\n  }\n\n  // Graphics are optional - don't block on failure\n  if (segment.graphic) {\n    try {\n      await this._triggerGraphic(segment.graphic, segment.graphicData);\n    } catch (error) {\n      this._log('warn', `Graphic failed: ${error.message}`);\n    }\n  }\n}\n```\n\n---\n\n## 10. Testing Strategy\n\n### 10.1 Unit Tests\n\n| Component | Test File | Key Tests |\n|-----------|-----------|-----------|\n| TimesheetEngine | `server/lib/__tests__/timesheetEngine.test.js` | State transitions, timing accuracy, segment progression |\n| Segment Mapper | `server/lib/__tests__/segmentMapper.test.js` | Editor → Engine format conversion |\n| useTimesheet Hook | `show-controller/src/hooks/__tests__/useTimesheet.test.js` | State updates, action dispatching |\n\n### 10.2 Integration Tests\n\n| Scenario | Setup | Assertions |\n|----------|-------|------------|\n| Load rundown | Create test segments in Firebase | Segments appear in engine, state = LOADED |\n| Start show | Load rundown, call startShow | First segment active, timer running |\n| OBS integration | Mock OBS WebSocket | Scene change called with correct name |\n| Multi-competition | Create 2 engines | Actions on one don't affect other |\n| Live reload | Modify Firebase during show | Change detected, reload preserves position |\n\n### 10.3 End-to-End Tests (Playwright)\n\n```javascript\n// E2E: Producer loads and runs show\ntest('producer can load and start show', async ({ page }) => {\n  await page.goto('/comp123/producer');\n\n  // Load rundown\n  await page.click('button:has-text(\"Load Rundown\")');\n  await expect(page.locator('.segment-list')).toContainText('24 segments');\n\n  // Start show\n  await page.click('button:has-text(\"Start Show\")');\n  await expect(page.locator('.current-segment')).toContainText('Pre-Show');\n  await expect(page.locator('.timer')).toBeVisible();\n});\n\n// E2E: Live reload during show\ntest('producer can reload modified rundown', async ({ page }) => {\n  await page.goto('/comp123/producer');\n  await page.click('button:has-text(\"Load Rundown\")');\n  await page.click('button:has-text(\"Start Show\")');\n\n  // Simulate Firebase change (via API)\n  await addSegmentViaAPI('comp123', { name: 'Breaking News', duration: 60 });\n\n  // Verify warning appears\n  await expect(page.locator('.rundown-modified-badge')).toBeVisible();\n\n  // Reload\n  await page.click('button:has-text(\"Reload Rundown\")');\n  await page.click('button:has-text(\"Reload Now\")');\n\n  // Verify new segment appears\n  await expect(page.locator('.segment-list')).toContainText('Breaking News');\n});\n```\n\n### 10.4 Manual Test Checklist\n\n#### Phase A: Basic Flow\n- [ ] Create rundown in Editor with 5 segments\n- [ ] Navigate to Producer View\n- [ ] Click \"Load Rundown\" - segments appear\n- [ ] Click \"Start Show\" - timer starts, first segment active\n- [ ] Wait for auto-advance - second segment activates\n- [ ] Click \"Next\" on manual segment - advances\n- [ ] Verify OBS scene changes (check OBS)\n- [ ] Stop show - timer stops\n\n#### Phase H: Rehearsal\n- [ ] Enable rehearsal mode\n- [ ] Start show - timer runs\n- [ ] Verify OBS does NOT change scenes\n- [ ] Verify graphics do NOT fire\n- [ ] \"REHEARSAL\" visible in all views\n\n#### Phase I: Live Sync\n- [ ] Start show (not rehearsal)\n- [ ] In new tab, edit rundown - add segment\n- [ ] Return to Producer View - \"Modified\" badge visible\n- [ ] Click \"Reload\" - new segment appears\n- [ ] Position preserved (still on same segment)\n\n---\n\n## 11. Open Questions\n\n| Question | Status | Decision |\n|----------|--------|----------|\n| Quick scenes configuration - per-competition or global? | Open | Likely per-competition in Firebase |\n| Should graphics fire via Firebase or socket.io? | Open | Currently socket.io only - may need both |\n| AI service provider for suggestions/context? | Open | Claude API, OpenAI, or custom rules engine? |\n| Audio playback mechanism? | Open | OBS media source, separate player, or browser? |\n| Talent View mobile optimization? | Open | Responsive design or separate mobile app? |\n| Rehearsal mode - same view or separate route? | Open | Likely same views with \"REHEARSAL\" badge |\n\n---\n\n## 12. Reference APIs\n\n### obsConnectionManager\n\n```javascript\nobsConnectionManager.connectToVM(compId, vmAddress)  // Connect to competition's VM\nobsConnectionManager.getConnection(compId)            // Get OBS WebSocket\nobsConnectionManager.isConnected(compId)              // Check connection status\nobsConnectionManager.getConnectionState(compId)       // Get full state\n```\n\n### Firebase Paths\n\n```\ncompetitions/{compId}/production/rundown/segments    # Rundown data\ncompetitions/{compId}/production/rundown/metadata    # Rundown metadata\n```\n","numLines":865,"startLine":1,"totalLines":865}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C47zLEJFnppyruNAhccCbn","type":"message","role":"assistant","content":[{"type":"text","text":"```\n1.3 Detailed Plan Read\n- Current phase: Phase A (P0) - Connect Editor to Engine (prerequisite for all other phases)\n- Relevant details noted: Multi-competition architecture requires Map-based engine instances, Socket.io rooms for isolation, Firebase Admin for graphics, OBS connection manager for per-competition scene switching\n```\n\n### Step 1.4 - Read Infrastructure Reference"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":12543,"cache_read_input_tokens":36954,"cache_creation":{"ephemeral_5m_input_tokens":12543,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"0aec7b01-7c4c-4de2-a66b-d010b31cfeba"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01C47zLEJFnppyruNAhccCbn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KBuRT996qjL7GqtmGuoWFx","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/INFRASTRUCTURE.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":12543,"cache_read_input_tokens":36954,"cache_creation":{"ephemeral_5m_input_tokens":12543,"ephemeral_1h_input_tokens":0},"output_tokens":163,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"a8a97de2-fdf0-4ac6-ba08-42bcf20f51f5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KBuRT996qjL7GqtmGuoWFx","type":"tool_result","content":"     1→# Infrastructure Reference\n     2→\n     3→**Last Updated:** 2026-01-22\n     4→\n     5→Quick reference for VMs, networking, and server architecture. For OBS-specific details, see [README-OBS-Architecture.md](README-OBS-Architecture.md).\n     6→\n     7→---\n     8→\n     9→## VM Inventory\n    10→\n    11→| VM | IP | Domain | Purpose |\n    12→|----|-----|--------|---------|\n    13→| **Coordinator** | 44.193.31.120 | api.commentarygraphic.com | Central hub, proxies all frontend connections |\n    14→| **Frontend** | 3.87.107.201 | commentarygraphic.com | Static file hosting (React SPA) |\n    15→| **Competition VMs** | Dynamic | None | Run OBS, one per competition |\n    16→\n    17→---\n    18→\n    19→## Connection Architecture\n    20→\n    21→```\n    22→┌─────────────────────────────────────────────────────────────┐\n    23→│  User's Browser (React App)                                 │\n    24→│  - Downloaded from commentarygraphic.com                    │\n    25→│  - ALL connections go to api.commentarygraphic.com          │\n    26→└─────────────────────────────────────────────────────────────┘\n    27→                              │\n    28→                              │ HTTPS / WSS (port 443)\n    29→                              ▼\n    30→┌─────────────────────────────────────────────────────────────┐\n    31→│  COORDINATOR (api.commentarygraphic.com)                    │\n    32→│  - nginx (SSL termination)                                  │\n    33→│  - Node.js server (port 3001, PM2 managed)                  │\n    34→│  - Routes requests to correct competition VM                │\n    35→└─────────────────────────────────────────────────────────────┘\n    36→                              │\n    37→                              │ Internal (ws://, no SSL)\n    38→                              ▼\n    39→┌─────────────────────────────────────────────────────────────┐\n    40→│  COMPETITION VM (e.g., 50.19.137.152)                       │\n    41→│  - OBS Studio (headless, port 4455 localhost only)          │\n    42→│  - Show Server (Node.js, port 3003)                         │\n    43→│  - SRT inputs (ports 9001-9010)                             │\n    44→└─────────────────────────────────────────────────────────────┘\n    45→```\n    46→\n    47→**Key point:** Frontend NEVER connects directly to competition VMs. The coordinator proxies everything.\n    48→\n    49→**Why:** Mixed content security. HTTPS pages can't connect to HTTP/WS endpoints. The coordinator has SSL; competition VMs don't.\n    50→\n    51→---\n    52→\n    53→## Network Ports\n    54→\n    55→| Port | VM | Service | Access |\n    56→|------|-----|---------|--------|\n    57→| 443 | Coordinator | nginx (HTTPS) | Public |\n    58→| 3001 | Coordinator | Node.js server | Internal (via nginx) |\n    59→| 3003 | Competition | Show Server | Public |\n    60→| 4455 | Competition | OBS WebSocket | localhost only |\n    61→| 9001-9010 | Competition | SRT camera inputs | Public |\n    62→| 22 | All | SSH | Admin only |\n    63→\n    64→---\n    65→\n    66→## Firebase Paths\n    67→\n    68→```\n    69→competitions/\n    70→  {compId}/\n    71→    config/\n    72→      vmAddress: \"50.19.137.152:3003\"    # Assigned VM\n    73→      eventName: \"UCLA vs Stanford\"\n    74→      gender: \"womens\"\n    75→    obs/\n    76→      state/\n    77→        connected: true\n    78→        currentScene: \"Camera 1\"\n    79→\n    80→vmPool/\n    81→  config/\n    82→    warmCount: 2                          # Running VMs to keep ready\n    83→    coldCount: 3                          # Stopped VMs available\n    84→  vms/\n    85→    {vmId}/\n    86→      instanceId: \"i-xxx\"\n    87→      status: \"assigned\" | \"available\" | \"stopped\"\n    88→      assignedTo: \"8kyf0rnl\"              # Competition ID\n    89→      publicIp: \"50.19.137.152\"\n    90→\n    91→teamsDatabase/\n    92→  teams/{team-key}/                       # Team info and rosters\n    93→  headshots/{athlete-name}/               # Athlete photos\n    94→  aliases/{alias}/                        # Team name aliases\n    95→```\n    96→\n    97→---\n    98→\n    99→## Routing Flow\n   100→\n   101→1. User navigates to `https://commentarygraphic.com/{compId}/producer`\n   102→2. React app extracts `compId` from URL\n   103→3. App connects Socket.io to `https://api.commentarygraphic.com` with `compId` in query\n   104→4. Coordinator looks up VM for that competition in Firebase\n   105→5. Coordinator connects to VM and proxies all traffic\n   106→\n   107→---\n   108→\n   109→## Key Services\n   110→\n   111→### Coordinator (44.193.31.120)\n   112→```bash\n   113→# Check status\n   114→ssh_exec target=\"coordinator\" command=\"pm2 list\"\n   115→\n   116→# View logs\n   117→ssh_exec target=\"coordinator\" command=\"pm2 logs coordinator --lines 50\"\n   118→\n   119→# Restart\n   120→ssh_exec target=\"coordinator\" command=\"pm2 restart coordinator\"\n   121→\n   122→# Deploy updates\n   123→ssh_exec target=\"coordinator\" command=\"cd /opt/gymnastics-graphics && sudo git pull --rebase origin main && pm2 restart coordinator\"\n   124→```\n   125→\n   126→### Competition VM\n   127→```bash\n   128→# Check OBS status\n   129→ssh_exec target=\"{VM_IP}\" command=\"systemctl status obs\"\n   130→\n   131→# Check Show Server\n   132→ssh_exec target=\"{VM_IP}\" command=\"pm2 list\"\n   133→\n   134→# View OBS logs\n   135→ssh_exec target=\"{VM_IP}\" command=\"journalctl -u obs -n 50\"\n   136→```\n   137→\n   138→---\n   139→\n   140→## Current AMI\n   141→\n   142→| Property | Value |\n   143→|----------|-------|\n   144→| AMI ID | `ami-070ce58462b2b9213` |\n   145→| Name | gymnastics-vm-v2.2 |\n   146→| Config location | `server/lib/awsService.js` line 34 |\n   147→\n   148→New VMs launched by VM Pool Manager use this AMI automatically.\n   149→\n   150→---\n   151→\n   152→## Quick Debugging\n   153→\n   154→| Symptom | Check |\n   155→|---------|-------|\n   156→| Frontend can't connect | Is coordinator running? `curl https://api.commentarygraphic.com/api/coordinator/status` |\n   157→| Competition not loading | Is VM assigned? Check `competitions/{compId}/config/vmAddress` in Firebase |\n   158→| OBS not responding | Is OBS running on VM? `ssh_exec target={IP} command=\"systemctl status obs\"` |\n   159→| Graphics not showing | Is `output.html` deployed? Check `https://commentarygraphic.com/output.html?graphic=logos` |\n   160→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"8e9241da-ab7f-45dc-a01f-80a823309976","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/INFRASTRUCTURE.md","content":"# Infrastructure Reference\n\n**Last Updated:** 2026-01-22\n\nQuick reference for VMs, networking, and server architecture. For OBS-specific details, see [README-OBS-Architecture.md](README-OBS-Architecture.md).\n\n---\n\n## VM Inventory\n\n| VM | IP | Domain | Purpose |\n|----|-----|--------|---------|\n| **Coordinator** | 44.193.31.120 | api.commentarygraphic.com | Central hub, proxies all frontend connections |\n| **Frontend** | 3.87.107.201 | commentarygraphic.com | Static file hosting (React SPA) |\n| **Competition VMs** | Dynamic | None | Run OBS, one per competition |\n\n---\n\n## Connection Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  User's Browser (React App)                                 │\n│  - Downloaded from commentarygraphic.com                    │\n│  - ALL connections go to api.commentarygraphic.com          │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              │ HTTPS / WSS (port 443)\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│  COORDINATOR (api.commentarygraphic.com)                    │\n│  - nginx (SSL termination)                                  │\n│  - Node.js server (port 3001, PM2 managed)                  │\n│  - Routes requests to correct competition VM                │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              │ Internal (ws://, no SSL)\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│  COMPETITION VM (e.g., 50.19.137.152)                       │\n│  - OBS Studio (headless, port 4455 localhost only)          │\n│  - Show Server (Node.js, port 3003)                         │\n│  - SRT inputs (ports 9001-9010)                             │\n└─────────────────────────────────────────────────────────────┘\n```\n\n**Key point:** Frontend NEVER connects directly to competition VMs. The coordinator proxies everything.\n\n**Why:** Mixed content security. HTTPS pages can't connect to HTTP/WS endpoints. The coordinator has SSL; competition VMs don't.\n\n---\n\n## Network Ports\n\n| Port | VM | Service | Access |\n|------|-----|---------|--------|\n| 443 | Coordinator | nginx (HTTPS) | Public |\n| 3001 | Coordinator | Node.js server | Internal (via nginx) |\n| 3003 | Competition | Show Server | Public |\n| 4455 | Competition | OBS WebSocket | localhost only |\n| 9001-9010 | Competition | SRT camera inputs | Public |\n| 22 | All | SSH | Admin only |\n\n---\n\n## Firebase Paths\n\n```\ncompetitions/\n  {compId}/\n    config/\n      vmAddress: \"50.19.137.152:3003\"    # Assigned VM\n      eventName: \"UCLA vs Stanford\"\n      gender: \"womens\"\n    obs/\n      state/\n        connected: true\n        currentScene: \"Camera 1\"\n\nvmPool/\n  config/\n    warmCount: 2                          # Running VMs to keep ready\n    coldCount: 3                          # Stopped VMs available\n  vms/\n    {vmId}/\n      instanceId: \"i-xxx\"\n      status: \"assigned\" | \"available\" | \"stopped\"\n      assignedTo: \"8kyf0rnl\"              # Competition ID\n      publicIp: \"50.19.137.152\"\n\nteamsDatabase/\n  teams/{team-key}/                       # Team info and rosters\n  headshots/{athlete-name}/               # Athlete photos\n  aliases/{alias}/                        # Team name aliases\n```\n\n---\n\n## Routing Flow\n\n1. User navigates to `https://commentarygraphic.com/{compId}/producer`\n2. React app extracts `compId` from URL\n3. App connects Socket.io to `https://api.commentarygraphic.com` with `compId` in query\n4. Coordinator looks up VM for that competition in Firebase\n5. Coordinator connects to VM and proxies all traffic\n\n---\n\n## Key Services\n\n### Coordinator (44.193.31.120)\n```bash\n# Check status\nssh_exec target=\"coordinator\" command=\"pm2 list\"\n\n# View logs\nssh_exec target=\"coordinator\" command=\"pm2 logs coordinator --lines 50\"\n\n# Restart\nssh_exec target=\"coordinator\" command=\"pm2 restart coordinator\"\n\n# Deploy updates\nssh_exec target=\"coordinator\" command=\"cd /opt/gymnastics-graphics && sudo git pull --rebase origin main && pm2 restart coordinator\"\n```\n\n### Competition VM\n```bash\n# Check OBS status\nssh_exec target=\"{VM_IP}\" command=\"systemctl status obs\"\n\n# Check Show Server\nssh_exec target=\"{VM_IP}\" command=\"pm2 list\"\n\n# View OBS logs\nssh_exec target=\"{VM_IP}\" command=\"journalctl -u obs -n 50\"\n```\n\n---\n\n## Current AMI\n\n| Property | Value |\n|----------|-------|\n| AMI ID | `ami-070ce58462b2b9213` |\n| Name | gymnastics-vm-v2.2 |\n| Config location | `server/lib/awsService.js` line 34 |\n\nNew VMs launched by VM Pool Manager use this AMI automatically.\n\n---\n\n## Quick Debugging\n\n| Symptom | Check |\n|---------|-------|\n| Frontend can't connect | Is coordinator running? `curl https://api.commentarygraphic.com/api/coordinator/status` |\n| Competition not loading | Is VM assigned? Check `competitions/{compId}/config/vmAddress` in Firebase |\n| OBS not responding | Is OBS running on VM? `ssh_exec target={IP} command=\"systemctl status obs\"` |\n| Graphics not showing | Is `output.html` deployed? Check `https://commentarygraphic.com/output.html?graphic=logos` |\n","numLines":160,"startLine":1,"totalLines":160}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NFtkLxTo2qo5fsDTkcpnNz","type":"message","role":"assistant","content":[{"type":"text","text":"```\n1.4 Infrastructure Reference Read\n- Relevant infrastructure noted: Coordinator at api.commentarygraphic.com (44.193.31.120), Frontend at commentarygraphic.com (3.87.107.201), Competition VMs are dynamic, Socket.io connects through coordinator with compId in query, Firebase stores competition config including vmAddress\n```\n\n---\n\n## Phase 2: Select ONE Task\n\n### Step 2.1 - Identify First Task\n\nFrom the Implementation Plan, the first task that is NOT STARTED is:\n\n**Task 1: Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager`**\n\n### Step 2.2 - Selection Output\n\n```\n2.2 ONE Task Selected\n- Task ID: Task 1\n- Task name: Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager`\n- This is ONE task, not multiple: yes\n- Files to modify: server/lib/timesheetEngine.js\n```\n\n---\n\n## Phase 3: Implement ONE TASK ONLY\n\nLet me read the TimesheetEngine file to understand the current constructor:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2390,"cache_read_input_tokens":49497,"cache_creation":{"ephemeral_5m_input_tokens":2390,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"7c4c15ed-f098-4a9e-8f6c-a7fa92195483"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NFtkLxTo2qo5fsDTkcpnNz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YY2WKoETere1etHauT7dgj","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/lib/timesheetEngine.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2390,"cache_read_input_tokens":49497,"cache_creation":{"ephemeral_5m_input_tokens":2390,"ephemeral_1h_input_tokens":0},"output_tokens":338,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"10bcff86-072c-4953-82d2-4bd48cc69491"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YY2WKoETere1etHauT7dgj","type":"tool_result","content":"     1→/**\n     2→ * Timesheet Engine Module\n     3→ *\n     4→ * Drives show flow based on segment timing, handling auto-advance,\n     5→ * manual overrides, and producer controls.\n     6→ * Emits events for real-time UI updates and segment transitions.\n     7→ */\n     8→\n     9→import { EventEmitter } from 'events';\n    10→\n    11→// Segment types\n    12→const SEGMENT_TYPES = {\n    13→  STATIC: 'static',     // Static graphics/video\n    14→  LIVE: 'live',         // Live camera feed\n    15→  MULTI: 'multi',       // Multi-camera view\n    16→  HOLD: 'hold',         // Hold for producer decision\n    17→  BREAK: 'break',       // Commercial/intermission break\n    18→  VIDEO: 'video',       // Pre-recorded video\n    19→  GRAPHIC: 'graphic'    // Graphics overlay\n    20→};\n    21→\n    22→// Engine states\n    23→const ENGINE_STATE = {\n    24→  STOPPED: 'stopped',\n    25→  RUNNING: 'running',\n    26→  PAUSED: 'paused'\n    27→};\n    28→\n    29→// Transition types\n    30→const TRANSITION_TYPES = {\n    31→  CUT: 'cut',\n    32→  FADE: 'fade',\n    33→  STINGER: 'stinger'\n    34→};\n    35→\n    36→/**\n    37→ * TimesheetEngine - Drives show flow based on segment timing\n    38→ *\n    39→ * Events emitted:\n    40→ * - 'tick': Emitted every second with elapsed/remaining time\n    41→ * - 'segmentActivated': Emitted when a segment becomes active\n    42→ * - 'segmentCompleted': Emitted when a segment finishes\n    43→ * - 'showStarted': Emitted when show begins\n    44→ * - 'showStopped': Emitted when show ends\n    45→ * - 'holdMaxReached': Emitted when hold segment exceeds maxDuration\n    46→ * - 'overrideRecorded': Emitted when a manual override is logged\n    47→ * - 'stateChanged': Emitted when engine state changes\n    48→ */\n    49→class TimesheetEngine extends EventEmitter {\n    50→  /**\n    51→   * Create a new TimesheetEngine\n    52→   * @param {Object} options - Configuration options\n    53→   * @param {string} options.compId - Competition ID for multi-competition support\n    54→   * @param {Object} options.obsConnectionManager - OBS connection manager for per-competition OBS connections\n    55→   * @param {Object} options.showConfig - Show configuration with segments\n    56→   * @param {Object} options.obs - OBS WebSocket controller (optional, legacy - prefer obsConnectionManager)\n    57→   * @param {Object} options.firebase - Firebase controller for graphics (optional)\n    58→   * @param {Object} options.io - Socket.io server for broadcasting (optional)\n    59→   */\n    60→  constructor(options = {}) {\n    61→    super();\n    62→\n    63→    // Multi-competition support\n    64→    this.compId = options.compId || null;\n    65→    this.obsConnectionManager = options.obsConnectionManager || null;\n    66→\n    67→    this.showConfig = options.showConfig || { segments: [] };\n    68→    this.obs = options.obs || null;\n    69→    this.firebase = options.firebase || null;\n    70→    this.io = options.io || null;\n    71→\n    72→    // Core state\n    73→    this._state = ENGINE_STATE.STOPPED;\n    74→    this._isRunning = false;\n    75→    this._currentSegmentIndex = -1;\n    76→    this._currentSegment = null;\n    77→    this._segmentStartTime = null;\n    78→    this._segmentElapsedMs = 0;\n    79→\n    80→    // Tick timer\n    81→    this._tickTimer = null;\n    82→    this._tickIntervalMs = 1000; // 1 second tick\n    83→\n    84→    // History tracking\n    85→    this._history = [];\n    86→    this._overrides = [];\n    87→\n    88→    // Show timing\n    89→    this._showStartTime = null;\n    90→    this._showElapsedMs = 0;\n    91→\n    92→    // Track last transition for context\n    93→    this._lastTransitionType = null;\n    94→\n    95→    // Track if holdMaxReached has been emitted for current segment\n    96→    this._holdMaxReachedEmitted = false;\n    97→  }\n    98→\n    99→  /**\n   100→   * Get segments from show config\n   101→   * @returns {Object[]} Array of segments\n   102→   */\n   103→  get segments() {\n   104→    return this.showConfig.segments || [];\n   105→  }\n   106→\n   107→  /**\n   108→   * Get current engine state\n   109→   * @returns {string} Current state (stopped, running, paused)\n   110→   */\n   111→  get state() {\n   112→    return this._state;\n   113→  }\n   114→\n   115→  /**\n   116→   * Check if engine is running\n   117→   * @returns {boolean} True if running\n   118→   */\n   119→  get isRunning() {\n   120→    return this._isRunning;\n   121→  }\n   122→\n   123→  /**\n   124→   * Get current segment index\n   125→   * @returns {number} Current segment index (-1 if not started)\n   126→   */\n   127→  get currentSegmentIndex() {\n   128→    return this._currentSegmentIndex;\n   129→  }\n   130→\n   131→  /**\n   132→   * Get current segment object\n   133→   * @returns {Object|null} Current segment or null\n   134→   */\n   135→  get currentSegment() {\n   136→    return this._currentSegment;\n   137→  }\n   138→\n   139→  /**\n   140→   * Get next segment (if any)\n   141→   * @returns {Object|null} Next segment or null\n   142→   */\n   143→  get nextSegment() {\n   144→    const nextIndex = this._currentSegmentIndex + 1;\n   145→    return nextIndex < this.segments.length ? this.segments[nextIndex] : null;\n   146→  }\n   147→\n   148→  /**\n   149→   * Get previous segment (if any)\n   150→   * @returns {Object|null} Previous segment or null\n   151→   */\n   152→  get previousSegment() {\n   153→    const prevIndex = this._currentSegmentIndex - 1;\n   154→    return prevIndex >= 0 ? this.segments[prevIndex] : null;\n   155→  }\n   156→\n   157→  /**\n   158→   * Get elapsed time for current segment in milliseconds\n   159→   * @returns {number} Elapsed milliseconds\n   160→   */\n   161→  get segmentElapsedMs() {\n   162→    if (!this._segmentStartTime) return 0;\n   163→    return Date.now() - this._segmentStartTime;\n   164→  }\n   165→\n   166→  /**\n   167→   * Get remaining time for current segment in milliseconds\n   168→   * @returns {number|null} Remaining milliseconds or null if untimed\n   169→   */\n   170→  get segmentRemainingMs() {\n   171→    if (!this._currentSegment || !this._currentSegment.duration) {\n   172→      return null; // Untimed segment\n   173→    }\n   174→    const durationMs = this._currentSegment.duration * 1000;\n   175→    const remaining = durationMs - this.segmentElapsedMs;\n   176→    return Math.max(0, remaining);\n   177→  }\n   178→\n   179→  /**\n   180→   * Get segment progress (0-1)\n   181→   * @returns {number|null} Progress fraction or null if untimed\n   182→   */\n   183→  get segmentProgress() {\n   184→    if (!this._currentSegment || !this._currentSegment.duration) {\n   185→      return null;\n   186→    }\n   187→    const durationMs = this._currentSegment.duration * 1000;\n   188→    return Math.min(1, this.segmentElapsedMs / durationMs);\n   189→  }\n   190→\n   191→  /**\n   192→   * Get show elapsed time in milliseconds\n   193→   * @returns {number} Show elapsed milliseconds\n   194→   */\n   195→  get showElapsedMs() {\n   196→    if (!this._showStartTime) return 0;\n   197→    return Date.now() - this._showStartTime;\n   198→  }\n   199→\n   200→  /**\n   201→   * Get segment history\n   202→   * @returns {Object[]} Array of history entries\n   203→   */\n   204→  get history() {\n   205→    return [...this._history];\n   206→  }\n   207→\n   208→  /**\n   209→   * Get override log\n   210→   * @returns {Object[]} Array of override entries\n   211→   */\n   212→  get overrides() {\n   213→    return [...this._overrides];\n   214→  }\n   215→\n   216→  /**\n   217→   * Start the show from the first segment\n   218→   */\n   219→  async start() {\n   220→    if (this._isRunning) {\n   221→      return;\n   222→    }\n   223→\n   224→    if (this.segments.length === 0) {\n   225→      this.emit('error', new Error('No segments defined in show config'));\n   226→      return;\n   227→    }\n   228→\n   229→    this._isRunning = true;\n   230→    this._state = ENGINE_STATE.RUNNING;\n   231→    this._showStartTime = Date.now();\n   232→    this._history = [];\n   233→    this._overrides = [];\n   234→\n   235→    // Start tick timer\n   236→    this._startTick();\n   237→\n   238→    // Activate first segment\n   239→    await this._activateSegment(0, 'start');\n   240→\n   241→    this.emit('showStarted', {\n   242→      timestamp: Date.now(),\n   243→      segmentCount: this.segments.length\n   244→    });\n   245→\n   246→    this.emit('stateChanged', {\n   247→      previousState: ENGINE_STATE.STOPPED,\n   248→      newState: ENGINE_STATE.RUNNING\n   249→    });\n   250→  }\n   251→\n   252→  /**\n   253→   * Stop the show\n   254→   */\n   255→  stop() {\n   256→    if (!this._isRunning) {\n   257→      return;\n   258→    }\n   259→\n   260→    // Record final segment in history\n   261→    if (this._currentSegment) {\n   262→      this._recordHistory('completed');\n   263→    }\n   264→\n   265→    this._isRunning = false;\n   266→    this._state = ENGINE_STATE.STOPPED;\n   267→    this._stopTick();\n   268→\n   269→    const showDurationMs = Date.now() - this._showStartTime;\n   270→\n   271→    this.emit('showStopped', {\n   272→      timestamp: Date.now(),\n   273→      showDurationMs,\n   274→      segmentsCompleted: this._history.length,\n   275→      overrideCount: this._overrides.length\n   276→    });\n   277→\n   278→    this.emit('stateChanged', {\n   279→      previousState: ENGINE_STATE.RUNNING,\n   280→      newState: ENGINE_STATE.STOPPED\n   281→    });\n   282→\n   283→    // Reset state\n   284→    this._currentSegmentIndex = -1;\n   285→    this._currentSegment = null;\n   286→    this._segmentStartTime = null;\n   287→    this._showStartTime = null;\n   288→  }\n   289→\n   290→  /**\n   291→   * Pause the show (stops tick but preserves state)\n   292→   */\n   293→  pause() {\n   294→    if (!this._isRunning || this._state === ENGINE_STATE.PAUSED) {\n   295→      return;\n   296→    }\n   297→\n   298→    this._state = ENGINE_STATE.PAUSED;\n   299→    this._segmentElapsedMs = this.segmentElapsedMs; // Capture current elapsed\n   300→    this._stopTick();\n   301→\n   302→    this.emit('stateChanged', {\n   303→      previousState: ENGINE_STATE.RUNNING,\n   304→      newState: ENGINE_STATE.PAUSED\n   305→    });\n   306→  }\n   307→\n   308→  /**\n   309→   * Resume the show from paused state\n   310→   */\n   311→  resume() {\n   312→    if (this._state !== ENGINE_STATE.PAUSED) {\n   313→      return;\n   314→    }\n   315→\n   316→    this._state = ENGINE_STATE.RUNNING;\n   317→    // Adjust start time to account for pause\n   318→    this._segmentStartTime = Date.now() - this._segmentElapsedMs;\n   319→    this._startTick();\n   320→\n   321→    this.emit('stateChanged', {\n   322→      previousState: ENGINE_STATE.PAUSED,\n   323→      newState: ENGINE_STATE.RUNNING\n   324→    });\n   325→  }\n   326→\n   327→  /**\n   328→   * Start the tick timer\n   329→   * @private\n   330→   */\n   331→  _startTick() {\n   332→    if (this._tickTimer) {\n   333→      return;\n   334→    }\n   335→\n   336→    this._tickTimer = setInterval(() => {\n   337→      this._tick();\n   338→    }, this._tickIntervalMs);\n   339→  }\n   340→\n   341→  /**\n   342→   * Stop the tick timer\n   343→   * @private\n   344→   */\n   345→  _stopTick() {\n   346→    if (this._tickTimer) {\n   347→      clearInterval(this._tickTimer);\n   348→      this._tickTimer = null;\n   349→    }\n   350→  }\n   351→\n   352→  /**\n   353→   * Tick handler - called every second\n   354→   * @private\n   355→   */\n   356→  _tick() {\n   357→    if (!this._isRunning || this._state !== ENGINE_STATE.RUNNING) {\n   358→      return;\n   359→    }\n   360→\n   361→    const elapsedMs = this.segmentElapsedMs;\n   362→    const remainingMs = this.segmentRemainingMs;\n   363→    const progress = this.segmentProgress;\n   364→\n   365→    // Emit tick event\n   366→    this.emit('tick', {\n   367→      timestamp: Date.now(),\n   368→      segmentId: this._currentSegment?.id,\n   369→      segmentIndex: this._currentSegmentIndex,\n   370→      elapsedMs,\n   371→      remainingMs,\n   372→      progress,\n   373→      showElapsedMs: this.showElapsedMs\n   374→    });\n   375→\n   376→    // Check for hold segment max duration warning\n   377→    if (this._currentSegment?.type === SEGMENT_TYPES.HOLD) {\n   378→      const maxDurationMs = (this._currentSegment.maxDuration || 0) * 1000;\n   379→      if (maxDurationMs > 0 && elapsedMs >= maxDurationMs && !this._holdMaxReachedEmitted) {\n   380→        this._holdMaxReachedEmitted = true;\n   381→        this.emit('holdMaxReached', {\n   382→          segmentId: this._currentSegment.id,\n   383→          elapsedMs,\n   384→          maxDurationMs\n   385→        });\n   386→      }\n   387→    }\n   388→\n   389→    // Check for auto-advance\n   390→    this._checkAutoAdvance(elapsedMs);\n   391→  }\n   392→\n   393→  /**\n   394→   * Check if segment should auto-advance and trigger if appropriate\n   395→   * @param {number} elapsedMs - Current elapsed time in milliseconds\n   396→   * @private\n   397→   */\n   398→  _checkAutoAdvance(elapsedMs) {\n   399→    // No current segment or no more segments\n   400→    if (!this._currentSegment) return;\n   401→    const nextIndex = this._currentSegmentIndex + 1;\n   402→    if (nextIndex >= this.segments.length) return;\n   403→\n   404→    // Hold segments NEVER auto-advance - producer must decide\n   405→    if (this._currentSegment.type === SEGMENT_TYPES.HOLD) {\n   406→      return;\n   407→    }\n   408→\n   409→    // Check autoAdvance flag on segment (default true for timed segments)\n   410→    const autoAdvance = this._currentSegment.autoAdvance !== false;\n   411→    if (!autoAdvance) {\n   412→      return;\n   413→    }\n   414→\n   415→    // Must have a duration to auto-advance\n   416→    const durationMs = (this._currentSegment.duration || 0) * 1000;\n   417→    if (durationMs <= 0) {\n   418→      return;\n   419→    }\n   420→\n   421→    // Check if elapsed time has reached or exceeded duration\n   422→    if (elapsedMs >= durationMs) {\n   423→      this._autoAdvance();\n   424→    }\n   425→  }\n   426→\n   427→  /**\n   428→   * Auto-advance to the next segment\n   429→   * @private\n   430→   */\n   431→  async _autoAdvance() {\n   432→    const nextIndex = this._currentSegmentIndex + 1;\n   433→\n   434→    // Emit event before advancing\n   435→    this.emit('autoAdvancing', {\n   436→      fromSegmentId: this._currentSegment?.id,\n   437→      fromSegmentIndex: this._currentSegmentIndex,\n   438→      toSegmentIndex: nextIndex,\n   439→      timestamp: Date.now()\n   440→    });\n   441→\n   442→    // Activate next segment\n   443→    await this._activateSegment(nextIndex, 'auto');\n   444→  }\n   445→\n   446→  /**\n   447→   * Check if hold segment has met minimum duration requirement\n   448→   * @returns {boolean} True if hold can be advanced\n   449→   */\n   450→  canAdvanceHold() {\n   451→    if (!this._currentSegment || this._currentSegment.type !== SEGMENT_TYPES.HOLD) {\n   452→      return true; // Not a hold segment, can always advance\n   453→    }\n   454→\n   455→    const minDurationMs = (this._currentSegment.minDuration || 0) * 1000;\n   456→    const elapsedMs = this.segmentElapsedMs;\n   457→\n   458→    return elapsedMs >= minDurationMs;\n   459→  }\n   460→\n   461→  /**\n   462→   * Get remaining time before hold can be advanced\n   463→   * @returns {number} Milliseconds remaining before minDuration is met (0 if already met)\n   464→   */\n   465→  getHoldRemainingMs() {\n   466→    if (!this._currentSegment || this._currentSegment.type !== SEGMENT_TYPES.HOLD) {\n   467→      return 0;\n   468→    }\n   469→\n   470→    const minDurationMs = (this._currentSegment.minDuration || 0) * 1000;\n   471→    const elapsedMs = this.segmentElapsedMs;\n   472→\n   473→    return Math.max(0, minDurationMs - elapsedMs);\n   474→  }\n   475→\n   476→  /**\n   477→   * Activate a segment by index\n   478→   * @param {number} index - Segment index to activate\n   479→   * @param {string} reason - Why this segment was activated (auto, manual, jump)\n   480→   * @private\n   481→   */\n   482→  async _activateSegment(index, reason = 'manual') {\n   483→    if (index < 0 || index >= this.segments.length) {\n   484→      return false;\n   485→    }\n   486→\n   487→    // Record previous segment in history\n   488→    if (this._currentSegment) {\n   489→      this._recordHistory(reason === 'auto' ? 'auto_advanced' : 'advanced');\n   490→    }\n   491→\n   492→    const previousSegment = this._currentSegment;\n   493→    const segment = this.segments[index];\n   494→\n   495→    this._currentSegmentIndex = index;\n   496→    this._currentSegment = segment;\n   497→    this._segmentStartTime = Date.now();\n   498→    this._segmentElapsedMs = 0;\n   499→    this._holdMaxReachedEmitted = false;\n   500→\n   501→    // Determine transition type based on segment types\n   502→    const transition = this._getTransition(previousSegment, segment);\n   503→    this._lastTransitionType = transition.type;\n   504→\n   505→    // Apply transition and switch scene\n   506→    await this._applyTransitionAndSwitchScene(segment, transition);\n   507→\n   508→    // Handle segment-type specific actions\n   509→    await this._handleSegmentTypeActions(segment);\n   510→\n   511→    // Apply audio overrides if defined\n   512→    await this._applyAudioOverrides(segment);\n   513→\n   514→    this.emit('segmentActivated', {\n   515→      timestamp: Date.now(),\n   516→      segmentIndex: index,\n   517→      segment: { ...segment },\n   518→      previousSegmentIndex: this._history.length > 0\n   519→        ? this._history[this._history.length - 1].segmentIndex\n   520→        : -1,\n   521→      transition: transition,\n   522→      reason\n   523→    });\n   524→\n   525→    return true;\n   526→  }\n   527→\n   528→  /**\n   529→   * Get the appropriate transition for segment change\n   530→   * @param {Object|null} fromSegment - Previous segment\n   531→   * @param {Object} toSegment - Next segment\n   532→   * @returns {Object} Transition config {type, durationMs}\n   533→   * @private\n   534→   */\n   535→  _getTransition(fromSegment, toSegment) {\n   536→    const transitions = this.showConfig.transitions || {};\n   537→\n   538→    // Check for segment-specific transition\n   539→    if (toSegment.transition) {\n   540→      return {\n   541→        type: toSegment.transition.type || TRANSITION_TYPES.CUT,\n   542→        durationMs: toSegment.transition.durationMs || 0\n   543→      };\n   544→    }\n   545→\n   546→    // Going to break\n   547→    if (toSegment.type === SEGMENT_TYPES.BREAK && transitions.toBreak) {\n   548→      return transitions.toBreak;\n   549→    }\n   550→\n   551→    // Coming from break\n   552→    if (fromSegment?.type === SEGMENT_TYPES.BREAK && transitions.fromBreak) {\n   553→      return transitions.fromBreak;\n   554→    }\n   555→\n   556→    // Default transition\n   557→    return transitions.default || { type: TRANSITION_TYPES.CUT, durationMs: 0 };\n   558→  }\n   559→\n   560→  /**\n   561→   * Apply transition and switch OBS scene\n   562→   * @param {Object} segment - Segment to switch to\n   563→   * @param {Object} transition - Transition config\n   564→   * @private\n   565→   */\n   566→  async _applyTransitionAndSwitchScene(segment, transition) {\n   567→    if (!this.obs || !segment.obsScene) {\n   568→      return;\n   569→    }\n   570→\n   571→    try {\n   572→      if (transition.type === TRANSITION_TYPES.FADE && transition.durationMs > 0) {\n   573→        // Use SetCurrentSceneTransitionDuration and then switch\n   574→        await this.obs.call('SetCurrentSceneTransitionDuration', {\n   575→          transitionDuration: transition.durationMs\n   576→        });\n   577→        await this.obs.call('SetCurrentSceneTransition', {\n   578→          transitionName: 'Fade'\n   579→        });\n   580→      } else if (transition.type === TRANSITION_TYPES.STINGER) {\n   581→        // Use stinger transition if configured\n   582→        await this.obs.call('SetCurrentSceneTransition', {\n   583→          transitionName: transition.transitionName || 'Stinger'\n   584→        });\n   585→      } else {\n   586→        // Cut transition (instant)\n   587→        await this.obs.call('SetCurrentSceneTransition', {\n   588→          transitionName: 'Cut'\n   589→        });\n   590→      }\n   591→\n   592→      // Switch to the scene\n   593→      await this.obs.call('SetCurrentProgramScene', {\n   594→        sceneName: segment.obsScene\n   595→      });\n   596→\n   597→      this.emit('sceneChanged', {\n   598→        sceneName: segment.obsScene,\n   599→        transition: transition,\n   600→        segmentId: segment.id\n   601→      });\n   602→    } catch (error) {\n   603→      this.emit('error', {\n   604→        type: 'obs_scene_switch',\n   605→        message: `Failed to switch to scene ${segment.obsScene}: ${error.message}`,\n   606→        segmentId: segment.id\n   607→      });\n   608→    }\n   609→  }\n   610→\n   611→  /**\n   612→   * Handle segment-type specific actions\n   613→   * @param {Object} segment - Current segment\n   614→   * @private\n   615→   */\n   616→  async _handleSegmentTypeActions(segment) {\n   617→    switch (segment.type) {\n   618→      case SEGMENT_TYPES.STATIC:\n   619→        // Static scene, nothing special to do\n   620→        break;\n   621→\n   622→      case SEGMENT_TYPES.LIVE:\n   623→      case SEGMENT_TYPES.MULTI:\n   624→        // Live camera feed - trigger any associated graphics\n   625→        if (segment.graphic) {\n   626→          await this._triggerGraphic(segment);\n   627→        }\n   628→        break;\n   629→\n   630→      case SEGMENT_TYPES.HOLD:\n   631→        // Hold segment - emit hold started event\n   632→        this.emit('holdStarted', {\n   633→          segmentId: segment.id,\n   634→          minDuration: segment.minDuration || 0,\n   635→          maxDuration: segment.maxDuration || null\n   636→        });\n   637→        break;\n   638→\n   639→      case SEGMENT_TYPES.BREAK:\n   640→        // Break segment - could trigger break graphics\n   641→        if (segment.graphic) {\n   642→          await this._triggerGraphic(segment);\n   643→        }\n   644→        this.emit('breakStarted', {\n   645→          segmentId: segment.id,\n   646→          duration: segment.duration || null\n   647→        });\n   648→        break;\n   649→\n   650→      case SEGMENT_TYPES.VIDEO:\n   651→        // Video segment - set video file and play\n   652→        if (segment.videoFile && this.obs) {\n   653→          await this._playVideo(segment);\n   654→        }\n   655→        break;\n   656→\n   657→      case SEGMENT_TYPES.GRAPHIC:\n   658→        // Graphics segment - trigger the graphic\n   659→        await this._triggerGraphic(segment);\n   660→        break;\n   661→\n   662→      default:\n   663→        // Unknown segment type, try to trigger graphic if present\n   664→        if (segment.graphic) {\n   665→          await this._triggerGraphic(segment);\n   666→        }\n   667→    }\n   668→  }\n   669→\n   670→  /**\n   671→   * Trigger a graphic via Firebase or socket.io\n   672→   * @param {Object} segment - Segment with graphic configuration\n   673→   * @private\n   674→   */\n   675→  async _triggerGraphic(segment) {\n   676→    if (!segment.graphic) return;\n   677→\n   678→    const graphicData = {\n   679→      graphic: segment.graphic,\n   680→      data: segment.graphicData || {},\n   681→      segmentId: segment.id,\n   682→      timestamp: Date.now()\n   683→    };\n   684→\n   685→    // Try Firebase first if available\n   686→    if (this.firebase) {\n   687→      try {\n   688→        await this.firebase.database().ref('graphics/current').set(graphicData);\n   689→      } catch (error) {\n   690→        this.emit('error', {\n   691→          type: 'firebase_graphic',\n   692→          message: `Failed to trigger graphic via Firebase: ${error.message}`,\n   693→          segmentId: segment.id\n   694→        });\n   695→      }\n   696→    }\n   697→\n   698→    // Also broadcast via socket.io\n   699→    if (this.io) {\n   700→      this.io.emit('triggerGraphic', graphicData);\n   701→    }\n   702→\n   703→    // Emit event for any listeners\n   704→    this.emit('graphicTriggered', graphicData);\n   705→  }\n   706→\n   707→  /**\n   708→   * Play a video segment via OBS media source\n   709→   * @param {Object} segment - Segment with video configuration\n   710→   * @private\n   711→   */\n   712→  async _playVideo(segment) {\n   713→    if (!this.obs || !segment.videoFile) return;\n   714→\n   715→    const sourceName = segment.videoSource || 'Video Player';\n   716→\n   717→    try {\n   718→      // Get current settings\n   719→      const { inputSettings } = await this.obs.call('GetInputSettings', {\n   720→        inputName: sourceName\n   721→      });\n   722→\n   723→      // Update with new file path\n   724→      await this.obs.call('SetInputSettings', {\n   725→        inputName: sourceName,\n   726→        inputSettings: {\n   727→          ...inputSettings,\n   728→          local_file: segment.videoFile,\n   729→          is_local_file: true\n   730→        }\n   731→      });\n   732→\n   733→      // Restart the media source to play from beginning\n   734→      await this.obs.call('TriggerMediaInputAction', {\n   735→        inputName: sourceName,\n   736→        mediaAction: 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n   737→      });\n   738→\n   739→      this.emit('videoStarted', {\n   740→        segmentId: segment.id,\n   741→        videoFile: segment.videoFile,\n   742→        sourceName\n   743→      });\n   744→    } catch (error) {\n   745→      this.emit('error', {\n   746→        type: 'obs_video',\n   747→        message: `Failed to play video ${segment.videoFile}: ${error.message}`,\n   748→        segmentId: segment.id\n   749→      });\n   750→    }\n   751→  }\n   752→\n   753→  /**\n   754→   * Apply audio overrides for a segment\n   755→   * @param {Object} segment - Current segment\n   756→   * @private\n   757→   */\n   758→  async _applyAudioOverrides(segment) {\n   759→    if (!this.obs || !segment.audio) return;\n   760→\n   761→    const audioConfig = this.showConfig.audioConfig || {};\n   762→\n   763→    try {\n   764→      // Apply venue audio volume\n   765→      if (segment.audio.venueVolume !== undefined && audioConfig.venue?.sourceName) {\n   766→        await this.obs.call('SetInputVolume', {\n   767→          inputName: audioConfig.venue.sourceName,\n   768→          inputVolumeDb: this._volumeToDb(segment.audio.venueVolume)\n   769→        });\n   770→      }\n   771→\n   772→      // Apply commentary audio volume\n   773→      if (segment.audio.commentaryVolume !== undefined && audioConfig.commentary?.sourceName) {\n   774→        await this.obs.call('SetInputVolume', {\n   775→          inputName: audioConfig.commentary.sourceName,\n   776→          inputVolumeDb: this._volumeToDb(segment.audio.commentaryVolume)\n   777→        });\n   778→      }\n   779→\n   780→      // Apply mute states\n   781→      if (segment.audio.muteVenue !== undefined && audioConfig.venue?.sourceName) {\n   782→        await this.obs.call('SetInputMute', {\n   783→          inputName: audioConfig.venue.sourceName,\n   784→          inputMuted: segment.audio.muteVenue\n   785→        });\n   786→      }\n   787→\n   788→      if (segment.audio.muteCommentary !== undefined && audioConfig.commentary?.sourceName) {\n   789→        await this.obs.call('SetInputMute', {\n   790→          inputName: audioConfig.commentary.sourceName,\n   791→          inputMuted: segment.audio.muteCommentary\n   792→        });\n   793→      }\n   794→\n   795→      this.emit('audioChanged', {\n   796→        segmentId: segment.id,\n   797→        audio: segment.audio\n   798→      });\n   799→    } catch (error) {\n   800→      this.emit('error', {\n   801→        type: 'obs_audio',\n   802→        message: `Failed to apply audio overrides: ${error.message}`,\n   803→        segmentId: segment.id\n   804→      });\n   805→    }\n   806→  }\n   807→\n   808→  /**\n   809→   * Convert volume (0-1) to decibels\n   810→   * @param {number} volume - Volume from 0 to 1\n   811→   * @returns {number} Volume in decibels\n   812→   * @private\n   813→   */\n   814→  _volumeToDb(volume) {\n   815→    if (volume <= 0) return -100; // Essentially silent\n   816→    if (volume >= 1) return 0;    // Full volume\n   817→    // Convert linear to dB: 20 * log10(volume)\n   818→    return 20 * Math.log10(volume);\n   819→  }\n   820→\n   821→  /**\n   822→   * Record segment in history\n   823→   * @param {string} endReason - Why segment ended\n   824→   * @private\n   825→   */\n   826→  _recordHistory(endReason) {\n   827→    if (!this._currentSegment) return;\n   828→\n   829→    this._history.push({\n   830→      segmentId: this._currentSegment.id,\n   831→      segmentIndex: this._currentSegmentIndex,\n   832→      segmentName: this._currentSegment.name,\n   833→      startTime: this._segmentStartTime,\n   834→      endTime: Date.now(),\n   835→      durationMs: this.segmentElapsedMs,\n   836→      plannedDurationMs: this._currentSegment.duration\n   837→        ? this._currentSegment.duration * 1000\n   838→        : null,\n   839→      endReason\n   840→    });\n   841→\n   842→    this.emit('segmentCompleted', {\n   843→      segmentId: this._currentSegment.id,\n   844→      segmentIndex: this._currentSegmentIndex,\n   845→      durationMs: this.segmentElapsedMs,\n   846→      endReason\n   847→    });\n   848→  }\n   849→\n   850→  /**\n   851→   * Record an override action\n   852→   * @param {string} type - Override type\n   853→   * @param {Object} details - Override details\n   854→   * @private\n   855→   */\n   856→  _recordOverride(type, details) {\n   857→    const override = {\n   858→      timestamp: Date.now(),\n   859→      type,\n   860→      segmentId: this._currentSegment?.id,\n   861→      segmentIndex: this._currentSegmentIndex,\n   862→      showElapsedMs: this.showElapsedMs,\n   863→      ...details\n   864→    };\n   865→\n   866→    this._overrides.push(override);\n   867→\n   868→    this.emit('overrideRecorded', override);\n   869→  }\n   870→\n   871→  /**\n   872→   * Get full timesheet state for clients\n   873→   * @returns {Object} Current timesheet state\n   874→   */\n   875→  getState() {\n   876→    const isHold = this._currentSegment?.type === SEGMENT_TYPES.HOLD;\n   877→\n   878→    return {\n   879→      state: this._state,\n   880→      isRunning: this._isRunning,\n   881→      currentSegmentIndex: this._currentSegmentIndex,\n   882→      currentSegment: this._currentSegment ? { ...this._currentSegment } : null,\n   883→      nextSegment: this.nextSegment ? { ...this.nextSegment } : null,\n   884→      previousSegment: this.previousSegment ? { ...this.previousSegment } : null,\n   885→      segmentElapsedMs: this.segmentElapsedMs,\n   886→      segmentRemainingMs: this.segmentRemainingMs,\n   887→      segmentProgress: this.segmentProgress,\n   888→      showElapsedMs: this.showElapsedMs,\n   889→      showStartTime: this._showStartTime,\n   890→      segmentCount: this.segments.length,\n   891→      historyCount: this._history.length,\n   892→      overrideCount: this._overrides.length,\n   893→      // Hold segment state\n   894→      isHoldSegment: isHold,\n   895→      canAdvanceHold: this.canAdvanceHold(),\n   896→      holdRemainingMs: isHold ? this.getHoldRemainingMs() : 0\n   897→    };\n   898→  }\n   899→\n   900→  /**\n   901→   * Get override history\n   902→   * @returns {Object[]} Array of override entries\n   903→   */\n   904→  getOverrides() {\n   905→    return [...this._overrides];\n   906→  }\n   907→\n   908→  /**\n   909→   * Get segment history\n   910→   * @returns {Object[]} Array of history entries\n   911→   */\n   912→  getHistory() {\n   913→    return [...this._history];\n   914→  }\n   915→\n   916→  /**\n   917→   * Update show config (e.g., after hot reload)\n   918→   * @param {Object} showConfig - New show configuration\n   919→   */\n   920→  updateConfig(showConfig) {\n   921→    const wasRunning = this._isRunning;\n   922→    const currentSegmentId = this._currentSegment?.id;\n   923→\n   924→    this.showConfig = showConfig;\n   925→\n   926→    // If running, try to maintain position by segment ID\n   927→    if (wasRunning && currentSegmentId) {\n   928→      const newIndex = this.segments.findIndex(s => s.id === currentSegmentId);\n   929→      if (newIndex >= 0) {\n   930→        this._currentSegmentIndex = newIndex;\n   931→        this._currentSegment = this.segments[newIndex];\n   932→      }\n   933→    }\n   934→  }\n   935→\n   936→  /**\n   937→   * Find segment index by ID\n   938→   * @param {string} segmentId - Segment ID to find\n   939→   * @returns {number} Segment index or -1 if not found\n   940→   */\n   941→  findSegmentIndex(segmentId) {\n   942→    return this.segments.findIndex(s => s.id === segmentId);\n   943→  }\n   944→\n   945→  /**\n   946→   * Get segment by ID\n   947→   * @param {string} segmentId - Segment ID to find\n   948→   * @returns {Object|null} Segment or null if not found\n   949→   */\n   950→  getSegment(segmentId) {\n   951→    return this.segments.find(s => s.id === segmentId) || null;\n   952→  }\n   953→\n   954→  // ============================================================\n   955→  // MANUAL CONTROLS AND OVERRIDES\n   956→  // ============================================================\n   957→\n   958→  /**\n   959→   * Advance to the next segment (manual)\n   960→   * @param {string} [advancedBy] - Who triggered the advance (for logging)\n   961→   * @returns {boolean} True if advanced successfully\n   962→   */\n   963→  async advance(advancedBy) {\n   964→    if (!this._isRunning) {\n   965→      return false;\n   966→    }\n   967→\n   968→    const nextIndex = this._currentSegmentIndex + 1;\n   969→    if (nextIndex >= this.segments.length) {\n   970→      this.emit('error', {\n   971→        type: 'advance_failed',\n   972→        message: 'Cannot advance: already at last segment'\n   973→      });\n   974→      return false;\n   975→    }\n   976→\n   977→    // For hold segments, check minDuration\n   978→    if (this._currentSegment?.type === SEGMENT_TYPES.HOLD && !this.canAdvanceHold()) {\n   979→      this.emit('error', {\n   980→        type: 'advance_blocked',\n   981→        message: `Cannot advance: hold segment requires ${this.getHoldRemainingMs()}ms more`,\n   982→        holdRemainingMs: this.getHoldRemainingMs()\n   983→      });\n   984→      return false;\n   985→    }\n   986→\n   987→    // Record the override\n   988→    this._recordOverride('advance', {\n   989→      advancedBy,\n   990→      fromSegmentId: this._currentSegment?.id,\n   991→      fromSegmentIndex: this._currentSegmentIndex,\n   992→      toSegmentIndex: nextIndex,\n   993→      toSegmentId: this.segments[nextIndex]?.id\n   994→    });\n   995→\n   996→    // Activate next segment\n   997→    await this._activateSegment(nextIndex, 'manual');\n   998→    return true;\n   999→  }\n  1000→\n  1001→  /**\n  1002→   * Go to the previous segment (manual)\n  1003→   * @param {string} [triggeredBy] - Who triggered the previous (for logging)\n  1004→   * @returns {boolean} True if went back successfully\n  1005→   */\n  1006→  async previous(triggeredBy) {\n  1007→    if (!this._isRunning) {\n  1008→      return false;\n  1009→    }\n  1010→\n  1011→    const prevIndex = this._currentSegmentIndex - 1;\n  1012→    if (prevIndex < 0) {\n  1013→      this.emit('error', {\n  1014→        type: 'previous_failed',\n  1015→        message: 'Cannot go previous: already at first segment'\n  1016→      });\n  1017→      return false;\n  1018→    }\n  1019→\n  1020→    // Record the override\n  1021→    this._recordOverride('previous', {\n  1022→      triggeredBy,\n  1023→      fromSegmentId: this._currentSegment?.id,\n  1024→      fromSegmentIndex: this._currentSegmentIndex,\n  1025→      toSegmentIndex: prevIndex,\n  1026→      toSegmentId: this.segments[prevIndex]?.id\n  1027→    });\n  1028→\n  1029→    // Activate previous segment\n  1030→    await this._activateSegment(prevIndex, 'manual');\n  1031→    return true;\n  1032→  }\n  1033→\n  1034→  /**\n  1035→   * Jump to a specific segment by ID\n  1036→   * @param {string} segmentId - Segment ID to jump to\n  1037→   * @param {string} [triggeredBy] - Who triggered the jump (for logging)\n  1038→   * @returns {boolean} True if jumped successfully\n  1039→   */\n  1040→  async goToSegment(segmentId, triggeredBy) {\n  1041→    if (!this._isRunning) {\n  1042→      return false;\n  1043→    }\n  1044→\n  1045→    const targetIndex = this.findSegmentIndex(segmentId);\n  1046→    if (targetIndex < 0) {\n  1047→      this.emit('error', {\n  1048→        type: 'jump_failed',\n  1049→        message: `Cannot jump: segment '${segmentId}' not found`\n  1050→      });\n  1051→      return false;\n  1052→    }\n  1053→\n  1054→    if (targetIndex === this._currentSegmentIndex) {\n  1055→      // Already at this segment, nothing to do\n  1056→      return true;\n  1057→    }\n  1058→\n  1059→    // Record the override\n  1060→    this._recordOverride('jump', {\n  1061→      triggeredBy,\n  1062→      fromSegmentId: this._currentSegment?.id,\n  1063→      fromSegmentIndex: this._currentSegmentIndex,\n  1064→      toSegmentIndex: targetIndex,\n  1065→      toSegmentId: segmentId\n  1066→    });\n  1067→\n  1068→    // Activate target segment\n  1069→    await this._activateSegment(targetIndex, 'jump');\n  1070→    return true;\n  1071→  }\n  1072→\n  1073→  /**\n  1074→   * Override to a specific OBS scene (outside of normal flow)\n  1075→   * This does NOT change the current segment, only the displayed scene\n  1076→   * @param {string} sceneName - OBS scene name to switch to\n  1077→   * @param {string} [triggeredBy] - Who triggered the override (for logging)\n  1078→   * @returns {boolean} True if scene switch succeeded\n  1079→   */\n  1080→  async overrideScene(sceneName, triggeredBy) {\n  1081→    if (!this.obs) {\n  1082→      this.emit('error', {\n  1083→        type: 'override_scene_failed',\n  1084→        message: 'Cannot override scene: OBS not connected'\n  1085→      });\n  1086→      return false;\n  1087→    }\n  1088→\n  1089→    try {\n  1090→      // Switch to the scene using cut transition\n  1091→      await this.obs.call('SetCurrentSceneTransition', {\n  1092→        transitionName: 'Cut'\n  1093→      });\n  1094→      await this.obs.call('SetCurrentProgramScene', {\n  1095→        sceneName: sceneName\n  1096→      });\n  1097→\n  1098→      // Record the override\n  1099→      this._recordOverride('scene_override', {\n  1100→        triggeredBy,\n  1101→        sceneName,\n  1102→        currentSegmentId: this._currentSegment?.id,\n  1103→        currentSegmentScene: this._currentSegment?.obsScene\n  1104→      });\n  1105→\n  1106→      this.emit('sceneOverridden', {\n  1107→        sceneName,\n  1108→        segmentId: this._currentSegment?.id,\n  1109→        timestamp: Date.now()\n  1110→      });\n  1111→\n  1112→      return true;\n  1113→    } catch (error) {\n  1114→      this.emit('error', {\n  1115→        type: 'override_scene_failed',\n  1116→        message: `Failed to switch to scene '${sceneName}': ${error.message}`\n  1117→      });\n  1118→      return false;\n  1119→    }\n  1120→  }\n  1121→\n  1122→  /**\n  1123→   * Override to a specific camera's scene\n  1124→   * Looks up the camera and switches to its single-camera scene\n  1125→   * @param {string} cameraId - Camera ID to switch to\n  1126→   * @param {string} [triggeredBy] - Who triggered the override (for logging)\n  1127→   * @returns {boolean} True if camera switch succeeded\n  1128→   */\n  1129→  async overrideCamera(cameraId, triggeredBy) {\n  1130→    if (!this.obs) {\n  1131→      this.emit('error', {\n  1132→        type: 'override_camera_failed',\n  1133→        message: 'Cannot override camera: OBS not connected'\n  1134→      });\n  1135→      return false;\n  1136→    }\n  1137→\n  1138→    // Find the camera in config\n  1139→    const cameras = this.showConfig.cameras || [];\n  1140→    const camera = cameras.find(c => c.id === cameraId);\n  1141→\n  1142→    if (!camera) {\n  1143→      this.emit('error', {\n  1144→        type: 'override_camera_failed',\n  1145→        message: `Cannot override camera: camera '${cameraId}' not found`\n  1146→      });\n  1147→      return false;\n  1148→    }\n  1149→\n  1150→    // Determine scene name - use camera's scene or generate standard name\n  1151→    const sceneName = camera.sceneName || `Single - ${camera.name}`;\n  1152→\n  1153→    try {\n  1154→      // Switch to the camera's scene using cut transition\n  1155→      await this.obs.call('SetCurrentSceneTransition', {\n  1156→        transitionName: 'Cut'\n  1157→      });\n  1158→      await this.obs.call('SetCurrentProgramScene', {\n  1159→        sceneName: sceneName\n  1160→      });\n  1161→\n  1162→      // Record the override\n  1163→      this._recordOverride('camera_override', {\n  1164→        triggeredBy,\n  1165→        cameraId,\n  1166→        cameraName: camera.name,\n  1167→        sceneName,\n  1168→        currentSegmentId: this._currentSegment?.id,\n  1169→        currentSegmentScene: this._currentSegment?.obsScene\n  1170→      });\n  1171→\n  1172→      this.emit('cameraOverridden', {\n  1173→        cameraId,\n  1174→        cameraName: camera.name,\n  1175→        sceneName,\n  1176→        segmentId: this._currentSegment?.id,\n  1177→        timestamp: Date.now()\n  1178→      });\n  1179→\n  1180→      return true;\n  1181→    } catch (error) {\n  1182→      this.emit('error', {\n  1183→        type: 'override_camera_failed',\n  1184→        message: `Failed to switch to camera '${cameraId}': ${error.message}`\n  1185→      });\n  1186→      return false;\n  1187→    }\n  1188→  }\n  1189→}\n  1190→\n  1191→// Export\n  1192→export { TimesheetEngine, SEGMENT_TYPES, ENGINE_STATE, TRANSITION_TYPES };\n  1193→export default TimesheetEngine;\n  1194→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"ea3c7530-2f92-4791-9bc7-00ee83ec399a","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/lib/timesheetEngine.js","content":"/**\n * Timesheet Engine Module\n *\n * Drives show flow based on segment timing, handling auto-advance,\n * manual overrides, and producer controls.\n * Emits events for real-time UI updates and segment transitions.\n */\n\nimport { EventEmitter } from 'events';\n\n// Segment types\nconst SEGMENT_TYPES = {\n  STATIC: 'static',     // Static graphics/video\n  LIVE: 'live',         // Live camera feed\n  MULTI: 'multi',       // Multi-camera view\n  HOLD: 'hold',         // Hold for producer decision\n  BREAK: 'break',       // Commercial/intermission break\n  VIDEO: 'video',       // Pre-recorded video\n  GRAPHIC: 'graphic'    // Graphics overlay\n};\n\n// Engine states\nconst ENGINE_STATE = {\n  STOPPED: 'stopped',\n  RUNNING: 'running',\n  PAUSED: 'paused'\n};\n\n// Transition types\nconst TRANSITION_TYPES = {\n  CUT: 'cut',\n  FADE: 'fade',\n  STINGER: 'stinger'\n};\n\n/**\n * TimesheetEngine - Drives show flow based on segment timing\n *\n * Events emitted:\n * - 'tick': Emitted every second with elapsed/remaining time\n * - 'segmentActivated': Emitted when a segment becomes active\n * - 'segmentCompleted': Emitted when a segment finishes\n * - 'showStarted': Emitted when show begins\n * - 'showStopped': Emitted when show ends\n * - 'holdMaxReached': Emitted when hold segment exceeds maxDuration\n * - 'overrideRecorded': Emitted when a manual override is logged\n * - 'stateChanged': Emitted when engine state changes\n */\nclass TimesheetEngine extends EventEmitter {\n  /**\n   * Create a new TimesheetEngine\n   * @param {Object} options - Configuration options\n   * @param {string} options.compId - Competition ID for multi-competition support\n   * @param {Object} options.obsConnectionManager - OBS connection manager for per-competition OBS connections\n   * @param {Object} options.showConfig - Show configuration with segments\n   * @param {Object} options.obs - OBS WebSocket controller (optional, legacy - prefer obsConnectionManager)\n   * @param {Object} options.firebase - Firebase controller for graphics (optional)\n   * @param {Object} options.io - Socket.io server for broadcasting (optional)\n   */\n  constructor(options = {}) {\n    super();\n\n    // Multi-competition support\n    this.compId = options.compId || null;\n    this.obsConnectionManager = options.obsConnectionManager || null;\n\n    this.showConfig = options.showConfig || { segments: [] };\n    this.obs = options.obs || null;\n    this.firebase = options.firebase || null;\n    this.io = options.io || null;\n\n    // Core state\n    this._state = ENGINE_STATE.STOPPED;\n    this._isRunning = false;\n    this._currentSegmentIndex = -1;\n    this._currentSegment = null;\n    this._segmentStartTime = null;\n    this._segmentElapsedMs = 0;\n\n    // Tick timer\n    this._tickTimer = null;\n    this._tickIntervalMs = 1000; // 1 second tick\n\n    // History tracking\n    this._history = [];\n    this._overrides = [];\n\n    // Show timing\n    this._showStartTime = null;\n    this._showElapsedMs = 0;\n\n    // Track last transition for context\n    this._lastTransitionType = null;\n\n    // Track if holdMaxReached has been emitted for current segment\n    this._holdMaxReachedEmitted = false;\n  }\n\n  /**\n   * Get segments from show config\n   * @returns {Object[]} Array of segments\n   */\n  get segments() {\n    return this.showConfig.segments || [];\n  }\n\n  /**\n   * Get current engine state\n   * @returns {string} Current state (stopped, running, paused)\n   */\n  get state() {\n    return this._state;\n  }\n\n  /**\n   * Check if engine is running\n   * @returns {boolean} True if running\n   */\n  get isRunning() {\n    return this._isRunning;\n  }\n\n  /**\n   * Get current segment index\n   * @returns {number} Current segment index (-1 if not started)\n   */\n  get currentSegmentIndex() {\n    return this._currentSegmentIndex;\n  }\n\n  /**\n   * Get current segment object\n   * @returns {Object|null} Current segment or null\n   */\n  get currentSegment() {\n    return this._currentSegment;\n  }\n\n  /**\n   * Get next segment (if any)\n   * @returns {Object|null} Next segment or null\n   */\n  get nextSegment() {\n    const nextIndex = this._currentSegmentIndex + 1;\n    return nextIndex < this.segments.length ? this.segments[nextIndex] : null;\n  }\n\n  /**\n   * Get previous segment (if any)\n   * @returns {Object|null} Previous segment or null\n   */\n  get previousSegment() {\n    const prevIndex = this._currentSegmentIndex - 1;\n    return prevIndex >= 0 ? this.segments[prevIndex] : null;\n  }\n\n  /**\n   * Get elapsed time for current segment in milliseconds\n   * @returns {number} Elapsed milliseconds\n   */\n  get segmentElapsedMs() {\n    if (!this._segmentStartTime) return 0;\n    return Date.now() - this._segmentStartTime;\n  }\n\n  /**\n   * Get remaining time for current segment in milliseconds\n   * @returns {number|null} Remaining milliseconds or null if untimed\n   */\n  get segmentRemainingMs() {\n    if (!this._currentSegment || !this._currentSegment.duration) {\n      return null; // Untimed segment\n    }\n    const durationMs = this._currentSegment.duration * 1000;\n    const remaining = durationMs - this.segmentElapsedMs;\n    return Math.max(0, remaining);\n  }\n\n  /**\n   * Get segment progress (0-1)\n   * @returns {number|null} Progress fraction or null if untimed\n   */\n  get segmentProgress() {\n    if (!this._currentSegment || !this._currentSegment.duration) {\n      return null;\n    }\n    const durationMs = this._currentSegment.duration * 1000;\n    return Math.min(1, this.segmentElapsedMs / durationMs);\n  }\n\n  /**\n   * Get show elapsed time in milliseconds\n   * @returns {number} Show elapsed milliseconds\n   */\n  get showElapsedMs() {\n    if (!this._showStartTime) return 0;\n    return Date.now() - this._showStartTime;\n  }\n\n  /**\n   * Get segment history\n   * @returns {Object[]} Array of history entries\n   */\n  get history() {\n    return [...this._history];\n  }\n\n  /**\n   * Get override log\n   * @returns {Object[]} Array of override entries\n   */\n  get overrides() {\n    return [...this._overrides];\n  }\n\n  /**\n   * Start the show from the first segment\n   */\n  async start() {\n    if (this._isRunning) {\n      return;\n    }\n\n    if (this.segments.length === 0) {\n      this.emit('error', new Error('No segments defined in show config'));\n      return;\n    }\n\n    this._isRunning = true;\n    this._state = ENGINE_STATE.RUNNING;\n    this._showStartTime = Date.now();\n    this._history = [];\n    this._overrides = [];\n\n    // Start tick timer\n    this._startTick();\n\n    // Activate first segment\n    await this._activateSegment(0, 'start');\n\n    this.emit('showStarted', {\n      timestamp: Date.now(),\n      segmentCount: this.segments.length\n    });\n\n    this.emit('stateChanged', {\n      previousState: ENGINE_STATE.STOPPED,\n      newState: ENGINE_STATE.RUNNING\n    });\n  }\n\n  /**\n   * Stop the show\n   */\n  stop() {\n    if (!this._isRunning) {\n      return;\n    }\n\n    // Record final segment in history\n    if (this._currentSegment) {\n      this._recordHistory('completed');\n    }\n\n    this._isRunning = false;\n    this._state = ENGINE_STATE.STOPPED;\n    this._stopTick();\n\n    const showDurationMs = Date.now() - this._showStartTime;\n\n    this.emit('showStopped', {\n      timestamp: Date.now(),\n      showDurationMs,\n      segmentsCompleted: this._history.length,\n      overrideCount: this._overrides.length\n    });\n\n    this.emit('stateChanged', {\n      previousState: ENGINE_STATE.RUNNING,\n      newState: ENGINE_STATE.STOPPED\n    });\n\n    // Reset state\n    this._currentSegmentIndex = -1;\n    this._currentSegment = null;\n    this._segmentStartTime = null;\n    this._showStartTime = null;\n  }\n\n  /**\n   * Pause the show (stops tick but preserves state)\n   */\n  pause() {\n    if (!this._isRunning || this._state === ENGINE_STATE.PAUSED) {\n      return;\n    }\n\n    this._state = ENGINE_STATE.PAUSED;\n    this._segmentElapsedMs = this.segmentElapsedMs; // Capture current elapsed\n    this._stopTick();\n\n    this.emit('stateChanged', {\n      previousState: ENGINE_STATE.RUNNING,\n      newState: ENGINE_STATE.PAUSED\n    });\n  }\n\n  /**\n   * Resume the show from paused state\n   */\n  resume() {\n    if (this._state !== ENGINE_STATE.PAUSED) {\n      return;\n    }\n\n    this._state = ENGINE_STATE.RUNNING;\n    // Adjust start time to account for pause\n    this._segmentStartTime = Date.now() - this._segmentElapsedMs;\n    this._startTick();\n\n    this.emit('stateChanged', {\n      previousState: ENGINE_STATE.PAUSED,\n      newState: ENGINE_STATE.RUNNING\n    });\n  }\n\n  /**\n   * Start the tick timer\n   * @private\n   */\n  _startTick() {\n    if (this._tickTimer) {\n      return;\n    }\n\n    this._tickTimer = setInterval(() => {\n      this._tick();\n    }, this._tickIntervalMs);\n  }\n\n  /**\n   * Stop the tick timer\n   * @private\n   */\n  _stopTick() {\n    if (this._tickTimer) {\n      clearInterval(this._tickTimer);\n      this._tickTimer = null;\n    }\n  }\n\n  /**\n   * Tick handler - called every second\n   * @private\n   */\n  _tick() {\n    if (!this._isRunning || this._state !== ENGINE_STATE.RUNNING) {\n      return;\n    }\n\n    const elapsedMs = this.segmentElapsedMs;\n    const remainingMs = this.segmentRemainingMs;\n    const progress = this.segmentProgress;\n\n    // Emit tick event\n    this.emit('tick', {\n      timestamp: Date.now(),\n      segmentId: this._currentSegment?.id,\n      segmentIndex: this._currentSegmentIndex,\n      elapsedMs,\n      remainingMs,\n      progress,\n      showElapsedMs: this.showElapsedMs\n    });\n\n    // Check for hold segment max duration warning\n    if (this._currentSegment?.type === SEGMENT_TYPES.HOLD) {\n      const maxDurationMs = (this._currentSegment.maxDuration || 0) * 1000;\n      if (maxDurationMs > 0 && elapsedMs >= maxDurationMs && !this._holdMaxReachedEmitted) {\n        this._holdMaxReachedEmitted = true;\n        this.emit('holdMaxReached', {\n          segmentId: this._currentSegment.id,\n          elapsedMs,\n          maxDurationMs\n        });\n      }\n    }\n\n    // Check for auto-advance\n    this._checkAutoAdvance(elapsedMs);\n  }\n\n  /**\n   * Check if segment should auto-advance and trigger if appropriate\n   * @param {number} elapsedMs - Current elapsed time in milliseconds\n   * @private\n   */\n  _checkAutoAdvance(elapsedMs) {\n    // No current segment or no more segments\n    if (!this._currentSegment) return;\n    const nextIndex = this._currentSegmentIndex + 1;\n    if (nextIndex >= this.segments.length) return;\n\n    // Hold segments NEVER auto-advance - producer must decide\n    if (this._currentSegment.type === SEGMENT_TYPES.HOLD) {\n      return;\n    }\n\n    // Check autoAdvance flag on segment (default true for timed segments)\n    const autoAdvance = this._currentSegment.autoAdvance !== false;\n    if (!autoAdvance) {\n      return;\n    }\n\n    // Must have a duration to auto-advance\n    const durationMs = (this._currentSegment.duration || 0) * 1000;\n    if (durationMs <= 0) {\n      return;\n    }\n\n    // Check if elapsed time has reached or exceeded duration\n    if (elapsedMs >= durationMs) {\n      this._autoAdvance();\n    }\n  }\n\n  /**\n   * Auto-advance to the next segment\n   * @private\n   */\n  async _autoAdvance() {\n    const nextIndex = this._currentSegmentIndex + 1;\n\n    // Emit event before advancing\n    this.emit('autoAdvancing', {\n      fromSegmentId: this._currentSegment?.id,\n      fromSegmentIndex: this._currentSegmentIndex,\n      toSegmentIndex: nextIndex,\n      timestamp: Date.now()\n    });\n\n    // Activate next segment\n    await this._activateSegment(nextIndex, 'auto');\n  }\n\n  /**\n   * Check if hold segment has met minimum duration requirement\n   * @returns {boolean} True if hold can be advanced\n   */\n  canAdvanceHold() {\n    if (!this._currentSegment || this._currentSegment.type !== SEGMENT_TYPES.HOLD) {\n      return true; // Not a hold segment, can always advance\n    }\n\n    const minDurationMs = (this._currentSegment.minDuration || 0) * 1000;\n    const elapsedMs = this.segmentElapsedMs;\n\n    return elapsedMs >= minDurationMs;\n  }\n\n  /**\n   * Get remaining time before hold can be advanced\n   * @returns {number} Milliseconds remaining before minDuration is met (0 if already met)\n   */\n  getHoldRemainingMs() {\n    if (!this._currentSegment || this._currentSegment.type !== SEGMENT_TYPES.HOLD) {\n      return 0;\n    }\n\n    const minDurationMs = (this._currentSegment.minDuration || 0) * 1000;\n    const elapsedMs = this.segmentElapsedMs;\n\n    return Math.max(0, minDurationMs - elapsedMs);\n  }\n\n  /**\n   * Activate a segment by index\n   * @param {number} index - Segment index to activate\n   * @param {string} reason - Why this segment was activated (auto, manual, jump)\n   * @private\n   */\n  async _activateSegment(index, reason = 'manual') {\n    if (index < 0 || index >= this.segments.length) {\n      return false;\n    }\n\n    // Record previous segment in history\n    if (this._currentSegment) {\n      this._recordHistory(reason === 'auto' ? 'auto_advanced' : 'advanced');\n    }\n\n    const previousSegment = this._currentSegment;\n    const segment = this.segments[index];\n\n    this._currentSegmentIndex = index;\n    this._currentSegment = segment;\n    this._segmentStartTime = Date.now();\n    this._segmentElapsedMs = 0;\n    this._holdMaxReachedEmitted = false;\n\n    // Determine transition type based on segment types\n    const transition = this._getTransition(previousSegment, segment);\n    this._lastTransitionType = transition.type;\n\n    // Apply transition and switch scene\n    await this._applyTransitionAndSwitchScene(segment, transition);\n\n    // Handle segment-type specific actions\n    await this._handleSegmentTypeActions(segment);\n\n    // Apply audio overrides if defined\n    await this._applyAudioOverrides(segment);\n\n    this.emit('segmentActivated', {\n      timestamp: Date.now(),\n      segmentIndex: index,\n      segment: { ...segment },\n      previousSegmentIndex: this._history.length > 0\n        ? this._history[this._history.length - 1].segmentIndex\n        : -1,\n      transition: transition,\n      reason\n    });\n\n    return true;\n  }\n\n  /**\n   * Get the appropriate transition for segment change\n   * @param {Object|null} fromSegment - Previous segment\n   * @param {Object} toSegment - Next segment\n   * @returns {Object} Transition config {type, durationMs}\n   * @private\n   */\n  _getTransition(fromSegment, toSegment) {\n    const transitions = this.showConfig.transitions || {};\n\n    // Check for segment-specific transition\n    if (toSegment.transition) {\n      return {\n        type: toSegment.transition.type || TRANSITION_TYPES.CUT,\n        durationMs: toSegment.transition.durationMs || 0\n      };\n    }\n\n    // Going to break\n    if (toSegment.type === SEGMENT_TYPES.BREAK && transitions.toBreak) {\n      return transitions.toBreak;\n    }\n\n    // Coming from break\n    if (fromSegment?.type === SEGMENT_TYPES.BREAK && transitions.fromBreak) {\n      return transitions.fromBreak;\n    }\n\n    // Default transition\n    return transitions.default || { type: TRANSITION_TYPES.CUT, durationMs: 0 };\n  }\n\n  /**\n   * Apply transition and switch OBS scene\n   * @param {Object} segment - Segment to switch to\n   * @param {Object} transition - Transition config\n   * @private\n   */\n  async _applyTransitionAndSwitchScene(segment, transition) {\n    if (!this.obs || !segment.obsScene) {\n      return;\n    }\n\n    try {\n      if (transition.type === TRANSITION_TYPES.FADE && transition.durationMs > 0) {\n        // Use SetCurrentSceneTransitionDuration and then switch\n        await this.obs.call('SetCurrentSceneTransitionDuration', {\n          transitionDuration: transition.durationMs\n        });\n        await this.obs.call('SetCurrentSceneTransition', {\n          transitionName: 'Fade'\n        });\n      } else if (transition.type === TRANSITION_TYPES.STINGER) {\n        // Use stinger transition if configured\n        await this.obs.call('SetCurrentSceneTransition', {\n          transitionName: transition.transitionName || 'Stinger'\n        });\n      } else {\n        // Cut transition (instant)\n        await this.obs.call('SetCurrentSceneTransition', {\n          transitionName: 'Cut'\n        });\n      }\n\n      // Switch to the scene\n      await this.obs.call('SetCurrentProgramScene', {\n        sceneName: segment.obsScene\n      });\n\n      this.emit('sceneChanged', {\n        sceneName: segment.obsScene,\n        transition: transition,\n        segmentId: segment.id\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'obs_scene_switch',\n        message: `Failed to switch to scene ${segment.obsScene}: ${error.message}`,\n        segmentId: segment.id\n      });\n    }\n  }\n\n  /**\n   * Handle segment-type specific actions\n   * @param {Object} segment - Current segment\n   * @private\n   */\n  async _handleSegmentTypeActions(segment) {\n    switch (segment.type) {\n      case SEGMENT_TYPES.STATIC:\n        // Static scene, nothing special to do\n        break;\n\n      case SEGMENT_TYPES.LIVE:\n      case SEGMENT_TYPES.MULTI:\n        // Live camera feed - trigger any associated graphics\n        if (segment.graphic) {\n          await this._triggerGraphic(segment);\n        }\n        break;\n\n      case SEGMENT_TYPES.HOLD:\n        // Hold segment - emit hold started event\n        this.emit('holdStarted', {\n          segmentId: segment.id,\n          minDuration: segment.minDuration || 0,\n          maxDuration: segment.maxDuration || null\n        });\n        break;\n\n      case SEGMENT_TYPES.BREAK:\n        // Break segment - could trigger break graphics\n        if (segment.graphic) {\n          await this._triggerGraphic(segment);\n        }\n        this.emit('breakStarted', {\n          segmentId: segment.id,\n          duration: segment.duration || null\n        });\n        break;\n\n      case SEGMENT_TYPES.VIDEO:\n        // Video segment - set video file and play\n        if (segment.videoFile && this.obs) {\n          await this._playVideo(segment);\n        }\n        break;\n\n      case SEGMENT_TYPES.GRAPHIC:\n        // Graphics segment - trigger the graphic\n        await this._triggerGraphic(segment);\n        break;\n\n      default:\n        // Unknown segment type, try to trigger graphic if present\n        if (segment.graphic) {\n          await this._triggerGraphic(segment);\n        }\n    }\n  }\n\n  /**\n   * Trigger a graphic via Firebase or socket.io\n   * @param {Object} segment - Segment with graphic configuration\n   * @private\n   */\n  async _triggerGraphic(segment) {\n    if (!segment.graphic) return;\n\n    const graphicData = {\n      graphic: segment.graphic,\n      data: segment.graphicData || {},\n      segmentId: segment.id,\n      timestamp: Date.now()\n    };\n\n    // Try Firebase first if available\n    if (this.firebase) {\n      try {\n        await this.firebase.database().ref('graphics/current').set(graphicData);\n      } catch (error) {\n        this.emit('error', {\n          type: 'firebase_graphic',\n          message: `Failed to trigger graphic via Firebase: ${error.message}`,\n          segmentId: segment.id\n        });\n      }\n    }\n\n    // Also broadcast via socket.io\n    if (this.io) {\n      this.io.emit('triggerGraphic', graphicData);\n    }\n\n    // Emit event for any listeners\n    this.emit('graphicTriggered', graphicData);\n  }\n\n  /**\n   * Play a video segment via OBS media source\n   * @param {Object} segment - Segment with video configuration\n   * @private\n   */\n  async _playVideo(segment) {\n    if (!this.obs || !segment.videoFile) return;\n\n    const sourceName = segment.videoSource || 'Video Player';\n\n    try {\n      // Get current settings\n      const { inputSettings } = await this.obs.call('GetInputSettings', {\n        inputName: sourceName\n      });\n\n      // Update with new file path\n      await this.obs.call('SetInputSettings', {\n        inputName: sourceName,\n        inputSettings: {\n          ...inputSettings,\n          local_file: segment.videoFile,\n          is_local_file: true\n        }\n      });\n\n      // Restart the media source to play from beginning\n      await this.obs.call('TriggerMediaInputAction', {\n        inputName: sourceName,\n        mediaAction: 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n      });\n\n      this.emit('videoStarted', {\n        segmentId: segment.id,\n        videoFile: segment.videoFile,\n        sourceName\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'obs_video',\n        message: `Failed to play video ${segment.videoFile}: ${error.message}`,\n        segmentId: segment.id\n      });\n    }\n  }\n\n  /**\n   * Apply audio overrides for a segment\n   * @param {Object} segment - Current segment\n   * @private\n   */\n  async _applyAudioOverrides(segment) {\n    if (!this.obs || !segment.audio) return;\n\n    const audioConfig = this.showConfig.audioConfig || {};\n\n    try {\n      // Apply venue audio volume\n      if (segment.audio.venueVolume !== undefined && audioConfig.venue?.sourceName) {\n        await this.obs.call('SetInputVolume', {\n          inputName: audioConfig.venue.sourceName,\n          inputVolumeDb: this._volumeToDb(segment.audio.venueVolume)\n        });\n      }\n\n      // Apply commentary audio volume\n      if (segment.audio.commentaryVolume !== undefined && audioConfig.commentary?.sourceName) {\n        await this.obs.call('SetInputVolume', {\n          inputName: audioConfig.commentary.sourceName,\n          inputVolumeDb: this._volumeToDb(segment.audio.commentaryVolume)\n        });\n      }\n\n      // Apply mute states\n      if (segment.audio.muteVenue !== undefined && audioConfig.venue?.sourceName) {\n        await this.obs.call('SetInputMute', {\n          inputName: audioConfig.venue.sourceName,\n          inputMuted: segment.audio.muteVenue\n        });\n      }\n\n      if (segment.audio.muteCommentary !== undefined && audioConfig.commentary?.sourceName) {\n        await this.obs.call('SetInputMute', {\n          inputName: audioConfig.commentary.sourceName,\n          inputMuted: segment.audio.muteCommentary\n        });\n      }\n\n      this.emit('audioChanged', {\n        segmentId: segment.id,\n        audio: segment.audio\n      });\n    } catch (error) {\n      this.emit('error', {\n        type: 'obs_audio',\n        message: `Failed to apply audio overrides: ${error.message}`,\n        segmentId: segment.id\n      });\n    }\n  }\n\n  /**\n   * Convert volume (0-1) to decibels\n   * @param {number} volume - Volume from 0 to 1\n   * @returns {number} Volume in decibels\n   * @private\n   */\n  _volumeToDb(volume) {\n    if (volume <= 0) return -100; // Essentially silent\n    if (volume >= 1) return 0;    // Full volume\n    // Convert linear to dB: 20 * log10(volume)\n    return 20 * Math.log10(volume);\n  }\n\n  /**\n   * Record segment in history\n   * @param {string} endReason - Why segment ended\n   * @private\n   */\n  _recordHistory(endReason) {\n    if (!this._currentSegment) return;\n\n    this._history.push({\n      segmentId: this._currentSegment.id,\n      segmentIndex: this._currentSegmentIndex,\n      segmentName: this._currentSegment.name,\n      startTime: this._segmentStartTime,\n      endTime: Date.now(),\n      durationMs: this.segmentElapsedMs,\n      plannedDurationMs: this._currentSegment.duration\n        ? this._currentSegment.duration * 1000\n        : null,\n      endReason\n    });\n\n    this.emit('segmentCompleted', {\n      segmentId: this._currentSegment.id,\n      segmentIndex: this._currentSegmentIndex,\n      durationMs: this.segmentElapsedMs,\n      endReason\n    });\n  }\n\n  /**\n   * Record an override action\n   * @param {string} type - Override type\n   * @param {Object} details - Override details\n   * @private\n   */\n  _recordOverride(type, details) {\n    const override = {\n      timestamp: Date.now(),\n      type,\n      segmentId: this._currentSegment?.id,\n      segmentIndex: this._currentSegmentIndex,\n      showElapsedMs: this.showElapsedMs,\n      ...details\n    };\n\n    this._overrides.push(override);\n\n    this.emit('overrideRecorded', override);\n  }\n\n  /**\n   * Get full timesheet state for clients\n   * @returns {Object} Current timesheet state\n   */\n  getState() {\n    const isHold = this._currentSegment?.type === SEGMENT_TYPES.HOLD;\n\n    return {\n      state: this._state,\n      isRunning: this._isRunning,\n      currentSegmentIndex: this._currentSegmentIndex,\n      currentSegment: this._currentSegment ? { ...this._currentSegment } : null,\n      nextSegment: this.nextSegment ? { ...this.nextSegment } : null,\n      previousSegment: this.previousSegment ? { ...this.previousSegment } : null,\n      segmentElapsedMs: this.segmentElapsedMs,\n      segmentRemainingMs: this.segmentRemainingMs,\n      segmentProgress: this.segmentProgress,\n      showElapsedMs: this.showElapsedMs,\n      showStartTime: this._showStartTime,\n      segmentCount: this.segments.length,\n      historyCount: this._history.length,\n      overrideCount: this._overrides.length,\n      // Hold segment state\n      isHoldSegment: isHold,\n      canAdvanceHold: this.canAdvanceHold(),\n      holdRemainingMs: isHold ? this.getHoldRemainingMs() : 0\n    };\n  }\n\n  /**\n   * Get override history\n   * @returns {Object[]} Array of override entries\n   */\n  getOverrides() {\n    return [...this._overrides];\n  }\n\n  /**\n   * Get segment history\n   * @returns {Object[]} Array of history entries\n   */\n  getHistory() {\n    return [...this._history];\n  }\n\n  /**\n   * Update show config (e.g., after hot reload)\n   * @param {Object} showConfig - New show configuration\n   */\n  updateConfig(showConfig) {\n    const wasRunning = this._isRunning;\n    const currentSegmentId = this._currentSegment?.id;\n\n    this.showConfig = showConfig;\n\n    // If running, try to maintain position by segment ID\n    if (wasRunning && currentSegmentId) {\n      const newIndex = this.segments.findIndex(s => s.id === currentSegmentId);\n      if (newIndex >= 0) {\n        this._currentSegmentIndex = newIndex;\n        this._currentSegment = this.segments[newIndex];\n      }\n    }\n  }\n\n  /**\n   * Find segment index by ID\n   * @param {string} segmentId - Segment ID to find\n   * @returns {number} Segment index or -1 if not found\n   */\n  findSegmentIndex(segmentId) {\n    return this.segments.findIndex(s => s.id === segmentId);\n  }\n\n  /**\n   * Get segment by ID\n   * @param {string} segmentId - Segment ID to find\n   * @returns {Object|null} Segment or null if not found\n   */\n  getSegment(segmentId) {\n    return this.segments.find(s => s.id === segmentId) || null;\n  }\n\n  // ============================================================\n  // MANUAL CONTROLS AND OVERRIDES\n  // ============================================================\n\n  /**\n   * Advance to the next segment (manual)\n   * @param {string} [advancedBy] - Who triggered the advance (for logging)\n   * @returns {boolean} True if advanced successfully\n   */\n  async advance(advancedBy) {\n    if (!this._isRunning) {\n      return false;\n    }\n\n    const nextIndex = this._currentSegmentIndex + 1;\n    if (nextIndex >= this.segments.length) {\n      this.emit('error', {\n        type: 'advance_failed',\n        message: 'Cannot advance: already at last segment'\n      });\n      return false;\n    }\n\n    // For hold segments, check minDuration\n    if (this._currentSegment?.type === SEGMENT_TYPES.HOLD && !this.canAdvanceHold()) {\n      this.emit('error', {\n        type: 'advance_blocked',\n        message: `Cannot advance: hold segment requires ${this.getHoldRemainingMs()}ms more`,\n        holdRemainingMs: this.getHoldRemainingMs()\n      });\n      return false;\n    }\n\n    // Record the override\n    this._recordOverride('advance', {\n      advancedBy,\n      fromSegmentId: this._currentSegment?.id,\n      fromSegmentIndex: this._currentSegmentIndex,\n      toSegmentIndex: nextIndex,\n      toSegmentId: this.segments[nextIndex]?.id\n    });\n\n    // Activate next segment\n    await this._activateSegment(nextIndex, 'manual');\n    return true;\n  }\n\n  /**\n   * Go to the previous segment (manual)\n   * @param {string} [triggeredBy] - Who triggered the previous (for logging)\n   * @returns {boolean} True if went back successfully\n   */\n  async previous(triggeredBy) {\n    if (!this._isRunning) {\n      return false;\n    }\n\n    const prevIndex = this._currentSegmentIndex - 1;\n    if (prevIndex < 0) {\n      this.emit('error', {\n        type: 'previous_failed',\n        message: 'Cannot go previous: already at first segment'\n      });\n      return false;\n    }\n\n    // Record the override\n    this._recordOverride('previous', {\n      triggeredBy,\n      fromSegmentId: this._currentSegment?.id,\n      fromSegmentIndex: this._currentSegmentIndex,\n      toSegmentIndex: prevIndex,\n      toSegmentId: this.segments[prevIndex]?.id\n    });\n\n    // Activate previous segment\n    await this._activateSegment(prevIndex, 'manual');\n    return true;\n  }\n\n  /**\n   * Jump to a specific segment by ID\n   * @param {string} segmentId - Segment ID to jump to\n   * @param {string} [triggeredBy] - Who triggered the jump (for logging)\n   * @returns {boolean} True if jumped successfully\n   */\n  async goToSegment(segmentId, triggeredBy) {\n    if (!this._isRunning) {\n      return false;\n    }\n\n    const targetIndex = this.findSegmentIndex(segmentId);\n    if (targetIndex < 0) {\n      this.emit('error', {\n        type: 'jump_failed',\n        message: `Cannot jump: segment '${segmentId}' not found`\n      });\n      return false;\n    }\n\n    if (targetIndex === this._currentSegmentIndex) {\n      // Already at this segment, nothing to do\n      return true;\n    }\n\n    // Record the override\n    this._recordOverride('jump', {\n      triggeredBy,\n      fromSegmentId: this._currentSegment?.id,\n      fromSegmentIndex: this._currentSegmentIndex,\n      toSegmentIndex: targetIndex,\n      toSegmentId: segmentId\n    });\n\n    // Activate target segment\n    await this._activateSegment(targetIndex, 'jump');\n    return true;\n  }\n\n  /**\n   * Override to a specific OBS scene (outside of normal flow)\n   * This does NOT change the current segment, only the displayed scene\n   * @param {string} sceneName - OBS scene name to switch to\n   * @param {string} [triggeredBy] - Who triggered the override (for logging)\n   * @returns {boolean} True if scene switch succeeded\n   */\n  async overrideScene(sceneName, triggeredBy) {\n    if (!this.obs) {\n      this.emit('error', {\n        type: 'override_scene_failed',\n        message: 'Cannot override scene: OBS not connected'\n      });\n      return false;\n    }\n\n    try {\n      // Switch to the scene using cut transition\n      await this.obs.call('SetCurrentSceneTransition', {\n        transitionName: 'Cut'\n      });\n      await this.obs.call('SetCurrentProgramScene', {\n        sceneName: sceneName\n      });\n\n      // Record the override\n      this._recordOverride('scene_override', {\n        triggeredBy,\n        sceneName,\n        currentSegmentId: this._currentSegment?.id,\n        currentSegmentScene: this._currentSegment?.obsScene\n      });\n\n      this.emit('sceneOverridden', {\n        sceneName,\n        segmentId: this._currentSegment?.id,\n        timestamp: Date.now()\n      });\n\n      return true;\n    } catch (error) {\n      this.emit('error', {\n        type: 'override_scene_failed',\n        message: `Failed to switch to scene '${sceneName}': ${error.message}`\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Override to a specific camera's scene\n   * Looks up the camera and switches to its single-camera scene\n   * @param {string} cameraId - Camera ID to switch to\n   * @param {string} [triggeredBy] - Who triggered the override (for logging)\n   * @returns {boolean} True if camera switch succeeded\n   */\n  async overrideCamera(cameraId, triggeredBy) {\n    if (!this.obs) {\n      this.emit('error', {\n        type: 'override_camera_failed',\n        message: 'Cannot override camera: OBS not connected'\n      });\n      return false;\n    }\n\n    // Find the camera in config\n    const cameras = this.showConfig.cameras || [];\n    const camera = cameras.find(c => c.id === cameraId);\n\n    if (!camera) {\n      this.emit('error', {\n        type: 'override_camera_failed',\n        message: `Cannot override camera: camera '${cameraId}' not found`\n      });\n      return false;\n    }\n\n    // Determine scene name - use camera's scene or generate standard name\n    const sceneName = camera.sceneName || `Single - ${camera.name}`;\n\n    try {\n      // Switch to the camera's scene using cut transition\n      await this.obs.call('SetCurrentSceneTransition', {\n        transitionName: 'Cut'\n      });\n      await this.obs.call('SetCurrentProgramScene', {\n        sceneName: sceneName\n      });\n\n      // Record the override\n      this._recordOverride('camera_override', {\n        triggeredBy,\n        cameraId,\n        cameraName: camera.name,\n        sceneName,\n        currentSegmentId: this._currentSegment?.id,\n        currentSegmentScene: this._currentSegment?.obsScene\n      });\n\n      this.emit('cameraOverridden', {\n        cameraId,\n        cameraName: camera.name,\n        sceneName,\n        segmentId: this._currentSegment?.id,\n        timestamp: Date.now()\n      });\n\n      return true;\n    } catch (error) {\n      this.emit('error', {\n        type: 'override_camera_failed',\n        message: `Failed to switch to camera '${cameraId}': ${error.message}`\n      });\n      return false;\n    }\n  }\n}\n\n// Export\nexport { TimesheetEngine, SEGMENT_TYPES, ENGINE_STATE, TRANSITION_TYPES };\nexport default TimesheetEngine;\n","numLines":1194,"startLine":1,"totalLines":1194}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01H7FvF3TS2bBX7aY9MYjT4r","type":"message","role":"assistant","content":[{"type":"text","text":"I see that the TimesheetEngine constructor **already has** `compId` and `obsConnectionManager` parameters! Looking at lines 53-66:\n\n```javascript\nconstructor(options = {}) {\n  super();\n\n  // Multi-competition support\n  this.compId = options.compId || null;\n  this.obsConnectionManager = options.obsConnectionManager || null;\n\n  this.showConfig = options.showConfig || { segments: [] };\n  this.obs = options.obs || null;\n  this.firebase = options.firebase || null;\n  this.io = options.io || null;\n  ...\n}\n```\n\nThe constructor already accepts and stores:\n- `compId` (line 64)\n- `obsConnectionManager` (line 65)\n\n**Task 1 is already complete!** This was likely implemented in a previous commit. Let me verify by checking the git log for this file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14304,"cache_read_input_tokens":51887,"cache_creation":{"ephemeral_5m_input_tokens":14304,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"270dde75-02c8-46eb-b5f9-28f651864ac7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01H7FvF3TS2bBX7aY9MYjT4r","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QoBv9FnTF18UpBJz2kYGLQ","name":"Bash","input":{"command":"git log --oneline -5 server/lib/timesheetEngine.js","description":"Check git history for timesheetEngine.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":14304,"cache_read_input_tokens":51887,"cache_creation":{"ephemeral_5m_input_tokens":14304,"ephemeral_1h_input_tokens":0},"output_tokens":321,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"5348d23f-6bef-475c-ae20-2169260b8b22"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QoBv9FnTF18UpBJz2kYGLQ","type":"tool_result","content":"9d0267c PRD-Rundown-System Task 1: Add compId and obsConnectionManager to TimesheetEngine\nf24f59b Add manual controls and overrides (P4-04)\n7353137 Add auto-advance and hold logic (P4-03)\n80960e3 Add segment activation logic (P4-02)\nfe507b4 Add timesheet engine core module (P4-01)","is_error":false}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"4cf4a365-62b2-4915-a661-4bb637fbb15f","tool_use_result":{"stdout":"9d0267c PRD-Rundown-System Task 1: Add compId and obsConnectionManager to TimesheetEngine\nf24f59b Add manual controls and overrides (P4-04)\n7353137 Add auto-advance and hold logic (P4-03)\n80960e3 Add segment activation logic (P4-02)\nfe507b4 Add timesheet engine core module (P4-01)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0142kyrgrityEjNAGKL7QsZt","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed - Task 1 was completed in commit `9d0267c`. The Implementation Plan is out of date. Let me update it to mark Task 1 as COMPLETE and then proceed to Task 2."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":518,"cache_read_input_tokens":66191,"cache_creation":{"ephemeral_5m_input_tokens":518,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"c26153fe-02e1-497b-8653-8d07090e4f83"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0142kyrgrityEjNAGKL7QsZt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015mM61XPb5majfTtJ9tDJHB","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","old_string":"| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |","new_string":"| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":518,"cache_read_input_tokens":66191,"cache_creation":{"ephemeral_5m_input_tokens":518,"ephemeral_1h_input_tokens":0},"output_tokens":242,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"dead7a13-942c-42bf-bde2-25de1830d259"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015mM61XPb5majfTtJ9tDJHB","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"ce5c84ab-54c0-4324-8de6-e06ccd2b31f1","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","oldString":"| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |","newString":"| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |","originalFile":"# PLAN-Rundown-System-Implementation\n\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n**Status:** NOT STARTED\n**Created:** 2026-01-23\n**Last Updated:** 2026-01-23\n\n---\n\n## Overview\n\nThis implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n\n---\n\n## IMPORTANT: Task Execution Rules\n\n**ONE TASK = ONE ITERATION**\n\nEach row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n\n1. Pick the first NOT STARTED or IN PROGRESS task\n2. Implement that ONE task\n3. Commit, deploy, verify\n4. STOP - the next iteration will handle the next task\n\n**Do NOT:**\n- Complete multiple tasks in one iteration\n- Batch \"related\" tasks together\n- Complete an entire phase in one iteration\n\n**Task Numbering:**\n- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n- Each task number is unique and independent\n- Example: \"Task 8\" is ONE task, not a subtask\n\n---\n\n## Phase Summary\n\n| Phase | Name | Priority | Status | Tasks |\n|-------|------|----------|--------|-------|\n| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n| B | Talent View | P1 | NOT STARTED | 22-27 |\n| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n\n---\n\n## Task Summary by Phase\n\n### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |\n| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |\n| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n\n### Phase H: Rehearsal Mode (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n\n### Phase B: Talent View (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n| Task 24 | Scene switching buttons | NOT STARTED | |\n| Task 25 | Next segment preview | NOT STARTED | |\n| Task 26 | Notes display | NOT STARTED | |\n| Task 27 | Add `/talent` route | NOT STARTED | |\n\n### Phase I: Live Rundown Sync (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n| Task 35 | Handle deleted current segment | NOT STARTED | |\n| Task 36 | Handle reordered past segments | NOT STARTED | |\n| Task 37 | Handle ID conflicts | NOT STARTED | |\n\n### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 38 | Log actual segment durations during show | NOT STARTED | |\n| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n\n### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n\n### Phase E: Script & Talent Flow (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 49 | Add script field to segment data model | NOT STARTED | |\n| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n| Task 53 | Create talent schedule view | NOT STARTED | |\n| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n\n### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 55 | Create AIContextService stub | NOT STARTED | |\n| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n| Task 59 | Generate talking points in real-time | NOT STARTED | |\n| Task 60 | Detect career highs, records during show | NOT STARTED | |\n| Task 61 | Display AI context in Talent View | NOT STARTED | |\n| Task 62 | Display AI context in Producer View | NOT STARTED | |\n\n### Phase F: Audio Cue Integration (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n| Task 66 | Add audio control to Producer View | NOT STARTED | |\n\n### Phase G: Production Tracking (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n| Task 68 | Generate equipment schedule report | NOT STARTED | |\n| Task 69 | Detect equipment conflicts | NOT STARTED | |\n| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n\n---\n\n## Detailed Tasks - Phase A (P0)\n\n### Task 1: Update TimesheetEngine constructor\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n\n**Checklist:**\n- [ ] Add `compId` parameter to constructor\n- [ ] Add `obsConnectionManager` parameter to constructor\n- [ ] Store both as instance properties\n- [ ] Remove dependency on global `obs` singleton\n\n---\n\n### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic\n\n---\n\n### Task 3: Update _applyTransitionAndSwitchScene()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the scene switching method to use per-competition OBS connection via obsConnectionManager.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n- [ ] Add error handling for disconnected state\n\n---\n\n### Task 4: Update _playVideo()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the video playback method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 5: Update _applyAudioOverrides()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the audio override method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 6: Update socket event broadcasts\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate all socket.io event emissions to target the competition-specific room.\n\n**Checklist:**\n- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n- [ ] Verify room naming matches existing convention\n\n---\n\n### Task 7: Pass Firebase Admin to engine\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n\n**Description:**\nPass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n\n**Checklist:**\n- [ ] Add `firebase` parameter to constructor\n- [ ] Export `db` from productionConfigService.js\n- [ ] Pass Firebase instance when creating engine\n- [ ] Update `_triggerGraphic()` to use `this.firebase`\n\n---\n\n### Task 8: Add loadRundown socket handler\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nAdd socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n\n**Checklist:**\n- [ ] Add `socket.on('loadRundown', ...)` handler\n- [ ] Extract `compId` from payload\n- [ ] Call `getOrCreateEngine()` to get engine instance\n- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n- [ ] Call engine's load method with segments\n- [ ] Emit `timesheetState` with loaded segments\n\n---\n\n### Task 9: Add loadRundown action in ShowContext\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/context/ShowContext.jsx`\n\n**Description:**\nAdd `loadRundown` action to emit the socket event from client.\n\n**Checklist:**\n- [ ] Add `loadRundown` function that emits `loadRundown` event\n- [ ] Pass `compId` from context\n- [ ] Export function from context\n\n---\n\n### Task 10: Add \"Load Rundown\" button\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd \"Load Rundown\" button in Producer View header/toolbar.\n\n**Checklist:**\n- [ ] Add \"Load Rundown\" button to Producer View\n- [ ] Wire button to `loadRundown` action from ShowContext\n- [ ] Show loading state while loading\n- [ ] Show toast on success/failure\n\n---\n\n### Task 11: Create segment mapper\n\n**Status:** NOT STARTED\n**File:** `server/lib/segmentMapper.js` (new file)\n\n**Description:**\nCreate utility to map Rundown Editor segment format to Timesheet Engine format.\n\n**Checklist:**\n- [ ] Create `server/lib/segmentMapper.js`\n- [ ] Map `scene` → `obsScene`\n- [ ] Map `graphic.graphicId` → `graphic`\n- [ ] Map `graphic.params` → `graphicData`\n- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n- [ ] Preserve all other fields\n\n---\n\n### Task 12: Verify Firebase passed to engine\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nVerify Firebase Admin is correctly passed and usable in engine.\n\n**Checklist:**\n- [ ] Add logging to confirm Firebase instance received\n- [ ] Test that `_triggerGraphic()` can write to Firebase\n- [ ] Handle missing Firebase gracefully\n\n---\n\n### Task 13: Show rundown status indicator\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd status indicator showing rundown state (idle, loaded, modified).\n\n**Checklist:**\n- [ ] Add status badge component\n- [ ] Show \"No Rundown\" when state is IDLE\n- [ ] Show \"Rundown Loaded\" when state is LOADED\n- [ ] Show segment count in badge\n\n---\n\n### Task 14: Verify scene picker uses OBS state\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n\n**Checklist:**\n- [ ] Check current implementation of scene picker\n- [ ] If hardcoded, plan integration with OBS scene list\n- [ ] Document current state\n\n---\n\n### Task 15: Verify graphics picker uses Registry\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the graphics picker dropdown uses graphicsRegistry.js.\n\n**Checklist:**\n- [ ] Check current implementation of graphics picker\n- [ ] Verify graphicsRegistry.js is imported and used\n- [ ] Confirm graphics filtered by competition type\n\n---\n\n### Task 16: Fix hardcoded picker data\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nReplace any hardcoded picker data with live data sources.\n\n**Checklist:**\n- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n- [ ] Verify graphics come from registry\n- [ ] Test with actual competition data\n\n---\n\n## Bugs & Issues\n\n| Bug ID | Description | Status | Task |\n|--------|-------------|--------|------|\n\n---\n\n## Notes\n\n### Dependencies\n- **Phase A** is the prerequisite for all other phases\n- **Phase H** and **Phase B** can run in parallel after Phase A\n- **Phase I-G** depend on Phase A completion\n\n### Architecture Considerations\n- Multi-competition support requires Map-based engine instances\n- Socket.io rooms isolate competition events\n- Firebase Admin must be passed to engine (not just client SDK)\n- OBS connections managed by existing obsConnectionManager\n\n### Critical Gap Identified\nCurrent `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n\n### Key Files Reference\nSee [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n\n---\n\n## Completion Criteria\n\n**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n\n**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n\n**Full System:** All phases complete.\n","structuredPatch":[{"oldStart":68,"oldLines":7,"newStart":68,"newLines":7,"lines":[" "," | Task | Description | Status | Notes |"," |------|-------------|--------|-------|","-| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | NOT STARTED | |","+| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |"," | Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |"," | Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |"," | Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HmZHXAp14fN1xcmxNFFBRr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UGw8cAyvqUM4nnLBoQ5YeB","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","old_string":"### Task 1: Update TimesheetEngine constructor\n\n**Status:** NOT STARTED","new_string":"### Task 1: Update TimesheetEngine constructor\n\n**Status:** COMPLETE (Commit 9d0267c)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":299,"cache_read_input_tokens":66709,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":171,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"e0367d29-7cc4-4814-9129-a651aaa78768"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UGw8cAyvqUM4nnLBoQ5YeB","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"c079ab34-16fd-4ccb-942a-745d3c673f1a","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","oldString":"### Task 1: Update TimesheetEngine constructor\n\n**Status:** NOT STARTED","newString":"### Task 1: Update TimesheetEngine constructor\n\n**Status:** COMPLETE (Commit 9d0267c)","originalFile":"# PLAN-Rundown-System-Implementation\n\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n**Status:** NOT STARTED\n**Created:** 2026-01-23\n**Last Updated:** 2026-01-23\n\n---\n\n## Overview\n\nThis implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n\n---\n\n## IMPORTANT: Task Execution Rules\n\n**ONE TASK = ONE ITERATION**\n\nEach row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n\n1. Pick the first NOT STARTED or IN PROGRESS task\n2. Implement that ONE task\n3. Commit, deploy, verify\n4. STOP - the next iteration will handle the next task\n\n**Do NOT:**\n- Complete multiple tasks in one iteration\n- Batch \"related\" tasks together\n- Complete an entire phase in one iteration\n\n**Task Numbering:**\n- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n- Each task number is unique and independent\n- Example: \"Task 8\" is ONE task, not a subtask\n\n---\n\n## Phase Summary\n\n| Phase | Name | Priority | Status | Tasks |\n|-------|------|----------|--------|-------|\n| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n| B | Talent View | P1 | NOT STARTED | 22-27 |\n| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n\n---\n\n## Task Summary by Phase\n\n### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |\n| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |\n| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n\n### Phase H: Rehearsal Mode (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n\n### Phase B: Talent View (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n| Task 24 | Scene switching buttons | NOT STARTED | |\n| Task 25 | Next segment preview | NOT STARTED | |\n| Task 26 | Notes display | NOT STARTED | |\n| Task 27 | Add `/talent` route | NOT STARTED | |\n\n### Phase I: Live Rundown Sync (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n| Task 35 | Handle deleted current segment | NOT STARTED | |\n| Task 36 | Handle reordered past segments | NOT STARTED | |\n| Task 37 | Handle ID conflicts | NOT STARTED | |\n\n### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 38 | Log actual segment durations during show | NOT STARTED | |\n| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n\n### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n\n### Phase E: Script & Talent Flow (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 49 | Add script field to segment data model | NOT STARTED | |\n| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n| Task 53 | Create talent schedule view | NOT STARTED | |\n| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n\n### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 55 | Create AIContextService stub | NOT STARTED | |\n| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n| Task 59 | Generate talking points in real-time | NOT STARTED | |\n| Task 60 | Detect career highs, records during show | NOT STARTED | |\n| Task 61 | Display AI context in Talent View | NOT STARTED | |\n| Task 62 | Display AI context in Producer View | NOT STARTED | |\n\n### Phase F: Audio Cue Integration (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n| Task 66 | Add audio control to Producer View | NOT STARTED | |\n\n### Phase G: Production Tracking (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n| Task 68 | Generate equipment schedule report | NOT STARTED | |\n| Task 69 | Detect equipment conflicts | NOT STARTED | |\n| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n\n---\n\n## Detailed Tasks - Phase A (P0)\n\n### Task 1: Update TimesheetEngine constructor\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n\n**Checklist:**\n- [ ] Add `compId` parameter to constructor\n- [ ] Add `obsConnectionManager` parameter to constructor\n- [ ] Store both as instance properties\n- [ ] Remove dependency on global `obs` singleton\n\n---\n\n### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic\n\n---\n\n### Task 3: Update _applyTransitionAndSwitchScene()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the scene switching method to use per-competition OBS connection via obsConnectionManager.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n- [ ] Add error handling for disconnected state\n\n---\n\n### Task 4: Update _playVideo()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the video playback method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 5: Update _applyAudioOverrides()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the audio override method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 6: Update socket event broadcasts\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate all socket.io event emissions to target the competition-specific room.\n\n**Checklist:**\n- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n- [ ] Verify room naming matches existing convention\n\n---\n\n### Task 7: Pass Firebase Admin to engine\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n\n**Description:**\nPass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n\n**Checklist:**\n- [ ] Add `firebase` parameter to constructor\n- [ ] Export `db` from productionConfigService.js\n- [ ] Pass Firebase instance when creating engine\n- [ ] Update `_triggerGraphic()` to use `this.firebase`\n\n---\n\n### Task 8: Add loadRundown socket handler\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nAdd socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n\n**Checklist:**\n- [ ] Add `socket.on('loadRundown', ...)` handler\n- [ ] Extract `compId` from payload\n- [ ] Call `getOrCreateEngine()` to get engine instance\n- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n- [ ] Call engine's load method with segments\n- [ ] Emit `timesheetState` with loaded segments\n\n---\n\n### Task 9: Add loadRundown action in ShowContext\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/context/ShowContext.jsx`\n\n**Description:**\nAdd `loadRundown` action to emit the socket event from client.\n\n**Checklist:**\n- [ ] Add `loadRundown` function that emits `loadRundown` event\n- [ ] Pass `compId` from context\n- [ ] Export function from context\n\n---\n\n### Task 10: Add \"Load Rundown\" button\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd \"Load Rundown\" button in Producer View header/toolbar.\n\n**Checklist:**\n- [ ] Add \"Load Rundown\" button to Producer View\n- [ ] Wire button to `loadRundown` action from ShowContext\n- [ ] Show loading state while loading\n- [ ] Show toast on success/failure\n\n---\n\n### Task 11: Create segment mapper\n\n**Status:** NOT STARTED\n**File:** `server/lib/segmentMapper.js` (new file)\n\n**Description:**\nCreate utility to map Rundown Editor segment format to Timesheet Engine format.\n\n**Checklist:**\n- [ ] Create `server/lib/segmentMapper.js`\n- [ ] Map `scene` → `obsScene`\n- [ ] Map `graphic.graphicId` → `graphic`\n- [ ] Map `graphic.params` → `graphicData`\n- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n- [ ] Preserve all other fields\n\n---\n\n### Task 12: Verify Firebase passed to engine\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nVerify Firebase Admin is correctly passed and usable in engine.\n\n**Checklist:**\n- [ ] Add logging to confirm Firebase instance received\n- [ ] Test that `_triggerGraphic()` can write to Firebase\n- [ ] Handle missing Firebase gracefully\n\n---\n\n### Task 13: Show rundown status indicator\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd status indicator showing rundown state (idle, loaded, modified).\n\n**Checklist:**\n- [ ] Add status badge component\n- [ ] Show \"No Rundown\" when state is IDLE\n- [ ] Show \"Rundown Loaded\" when state is LOADED\n- [ ] Show segment count in badge\n\n---\n\n### Task 14: Verify scene picker uses OBS state\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n\n**Checklist:**\n- [ ] Check current implementation of scene picker\n- [ ] If hardcoded, plan integration with OBS scene list\n- [ ] Document current state\n\n---\n\n### Task 15: Verify graphics picker uses Registry\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the graphics picker dropdown uses graphicsRegistry.js.\n\n**Checklist:**\n- [ ] Check current implementation of graphics picker\n- [ ] Verify graphicsRegistry.js is imported and used\n- [ ] Confirm graphics filtered by competition type\n\n---\n\n### Task 16: Fix hardcoded picker data\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nReplace any hardcoded picker data with live data sources.\n\n**Checklist:**\n- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n- [ ] Verify graphics come from registry\n- [ ] Test with actual competition data\n\n---\n\n## Bugs & Issues\n\n| Bug ID | Description | Status | Task |\n|--------|-------------|--------|------|\n\n---\n\n## Notes\n\n### Dependencies\n- **Phase A** is the prerequisite for all other phases\n- **Phase H** and **Phase B** can run in parallel after Phase A\n- **Phase I-G** depend on Phase A completion\n\n### Architecture Considerations\n- Multi-competition support requires Map-based engine instances\n- Socket.io rooms isolate competition events\n- Firebase Admin must be passed to engine (not just client SDK)\n- OBS connections managed by existing obsConnectionManager\n\n### Critical Gap Identified\nCurrent `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n\n### Key Files Reference\nSee [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n\n---\n\n## Completion Criteria\n\n**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n\n**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n\n**Full System:** All phases complete.\n","structuredPatch":[{"oldStart":191,"oldLines":7,"newStart":191,"newLines":7,"lines":[" "," ### Task 1: Update TimesheetEngine constructor"," ","-**Status:** NOT STARTED","+**Status:** COMPLETE (Commit 9d0267c)"," **File:** `server/lib/timesheetEngine.js`"," "," **Description:**"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CjwiR1gkacjcuoTSqspizk","type":"message","role":"assistant","content":[{"type":"text","text":"Now the FIRST NOT STARTED task is **Task 2: Create `timesheetEngines` Map in server/index.js**. Let me update my selection:\n\n---\n\n## Updated Phase 2: Select ONE Task\n\n```\n2.2 ONE Task Selected\n- Task ID: Task 2\n- Task name: Create `timesheetEngines` Map in server/index.js\n- This is ONE task, not multiple: yes\n- Files to modify: server/index.js\n```\n\n---\n\n## Phase 3: Implement ONE TASK ONLY\n\nLet me read the server/index.js file to understand the current implementation:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":332,"cache_read_input_tokens":67008,"cache_creation":{"ephemeral_5m_input_tokens":332,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"e09414aa-f2d2-44c0-9214-474a9b3ad362"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CjwiR1gkacjcuoTSqspizk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AEuH15mMGfw1RvWuyFQDRA","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":332,"cache_read_input_tokens":67008,"cache_creation":{"ephemeral_5m_input_tokens":332,"ephemeral_1h_input_tokens":0},"output_tokens":217,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"545bc244-ae1e-4a9d-9ba1-9d875629eefd"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (58504 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01AEuH15mMGfw1RvWuyFQDRA"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"5c73b042-ca68-478f-bc3c-caad4f41c0c3","tool_use_result":"Error: File content (58504 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WwJY9bYphkmLA19ZTNp39Q","type":"message","role":"assistant","content":[{"type":"text","text":"The file is large. Let me search for the specific sections related to timesheetEngine:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":280,"cache_read_input_tokens":67340,"cache_creation":{"ephemeral_5m_input_tokens":280,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"529c2b4e-280f-46d7-9232-0093a2644b0c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01WwJY9bYphkmLA19ZTNp39Q","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XwxpqFJeHP5FDXxVoGBncZ","name":"Grep","input":{"pattern":"timesheetEngine","path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":280,"cache_read_input_tokens":67340,"cache_creation":{"ephemeral_5m_input_tokens":280,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"3ed68261-7777-4b0c-800f-d91900511d3b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XwxpqFJeHP5FDXxVoGBncZ","type":"tool_result","content":"17:import { TimesheetEngine } from './lib/timesheetEngine.js';\n118:let timesheetEngine = null;\n251:  timesheetEngine = new TimesheetEngine({\n258:  timesheetEngine.on('tick', (data) => {\n262:  timesheetEngine.on('segmentActivated', (data) => {\n265:    io.emit('timesheetState', timesheetEngine.getState());\n268:  timesheetEngine.on('segmentCompleted', (data) => {\n273:  timesheetEngine.on('showStarted', (data) => {\n276:    io.emit('timesheetState', timesheetEngine.getState());\n279:  timesheetEngine.on('showStopped', (data) => {\n282:    io.emit('timesheetState', timesheetEngine.getState());\n285:  timesheetEngine.on('stateChanged', (data) => {\n287:    io.emit('timesheetState', timesheetEngine.getState());\n290:  timesheetEngine.on('holdStarted', (data) => {\n295:  timesheetEngine.on('holdMaxReached', (data) => {\n300:  timesheetEngine.on('autoAdvancing', (data) => {\n305:  timesheetEngine.on('overrideRecorded', (data) => {\n310:  timesheetEngine.on('sceneChanged', (data) => {\n314:  timesheetEngine.on('sceneOverridden', (data) => {\n319:  timesheetEngine.on('cameraOverridden', (data) => {\n324:  timesheetEngine.on('graphicTriggered', (data) => {\n328:  timesheetEngine.on('videoStarted', (data) => {\n332:  timesheetEngine.on('breakStarted', (data) => {\n337:  timesheetEngine.on('error', (data) => {\n505:    if (timesheetEngine) {\n506:      timesheetEngine.stop();\n560:  if (timesheetEngine) {\n561:    timesheetEngine.updateConfig(showConfig);\n1717:  if (!timesheetEngine) {\n1720:  res.json(timesheetEngine.getState());\n1725:  if (!timesheetEngine) {\n1728:  res.json(timesheetEngine.getOverrides());\n1733:  if (!timesheetEngine) {\n1736:  res.json(timesheetEngine.getHistory());\n1741:  if (!timesheetEngine) {\n1745:    await timesheetEngine.start();\n1746:    res.json({ success: true, state: timesheetEngine.getState() });\n1754:  if (!timesheetEngine) {\n1757:  timesheetEngine.stop();\n1758:  res.json({ success: true, state: timesheetEngine.getState() });\n1763:  if (!timesheetEngine) {\n1767:  const success = await timesheetEngine.advance(advancedBy || 'api');\n1769:    return res.status(400).json({ error: 'Cannot advance segment', state: timesheetEngine.getState() });\n1771:  res.json({ success: true, state: timesheetEngine.getState() });\n1776:  if (!timesheetEngine) {\n1780:  const success = await timesheetEngine.previous(triggeredBy || 'api');\n1782:    return res.status(400).json({ error: 'Cannot go to previous segment', state: timesheetEngine.getState() });\n1784:  res.json({ success: true, state: timesheetEngine.getState() });\n1789:  if (!timesheetEngine) {\n1796:  const success = await timesheetEngine.goToSegment(segmentId, triggeredBy || 'api');\n1798:    return res.status(400).json({ error: `Cannot jump to segment: ${segmentId}`, state: timesheetEngine.getState() });\n1800:  res.json({ success: true, state: timesheetEngine.getState() });\n2684:  if (timesheetEngine) {\n2685:    socket.emit('timesheetState', timesheetEngine.getState());\n5213:    if (!timesheetEngine) {\n5217:    await timesheetEngine.start();\n5223:    if (!timesheetEngine) {\n5227:    timesheetEngine.stop();\n5233:    if (!timesheetEngine) {\n5239:    const success = await timesheetEngine.advance(advancedBy);\n5248:    if (!timesheetEngine) {\n5254:    const success = await timesheetEngine.previous(triggeredBy);\n5263:    if (!timesheetEngine) {\n5273:    const success = await timesheetEngine.goToSegment(segmentId, triggeredBy);\n5282:    if (!timesheetEngine) {\n5292:    const success = await timesheetEngine.overrideScene(sceneName, triggeredBy);\n5301:    if (!timesheetEngine) {\n5311:    const success = await timesheetEngine.overrideCamera(cameraId, triggeredBy);\n5320:    if (!timesheetEngine) {\n5324:    socket.emit('timesheetState', timesheetEngine.getState());\n5329:    if (!timesheetEngine) {\n5333:    socket.emit('timesheetOverrides', timesheetEngine.getOverrides());\n5338:    if (!timesheetEngine) {\n5342:    socket.emit('timesheetHistory', timesheetEngine.getHistory());"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"ac823f3b-92a3-4477-923a-5c81ca98668a","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"17:import { TimesheetEngine } from './lib/timesheetEngine.js';\n118:let timesheetEngine = null;\n251:  timesheetEngine = new TimesheetEngine({\n258:  timesheetEngine.on('tick', (data) => {\n262:  timesheetEngine.on('segmentActivated', (data) => {\n265:    io.emit('timesheetState', timesheetEngine.getState());\n268:  timesheetEngine.on('segmentCompleted', (data) => {\n273:  timesheetEngine.on('showStarted', (data) => {\n276:    io.emit('timesheetState', timesheetEngine.getState());\n279:  timesheetEngine.on('showStopped', (data) => {\n282:    io.emit('timesheetState', timesheetEngine.getState());\n285:  timesheetEngine.on('stateChanged', (data) => {\n287:    io.emit('timesheetState', timesheetEngine.getState());\n290:  timesheetEngine.on('holdStarted', (data) => {\n295:  timesheetEngine.on('holdMaxReached', (data) => {\n300:  timesheetEngine.on('autoAdvancing', (data) => {\n305:  timesheetEngine.on('overrideRecorded', (data) => {\n310:  timesheetEngine.on('sceneChanged', (data) => {\n314:  timesheetEngine.on('sceneOverridden', (data) => {\n319:  timesheetEngine.on('cameraOverridden', (data) => {\n324:  timesheetEngine.on('graphicTriggered', (data) => {\n328:  timesheetEngine.on('videoStarted', (data) => {\n332:  timesheetEngine.on('breakStarted', (data) => {\n337:  timesheetEngine.on('error', (data) => {\n505:    if (timesheetEngine) {\n506:      timesheetEngine.stop();\n560:  if (timesheetEngine) {\n561:    timesheetEngine.updateConfig(showConfig);\n1717:  if (!timesheetEngine) {\n1720:  res.json(timesheetEngine.getState());\n1725:  if (!timesheetEngine) {\n1728:  res.json(timesheetEngine.getOverrides());\n1733:  if (!timesheetEngine) {\n1736:  res.json(timesheetEngine.getHistory());\n1741:  if (!timesheetEngine) {\n1745:    await timesheetEngine.start();\n1746:    res.json({ success: true, state: timesheetEngine.getState() });\n1754:  if (!timesheetEngine) {\n1757:  timesheetEngine.stop();\n1758:  res.json({ success: true, state: timesheetEngine.getState() });\n1763:  if (!timesheetEngine) {\n1767:  const success = await timesheetEngine.advance(advancedBy || 'api');\n1769:    return res.status(400).json({ error: 'Cannot advance segment', state: timesheetEngine.getState() });\n1771:  res.json({ success: true, state: timesheetEngine.getState() });\n1776:  if (!timesheetEngine) {\n1780:  const success = await timesheetEngine.previous(triggeredBy || 'api');\n1782:    return res.status(400).json({ error: 'Cannot go to previous segment', state: timesheetEngine.getState() });\n1784:  res.json({ success: true, state: timesheetEngine.getState() });\n1789:  if (!timesheetEngine) {\n1796:  const success = await timesheetEngine.goToSegment(segmentId, triggeredBy || 'api');\n1798:    return res.status(400).json({ error: `Cannot jump to segment: ${segmentId}`, state: timesheetEngine.getState() });\n1800:  res.json({ success: true, state: timesheetEngine.getState() });\n2684:  if (timesheetEngine) {\n2685:    socket.emit('timesheetState', timesheetEngine.getState());\n5213:    if (!timesheetEngine) {\n5217:    await timesheetEngine.start();\n5223:    if (!timesheetEngine) {\n5227:    timesheetEngine.stop();\n5233:    if (!timesheetEngine) {\n5239:    const success = await timesheetEngine.advance(advancedBy);\n5248:    if (!timesheetEngine) {\n5254:    const success = await timesheetEngine.previous(triggeredBy);\n5263:    if (!timesheetEngine) {\n5273:    const success = await timesheetEngine.goToSegment(segmentId, triggeredBy);\n5282:    if (!timesheetEngine) {\n5292:    const success = await timesheetEngine.overrideScene(sceneName, triggeredBy);\n5301:    if (!timesheetEngine) {\n5311:    const success = await timesheetEngine.overrideCamera(cameraId, triggeredBy);\n5320:    if (!timesheetEngine) {\n5324:    socket.emit('timesheetState', timesheetEngine.getState());\n5329:    if (!timesheetEngine) {\n5333:    socket.emit('timesheetOverrides', timesheetEngine.getOverrides());\n5338:    if (!timesheetEngine) {\n5342:    socket.emit('timesheetHistory', timesheetEngine.getHistory());","numLines":74}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018HqH1f8DRTydBFKC1ynEBQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WVUfz5GXe8QesF8DsGfsif","name":"TodoWrite","input":{"todos":[{"content":"Update Implementation Plan to mark Task 1 as COMPLETE","status":"completed","activeForm":"Updating Implementation Plan to mark Task 1 as COMPLETE"},{"content":"Implement Task 2: Create timesheetEngines Map in server/index.js","status":"in_progress","activeForm":"Implementing Task 2: Creating timesheetEngines Map in server/index.js"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1660,"cache_read_input_tokens":67620,"cache_creation":{"ephemeral_5m_input_tokens":1660,"ephemeral_1h_input_tokens":0},"output_tokens":142,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"3b8f819a-af8f-47e4-82d8-512ba6293138"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WVUfz5GXe8QesF8DsGfsif","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"a12b434b-57e0-4058-b999-b063471ae810","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Update Implementation Plan to mark Task 1 as COMPLETE","status":"completed","activeForm":"Updating Implementation Plan to mark Task 1 as COMPLETE"},{"content":"Implement Task 2: Create timesheetEngines Map in server/index.js","status":"in_progress","activeForm":"Implementing Task 2: Creating timesheetEngines Map in server/index.js"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011TGiyj7Uz8vHiXfnhzFfVu","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the relevant sections of the file to understand the current structure:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":195,"cache_read_input_tokens":69280,"cache_creation":{"ephemeral_5m_input_tokens":195,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"f358f6ec-13b1-42dd-9b64-c0edd693d756"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011TGiyj7Uz8vHiXfnhzFfVu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SYLTkjqmrtdEuK8UbM4S8E","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","offset":1,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":195,"cache_read_input_tokens":69280,"cache_creation":{"ephemeral_5m_input_tokens":195,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"ca654318-f6a7-4c7c-bf4b-5da251dc621e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SYLTkjqmrtdEuK8UbM4S8E","type":"tool_result","content":"     1→import express from 'express';\n     2→import { createServer } from 'http';\n     3→import { Server } from 'socket.io';\n     4→import OBSWebSocket from 'obs-websocket-js';\n     5→import cors from 'cors';\n     6→import { readFileSync, writeFileSync, watchFile } from 'fs';\n     7→import { fileURLToPath } from 'url';\n     8→import { dirname, join } from 'path';\n     9→import dotenv from 'dotenv';\n    10→import multer from 'multer';\n    11→import { parse } from 'csv-parse/sync';\n    12→import { validateShowConfig } from './lib/showConfigSchema.js';\n    13→import { CameraHealthMonitor } from './lib/cameraHealth.js';\n    14→import { CameraRuntimeState } from './lib/cameraRuntimeState.js';\n    15→import { CameraFallbackManager } from './lib/cameraFallback.js';\n    16→import { OBSSceneGenerator } from './lib/obsSceneGenerator.js';\n    17→import { TimesheetEngine } from './lib/timesheetEngine.js';\n    18→import { getApparatusForGender } from './lib/apparatusConfig.js';\n    19→import productionConfigService from './lib/productionConfigService.js';\n    20→import configLoader from './lib/configLoader.js';\n    21→import { getVMPoolManager, VM_STATUS } from './lib/vmPoolManager.js';\n    22→import { getAWSService } from './lib/awsService.js';\n    23→import { getAlertService, ALERT_LEVEL, ALERT_CATEGORY } from './lib/alertService.js';\n    24→import { getAutoShutdownService } from './lib/autoShutdown.js';\n    25→import { getSelfStopService } from './lib/selfStop.js';\n    26→import { getOBSStateSync } from './lib/obsStateSync.js';\n    27→import { setupOBSRoutes } from './routes/obs.js';\n    28→import { getOBSConnectionManager } from './lib/obsConnectionManager.js';\n    29→import { DEFAULT_PRESETS } from './lib/obsAudioManager.js';\n    30→import { encryptStreamKey, decryptStreamKey, isEncryptedKey } from './lib/obsStreamManager.js';\n    31→\n    32→dotenv.config();\n    33→\n    34→// ============================================\n    35→// Coordinator State Tracking\n    36→// ============================================\n    37→const serverStartTime = Date.now();\n    38→let lastActivityTimestamp = Date.now();\n    39→const SERVER_VERSION = '1.0.0';\n    40→\n    41→/**\n    42→ * Update last activity timestamp\n    43→ * Called on API requests and socket events\n    44→ */\n    45→function updateLastActivity() {\n    46→  lastActivityTimestamp = Date.now();\n    47→}\n    48→\n    49→/**\n    50→ * Get server uptime in seconds\n    51→ */\n    52→function getUptime() {\n    53→  return Math.floor((Date.now() - serverStartTime) / 1000);\n    54→}\n    55→\n    56→/**\n    57→ * Get idle time in seconds\n    58→ */\n    59→function getIdleTime() {\n    60→  return Math.floor((Date.now() - lastActivityTimestamp) / 1000);\n    61→}\n    62→\n    63→// Configure multer for file uploads\n    64→const upload = multer({ storage: multer.memoryStorage() });\n    65→\n    66→const __filename = fileURLToPath(import.meta.url);\n    67→const __dirname = dirname(__filename);\n    68→\n    69→const app = express();\n    70→const httpServer = createServer(app);\n    71→const io = new Server(httpServer, {\n    72→  cors: {\n    73→    origin: \"*\",\n    74→    methods: [\"GET\", \"POST\"]\n    75→  }\n    76→});\n    77→\n    78→const obs = new OBSWebSocket();\n    79→\n    80→// Configuration\n    81→const PORT = process.env.PORT || 3003;\n    82→const OBS_WEBSOCKET_URL = process.env.OBS_WEBSOCKET_URL || 'ws://localhost:4455';\n    83→const OBS_WEBSOCKET_PASSWORD = process.env.OBS_WEBSOCKET_PASSWORD || '';\n    84→\n    85→// Show State\n    86→let showState = {\n    87→  currentSegmentIndex: 0,\n    88→  currentSegment: null,\n    89→  nextSegment: null,\n    90→  isPlaying: false,\n    91→  isPaused: false,\n    92→  talentLocked: false,\n    93→  obsConnected: false,\n    94→  obsCurrentScene: null,\n    95→  obsIsStreaming: false,\n    96→  obsIsRecording: false,\n    97→  connectedClients: [],\n    98→  showProgress: {\n    99→    completed: 0,\n   100→    total: 0\n   101→  },\n   102→  segmentStartTime: null,\n   103→  segmentElapsed: 0\n   104→};\n   105→\n   106→// Show Configuration\n   107→let showConfig = null;\n   108→\n   109→// Camera Management Modules\n   110→let cameraHealthMonitor = null;\n   111→let cameraRuntimeState = null;\n   112→let cameraFallbackManager = null;\n   113→\n   114→// OBS Scene Generator\n   115→let obsSceneGenerator = null;\n   116→\n   117→// Timesheet Engine\n   118→let timesheetEngine = null;\n   119→\n   120→// OBS State Sync\n   121→let obsStateSync = null;\n   122→\n   123→// Load show configuration\n   124→function loadShowConfig(exitOnInvalid = false) {\n   125→  try {\n   126→    const configPath = join(__dirname, 'config', 'show-config.json');\n   127→    const configData = readFileSync(configPath, 'utf-8');\n   128→    const parsedConfig = JSON.parse(configData);\n   129→\n   130→    // Validate the configuration against schema\n   131→    const validation = validateShowConfig(parsedConfig);\n   132→    if (!validation.valid) {\n   133→      console.error('Show config validation failed:');\n   134→      validation.errors.forEach(err => console.error(`  - ${err}`));\n   135→      if (exitOnInvalid) {\n   136→        console.error('Exiting due to invalid configuration');\n   137→        process.exit(1);\n   138→      }\n   139→      return false;\n   140→    }\n   141→\n   142→    showConfig = parsedConfig;\n   143→    showState.showProgress.total = showConfig.segments.length;\n   144→    updateCurrentSegment();\n   145→    console.log(`Loaded show config: ${showConfig.showName} with ${showConfig.segments.length} segments (validated)`);\n   146→    return true;\n   147→  } catch (error) {\n   148→    console.error('Error loading show config:', error.message);\n   149→    if (exitOnInvalid) {\n   150→      process.exit(1);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"93e9768f-62ae-4555-919f-a766111f3055","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","content":"import express from 'express';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport OBSWebSocket from 'obs-websocket-js';\nimport cors from 'cors';\nimport { readFileSync, writeFileSync, watchFile } from 'fs';\nimport { fileURLToPath } from 'url';\nimport { dirname, join } from 'path';\nimport dotenv from 'dotenv';\nimport multer from 'multer';\nimport { parse } from 'csv-parse/sync';\nimport { validateShowConfig } from './lib/showConfigSchema.js';\nimport { CameraHealthMonitor } from './lib/cameraHealth.js';\nimport { CameraRuntimeState } from './lib/cameraRuntimeState.js';\nimport { CameraFallbackManager } from './lib/cameraFallback.js';\nimport { OBSSceneGenerator } from './lib/obsSceneGenerator.js';\nimport { TimesheetEngine } from './lib/timesheetEngine.js';\nimport { getApparatusForGender } from './lib/apparatusConfig.js';\nimport productionConfigService from './lib/productionConfigService.js';\nimport configLoader from './lib/configLoader.js';\nimport { getVMPoolManager, VM_STATUS } from './lib/vmPoolManager.js';\nimport { getAWSService } from './lib/awsService.js';\nimport { getAlertService, ALERT_LEVEL, ALERT_CATEGORY } from './lib/alertService.js';\nimport { getAutoShutdownService } from './lib/autoShutdown.js';\nimport { getSelfStopService } from './lib/selfStop.js';\nimport { getOBSStateSync } from './lib/obsStateSync.js';\nimport { setupOBSRoutes } from './routes/obs.js';\nimport { getOBSConnectionManager } from './lib/obsConnectionManager.js';\nimport { DEFAULT_PRESETS } from './lib/obsAudioManager.js';\nimport { encryptStreamKey, decryptStreamKey, isEncryptedKey } from './lib/obsStreamManager.js';\n\ndotenv.config();\n\n// ============================================\n// Coordinator State Tracking\n// ============================================\nconst serverStartTime = Date.now();\nlet lastActivityTimestamp = Date.now();\nconst SERVER_VERSION = '1.0.0';\n\n/**\n * Update last activity timestamp\n * Called on API requests and socket events\n */\nfunction updateLastActivity() {\n  lastActivityTimestamp = Date.now();\n}\n\n/**\n * Get server uptime in seconds\n */\nfunction getUptime() {\n  return Math.floor((Date.now() - serverStartTime) / 1000);\n}\n\n/**\n * Get idle time in seconds\n */\nfunction getIdleTime() {\n  return Math.floor((Date.now() - lastActivityTimestamp) / 1000);\n}\n\n// Configure multer for file uploads\nconst upload = multer({ storage: multer.memoryStorage() });\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst app = express();\nconst httpServer = createServer(app);\nconst io = new Server(httpServer, {\n  cors: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\nconst obs = new OBSWebSocket();\n\n// Configuration\nconst PORT = process.env.PORT || 3003;\nconst OBS_WEBSOCKET_URL = process.env.OBS_WEBSOCKET_URL || 'ws://localhost:4455';\nconst OBS_WEBSOCKET_PASSWORD = process.env.OBS_WEBSOCKET_PASSWORD || '';\n\n// Show State\nlet showState = {\n  currentSegmentIndex: 0,\n  currentSegment: null,\n  nextSegment: null,\n  isPlaying: false,\n  isPaused: false,\n  talentLocked: false,\n  obsConnected: false,\n  obsCurrentScene: null,\n  obsIsStreaming: false,\n  obsIsRecording: false,\n  connectedClients: [],\n  showProgress: {\n    completed: 0,\n    total: 0\n  },\n  segmentStartTime: null,\n  segmentElapsed: 0\n};\n\n// Show Configuration\nlet showConfig = null;\n\n// Camera Management Modules\nlet cameraHealthMonitor = null;\nlet cameraRuntimeState = null;\nlet cameraFallbackManager = null;\n\n// OBS Scene Generator\nlet obsSceneGenerator = null;\n\n// Timesheet Engine\nlet timesheetEngine = null;\n\n// OBS State Sync\nlet obsStateSync = null;\n\n// Load show configuration\nfunction loadShowConfig(exitOnInvalid = false) {\n  try {\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    const configData = readFileSync(configPath, 'utf-8');\n    const parsedConfig = JSON.parse(configData);\n\n    // Validate the configuration against schema\n    const validation = validateShowConfig(parsedConfig);\n    if (!validation.valid) {\n      console.error('Show config validation failed:');\n      validation.errors.forEach(err => console.error(`  - ${err}`));\n      if (exitOnInvalid) {\n        console.error('Exiting due to invalid configuration');\n        process.exit(1);\n      }\n      return false;\n    }\n\n    showConfig = parsedConfig;\n    showState.showProgress.total = showConfig.segments.length;\n    updateCurrentSegment();\n    console.log(`Loaded show config: ${showConfig.showName} with ${showConfig.segments.length} segments (validated)`);\n    return true;\n  } catch (error) {\n    console.error('Error loading show config:', error.message);\n    if (exitOnInvalid) {\n      process.exit(1);","numLines":150,"startLine":1,"totalLines":5653}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XpKGkXzPazgTpGRPK5iYps","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RGqixJqKyiE6s72dZH1ofE","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","offset":240,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2118,"cache_read_input_tokens":69475,"cache_creation":{"ephemeral_5m_input_tokens":2118,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"dd5eec67-3bc2-4952-bda7-f5b205c0724a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RGqixJqKyiE6s72dZH1ofE","type":"tool_result","content":"   240→  console.log(`Camera modules initialized with ${showConfig.cameras.length} cameras`);\n   241→}\n   242→\n   243→// Initialize OBS scene generator\n   244→function initializeSceneGenerator() {\n   245→  obsSceneGenerator = new OBSSceneGenerator(obs, showConfig);\n   246→  console.log('OBS scene generator initialized');\n   247→}\n   248→\n   249→// Initialize timesheet engine\n   250→function initializeTimesheetEngine() {\n   251→  timesheetEngine = new TimesheetEngine({\n   252→    showConfig,\n   253→    obs,\n   254→    io\n   255→  });\n   256→\n   257→  // Wire up timesheet events to broadcast to all clients\n   258→  timesheetEngine.on('tick', (data) => {\n   259→    io.emit('timesheetTick', data);\n   260→  });\n   261→\n   262→  timesheetEngine.on('segmentActivated', (data) => {\n   263→    console.log(`Timesheet: Segment activated - ${data.segment.name} (${data.reason})`);\n   264→    io.emit('timesheetSegmentActivated', data);\n   265→    io.emit('timesheetState', timesheetEngine.getState());\n   266→  });\n   267→\n   268→  timesheetEngine.on('segmentCompleted', (data) => {\n   269→    console.log(`Timesheet: Segment completed - ${data.segmentId} (${data.endReason})`);\n   270→    io.emit('timesheetSegmentCompleted', data);\n   271→  });\n   272→\n   273→  timesheetEngine.on('showStarted', (data) => {\n   274→    console.log('Timesheet: Show started');\n   275→    io.emit('timesheetShowStarted', data);\n   276→    io.emit('timesheetState', timesheetEngine.getState());\n   277→  });\n   278→\n   279→  timesheetEngine.on('showStopped', (data) => {\n   280→    console.log('Timesheet: Show stopped');\n   281→    io.emit('timesheetShowStopped', data);\n   282→    io.emit('timesheetState', timesheetEngine.getState());\n   283→  });\n   284→\n   285→  timesheetEngine.on('stateChanged', (data) => {\n   286→    io.emit('timesheetStateChanged', data);\n   287→    io.emit('timesheetState', timesheetEngine.getState());\n   288→  });\n   289→\n   290→  timesheetEngine.on('holdStarted', (data) => {\n   291→    console.log(`Timesheet: Hold started - ${data.segmentId}`);\n   292→    io.emit('timesheetHoldStarted', data);\n   293→  });\n   294→\n   295→  timesheetEngine.on('holdMaxReached', (data) => {\n   296→    console.log(`Timesheet: Hold max reached - ${data.segmentId}`);\n   297→    io.emit('timesheetHoldMaxReached', data);\n   298→  });\n   299→\n   300→  timesheetEngine.on('autoAdvancing', (data) => {\n   301→    console.log(`Timesheet: Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n   302→    io.emit('timesheetAutoAdvancing', data);\n   303→  });\n   304→\n   305→  timesheetEngine.on('overrideRecorded', (data) => {\n   306→    console.log(`Timesheet: Override recorded - ${data.type}`);\n   307→    io.emit('timesheetOverrideRecorded', data);\n   308→  });\n   309→\n   310→  timesheetEngine.on('sceneChanged', (data) => {\n   311→    io.emit('timesheetSceneChanged', data);\n   312→  });\n   313→\n   314→  timesheetEngine.on('sceneOverridden', (data) => {\n   315→    console.log(`Timesheet: Scene overridden to ${data.sceneName}`);\n   316→    io.emit('timesheetSceneOverridden', data);\n   317→  });\n   318→\n   319→  timesheetEngine.on('cameraOverridden', (data) => {\n   320→    console.log(`Timesheet: Camera overridden to ${data.cameraName}`);\n   321→    io.emit('timesheetCameraOverridden', data);\n   322→  });\n   323→\n   324→  timesheetEngine.on('graphicTriggered', (data) => {\n   325→    io.emit('timesheetGraphicTriggered', data);\n   326→  });\n   327→\n   328→  timesheetEngine.on('videoStarted', (data) => {\n   329→    io.emit('timesheetVideoStarted', data);\n   330→  });\n   331→\n   332→  timesheetEngine.on('breakStarted', (data) => {\n   333→    console.log(`Timesheet: Break started - ${data.segmentId}`);\n   334→    io.emit('timesheetBreakStarted', data);\n   335→  });\n   336→\n   337→  timesheetEngine.on('error', (data) => {\n   338→    console.error(`Timesheet error: ${data.message}`);\n   339→    io.emit('timesheetError', data);\n   340→  });\n   341→\n   342→  console.log('Timesheet engine initialized');\n   343→}\n   344→\n   345→// Initialize OBS State Sync\n   346→async function initializeOBSStateSync(competitionId) {\n   347→  if (!competitionId) {\n   348→    console.log('No competition ID provided, skipping OBS State Sync initialization');\n   349→    return;\n   350→  }\n   351→\n   352→  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n   353→\n   354→  // Get or create the singleton instance\n   355→  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n   356→\n   357→  // Initialize with competition ID\n   358→  await obsStateSync.initialize(competitionId);\n   359→\n   360→  // Wire up state change event to broadcast\n   361→  obsStateSync.on('broadcast', ({ event, data }) => {\n   362→    // State changes are already broadcast by obsStateSync\n   363→    // This listener is here for logging or additional handling if needed\n   364→  });\n   365→\n   366→  // Sync legacy showState.obsCurrentScene from new system\n   367→  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n   368→    showState.obsCurrentScene = sceneName;\n   369→  });\n   370→\n   371→  console.log('OBS State Sync initialized and ready');\n   372→}\n   373→\n   374→// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\n   375→function initializeVMPoolManager() {\n   376→  const vmPoolManager = getVMPoolManager();\n   377→\n   378→  // Wire up VM pool events to broadcast to all clients\n   379→  vmPoolManager.on('poolUpdated', (data) => {\n   380→    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n   381→    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n   382→  });\n   383→\n   384→  vmPoolManager.on('vmAssigned', (data) => {\n   385→    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n   386→    io.emit('vmAssigned', data);\n   387→    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n   388→  });\n   389→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"09b1266c-305c-45f7-a2cf-1336764bd799","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","content":"  console.log(`Camera modules initialized with ${showConfig.cameras.length} cameras`);\n}\n\n// Initialize OBS scene generator\nfunction initializeSceneGenerator() {\n  obsSceneGenerator = new OBSSceneGenerator(obs, showConfig);\n  console.log('OBS scene generator initialized');\n}\n\n// Initialize timesheet engine\nfunction initializeTimesheetEngine() {\n  timesheetEngine = new TimesheetEngine({\n    showConfig,\n    obs,\n    io\n  });\n\n  // Wire up timesheet events to broadcast to all clients\n  timesheetEngine.on('tick', (data) => {\n    io.emit('timesheetTick', data);\n  });\n\n  timesheetEngine.on('segmentActivated', (data) => {\n    console.log(`Timesheet: Segment activated - ${data.segment.name} (${data.reason})`);\n    io.emit('timesheetSegmentActivated', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('segmentCompleted', (data) => {\n    console.log(`Timesheet: Segment completed - ${data.segmentId} (${data.endReason})`);\n    io.emit('timesheetSegmentCompleted', data);\n  });\n\n  timesheetEngine.on('showStarted', (data) => {\n    console.log('Timesheet: Show started');\n    io.emit('timesheetShowStarted', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('showStopped', (data) => {\n    console.log('Timesheet: Show stopped');\n    io.emit('timesheetShowStopped', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('stateChanged', (data) => {\n    io.emit('timesheetStateChanged', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('holdStarted', (data) => {\n    console.log(`Timesheet: Hold started - ${data.segmentId}`);\n    io.emit('timesheetHoldStarted', data);\n  });\n\n  timesheetEngine.on('holdMaxReached', (data) => {\n    console.log(`Timesheet: Hold max reached - ${data.segmentId}`);\n    io.emit('timesheetHoldMaxReached', data);\n  });\n\n  timesheetEngine.on('autoAdvancing', (data) => {\n    console.log(`Timesheet: Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n    io.emit('timesheetAutoAdvancing', data);\n  });\n\n  timesheetEngine.on('overrideRecorded', (data) => {\n    console.log(`Timesheet: Override recorded - ${data.type}`);\n    io.emit('timesheetOverrideRecorded', data);\n  });\n\n  timesheetEngine.on('sceneChanged', (data) => {\n    io.emit('timesheetSceneChanged', data);\n  });\n\n  timesheetEngine.on('sceneOverridden', (data) => {\n    console.log(`Timesheet: Scene overridden to ${data.sceneName}`);\n    io.emit('timesheetSceneOverridden', data);\n  });\n\n  timesheetEngine.on('cameraOverridden', (data) => {\n    console.log(`Timesheet: Camera overridden to ${data.cameraName}`);\n    io.emit('timesheetCameraOverridden', data);\n  });\n\n  timesheetEngine.on('graphicTriggered', (data) => {\n    io.emit('timesheetGraphicTriggered', data);\n  });\n\n  timesheetEngine.on('videoStarted', (data) => {\n    io.emit('timesheetVideoStarted', data);\n  });\n\n  timesheetEngine.on('breakStarted', (data) => {\n    console.log(`Timesheet: Break started - ${data.segmentId}`);\n    io.emit('timesheetBreakStarted', data);\n  });\n\n  timesheetEngine.on('error', (data) => {\n    console.error(`Timesheet error: ${data.message}`);\n    io.emit('timesheetError', data);\n  });\n\n  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync\nasync function initializeOBSStateSync(competitionId) {\n  if (!competitionId) {\n    console.log('No competition ID provided, skipping OBS State Sync initialization');\n    return;\n  }\n\n  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n\n  // Get or create the singleton instance\n  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n\n  // Initialize with competition ID\n  await obsStateSync.initialize(competitionId);\n\n  // Wire up state change event to broadcast\n  obsStateSync.on('broadcast', ({ event, data }) => {\n    // State changes are already broadcast by obsStateSync\n    // This listener is here for logging or additional handling if needed\n  });\n\n  // Sync legacy showState.obsCurrentScene from new system\n  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n    showState.obsCurrentScene = sceneName;\n  });\n\n  console.log('OBS State Sync initialized and ready');\n}\n\n// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\nfunction initializeVMPoolManager() {\n  const vmPoolManager = getVMPoolManager();\n\n  // Wire up VM pool events to broadcast to all clients\n  vmPoolManager.on('poolUpdated', (data) => {\n    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmAssigned', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n    io.emit('vmAssigned', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n","numLines":150,"startLine":240,"totalLines":5653}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Mwe2FCHb3dYWCkyaMdqzBA","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the current state. The current `initializeTimesheetEngine()` function:\n1. Creates a single global `timesheetEngine` instance\n2. Uses the legacy `obs` singleton instead of `obsConnectionManager`\n3. Doesn't use `compId` for multi-competition support\n4. Broadcasts events globally to all clients with `io.emit()` instead of to competition-specific rooms\n\nFor Task 2, I need to:\n1. Replace `let timesheetEngine = null;` with `const timesheetEngines = new Map();`\n2. Create a `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n3. Update the existing initialization logic\n\nLet me make the changes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2244,"cache_read_input_tokens":71593,"cache_creation":{"ephemeral_5m_input_tokens":2244,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"8762fe23-eaed-4a1b-9ede-5e6204e5d984"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Mwe2FCHb3dYWCkyaMdqzBA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019kSQtoS4f6SDSqHifh8Hg3","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","old_string":"// Timesheet Engine\nlet timesheetEngine = null;","new_string":"// Timesheet Engines (per-competition Map for multi-competition support)\nconst timesheetEngines = new Map();\n// Legacy single-engine reference (for backward compatibility during transition)\nlet timesheetEngine = null;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":2244,"cache_read_input_tokens":71593,"cache_creation":{"ephemeral_5m_input_tokens":2244,"ephemeral_1h_input_tokens":0},"output_tokens":340,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"13e78d55-839f-4dcc-b2f4-de21f4f3619a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019kSQtoS4f6SDSqHifh8Hg3","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/server/index.js has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"52873666-f281-4cfa-9e56-600948473c82","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","oldString":"// Timesheet Engine\nlet timesheetEngine = null;","newString":"// Timesheet Engines (per-competition Map for multi-competition support)\nconst timesheetEngines = new Map();\n// Legacy single-engine reference (for backward compatibility during transition)\nlet timesheetEngine = null;","originalFile":"import express from 'express';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport OBSWebSocket from 'obs-websocket-js';\nimport cors from 'cors';\nimport { readFileSync, writeFileSync, watchFile } from 'fs';\nimport { fileURLToPath } from 'url';\nimport { dirname, join } from 'path';\nimport dotenv from 'dotenv';\nimport multer from 'multer';\nimport { parse } from 'csv-parse/sync';\nimport { validateShowConfig } from './lib/showConfigSchema.js';\nimport { CameraHealthMonitor } from './lib/cameraHealth.js';\nimport { CameraRuntimeState } from './lib/cameraRuntimeState.js';\nimport { CameraFallbackManager } from './lib/cameraFallback.js';\nimport { OBSSceneGenerator } from './lib/obsSceneGenerator.js';\nimport { TimesheetEngine } from './lib/timesheetEngine.js';\nimport { getApparatusForGender } from './lib/apparatusConfig.js';\nimport productionConfigService from './lib/productionConfigService.js';\nimport configLoader from './lib/configLoader.js';\nimport { getVMPoolManager, VM_STATUS } from './lib/vmPoolManager.js';\nimport { getAWSService } from './lib/awsService.js';\nimport { getAlertService, ALERT_LEVEL, ALERT_CATEGORY } from './lib/alertService.js';\nimport { getAutoShutdownService } from './lib/autoShutdown.js';\nimport { getSelfStopService } from './lib/selfStop.js';\nimport { getOBSStateSync } from './lib/obsStateSync.js';\nimport { setupOBSRoutes } from './routes/obs.js';\nimport { getOBSConnectionManager } from './lib/obsConnectionManager.js';\nimport { DEFAULT_PRESETS } from './lib/obsAudioManager.js';\nimport { encryptStreamKey, decryptStreamKey, isEncryptedKey } from './lib/obsStreamManager.js';\n\ndotenv.config();\n\n// ============================================\n// Coordinator State Tracking\n// ============================================\nconst serverStartTime = Date.now();\nlet lastActivityTimestamp = Date.now();\nconst SERVER_VERSION = '1.0.0';\n\n/**\n * Update last activity timestamp\n * Called on API requests and socket events\n */\nfunction updateLastActivity() {\n  lastActivityTimestamp = Date.now();\n}\n\n/**\n * Get server uptime in seconds\n */\nfunction getUptime() {\n  return Math.floor((Date.now() - serverStartTime) / 1000);\n}\n\n/**\n * Get idle time in seconds\n */\nfunction getIdleTime() {\n  return Math.floor((Date.now() - lastActivityTimestamp) / 1000);\n}\n\n// Configure multer for file uploads\nconst upload = multer({ storage: multer.memoryStorage() });\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst app = express();\nconst httpServer = createServer(app);\nconst io = new Server(httpServer, {\n  cors: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\nconst obs = new OBSWebSocket();\n\n// Configuration\nconst PORT = process.env.PORT || 3003;\nconst OBS_WEBSOCKET_URL = process.env.OBS_WEBSOCKET_URL || 'ws://localhost:4455';\nconst OBS_WEBSOCKET_PASSWORD = process.env.OBS_WEBSOCKET_PASSWORD || '';\n\n// Show State\nlet showState = {\n  currentSegmentIndex: 0,\n  currentSegment: null,\n  nextSegment: null,\n  isPlaying: false,\n  isPaused: false,\n  talentLocked: false,\n  obsConnected: false,\n  obsCurrentScene: null,\n  obsIsStreaming: false,\n  obsIsRecording: false,\n  connectedClients: [],\n  showProgress: {\n    completed: 0,\n    total: 0\n  },\n  segmentStartTime: null,\n  segmentElapsed: 0\n};\n\n// Show Configuration\nlet showConfig = null;\n\n// Camera Management Modules\nlet cameraHealthMonitor = null;\nlet cameraRuntimeState = null;\nlet cameraFallbackManager = null;\n\n// OBS Scene Generator\nlet obsSceneGenerator = null;\n\n// Timesheet Engine\nlet timesheetEngine = null;\n\n// OBS State Sync\nlet obsStateSync = null;\n\n// Load show configuration\nfunction loadShowConfig(exitOnInvalid = false) {\n  try {\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    const configData = readFileSync(configPath, 'utf-8');\n    const parsedConfig = JSON.parse(configData);\n\n    // Validate the configuration against schema\n    const validation = validateShowConfig(parsedConfig);\n    if (!validation.valid) {\n      console.error('Show config validation failed:');\n      validation.errors.forEach(err => console.error(`  - ${err}`));\n      if (exitOnInvalid) {\n        console.error('Exiting due to invalid configuration');\n        process.exit(1);\n      }\n      return false;\n    }\n\n    showConfig = parsedConfig;\n    showState.showProgress.total = showConfig.segments.length;\n    updateCurrentSegment();\n    console.log(`Loaded show config: ${showConfig.showName} with ${showConfig.segments.length} segments (validated)`);\n    return true;\n  } catch (error) {\n    console.error('Error loading show config:', error.message);\n    if (exitOnInvalid) {\n      process.exit(1);\n    }\n    return false;\n  }\n}\n\n// Initialize camera management modules\nfunction initializeCameraModules() {\n  if (!showConfig || !showConfig.cameras) {\n    console.log('No cameras configured, skipping camera module initialization');\n    return;\n  }\n\n  // Initialize health monitor\n  if (cameraHealthMonitor) {\n    cameraHealthMonitor.stop();\n  }\n  cameraHealthMonitor = new CameraHealthMonitor({\n    cameras: showConfig.cameras,\n    nimbleServer: showConfig.nimbleServer || {}\n  });\n\n  // Initialize runtime state\n  cameraRuntimeState = new CameraRuntimeState({\n    cameras: showConfig.cameras\n  });\n\n  // Initialize fallback manager\n  cameraFallbackManager = new CameraFallbackManager({\n    cameras: showConfig.cameras,\n    cameraHealthMonitor,\n    cameraRuntimeState,\n    switchScene\n  });\n\n  // Attach event handlers BEFORE starting (to catch initial poll errors)\n  // Broadcast camera health on each poll\n  cameraHealthMonitor.on('cameraHealth', (healthData) => {\n    io.emit('cameraHealth', healthData);\n  });\n\n  // Broadcast status changes to all clients\n  cameraHealthMonitor.on('cameraStatusChanged', (change) => {\n    console.log(`Camera ${change.cameraName} status: ${change.previousStatus} -> ${change.newStatus}`);\n    io.emit('cameraStatusChanged', change);\n  });\n\n  // Handle errors from health monitor (e.g., Nimble server not available)\n  cameraHealthMonitor.on('error', (error) => {\n    // Log but don't crash - Nimble server may not be running\n    console.warn(`Camera health monitor error: ${error.message}`);\n  });\n\n  // Broadcast runtime state changes to all clients\n  cameraRuntimeState.on('stateChanged', (state) => {\n    io.emit('cameraRuntimeState', state);\n  });\n\n  cameraRuntimeState.on('apparatusReassigned', (data) => {\n    io.emit('apparatusReassigned', data);\n  });\n\n  cameraRuntimeState.on('cameraVerified', (data) => {\n    io.emit('cameraVerified', data);\n  });\n\n  cameraRuntimeState.on('mismatchDetected', (data) => {\n    io.emit('mismatchDetected', data);\n  });\n\n  // Broadcast fallback events to all clients\n  cameraFallbackManager.on('fallbackActivated', (data) => {\n    io.emit('fallbackActivated', data);\n  });\n\n  cameraFallbackManager.on('fallbackCleared', (data) => {\n    io.emit('fallbackCleared', data);\n  });\n\n  cameraFallbackManager.on('fallbackUnavailable', (data) => {\n    io.emit('fallbackUnavailable', data);\n  });\n\n  cameraFallbackManager.on('fallbackChainExhausted', (data) => {\n    io.emit('fallbackChainExhausted', data);\n  });\n\n  // Start health monitoring (after event handlers are attached)\n  cameraHealthMonitor.start();\n\n  console.log(`Camera modules initialized with ${showConfig.cameras.length} cameras`);\n}\n\n// Initialize OBS scene generator\nfunction initializeSceneGenerator() {\n  obsSceneGenerator = new OBSSceneGenerator(obs, showConfig);\n  console.log('OBS scene generator initialized');\n}\n\n// Initialize timesheet engine\nfunction initializeTimesheetEngine() {\n  timesheetEngine = new TimesheetEngine({\n    showConfig,\n    obs,\n    io\n  });\n\n  // Wire up timesheet events to broadcast to all clients\n  timesheetEngine.on('tick', (data) => {\n    io.emit('timesheetTick', data);\n  });\n\n  timesheetEngine.on('segmentActivated', (data) => {\n    console.log(`Timesheet: Segment activated - ${data.segment.name} (${data.reason})`);\n    io.emit('timesheetSegmentActivated', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('segmentCompleted', (data) => {\n    console.log(`Timesheet: Segment completed - ${data.segmentId} (${data.endReason})`);\n    io.emit('timesheetSegmentCompleted', data);\n  });\n\n  timesheetEngine.on('showStarted', (data) => {\n    console.log('Timesheet: Show started');\n    io.emit('timesheetShowStarted', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('showStopped', (data) => {\n    console.log('Timesheet: Show stopped');\n    io.emit('timesheetShowStopped', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('stateChanged', (data) => {\n    io.emit('timesheetStateChanged', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('holdStarted', (data) => {\n    console.log(`Timesheet: Hold started - ${data.segmentId}`);\n    io.emit('timesheetHoldStarted', data);\n  });\n\n  timesheetEngine.on('holdMaxReached', (data) => {\n    console.log(`Timesheet: Hold max reached - ${data.segmentId}`);\n    io.emit('timesheetHoldMaxReached', data);\n  });\n\n  timesheetEngine.on('autoAdvancing', (data) => {\n    console.log(`Timesheet: Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n    io.emit('timesheetAutoAdvancing', data);\n  });\n\n  timesheetEngine.on('overrideRecorded', (data) => {\n    console.log(`Timesheet: Override recorded - ${data.type}`);\n    io.emit('timesheetOverrideRecorded', data);\n  });\n\n  timesheetEngine.on('sceneChanged', (data) => {\n    io.emit('timesheetSceneChanged', data);\n  });\n\n  timesheetEngine.on('sceneOverridden', (data) => {\n    console.log(`Timesheet: Scene overridden to ${data.sceneName}`);\n    io.emit('timesheetSceneOverridden', data);\n  });\n\n  timesheetEngine.on('cameraOverridden', (data) => {\n    console.log(`Timesheet: Camera overridden to ${data.cameraName}`);\n    io.emit('timesheetCameraOverridden', data);\n  });\n\n  timesheetEngine.on('graphicTriggered', (data) => {\n    io.emit('timesheetGraphicTriggered', data);\n  });\n\n  timesheetEngine.on('videoStarted', (data) => {\n    io.emit('timesheetVideoStarted', data);\n  });\n\n  timesheetEngine.on('breakStarted', (data) => {\n    console.log(`Timesheet: Break started - ${data.segmentId}`);\n    io.emit('timesheetBreakStarted', data);\n  });\n\n  timesheetEngine.on('error', (data) => {\n    console.error(`Timesheet error: ${data.message}`);\n    io.emit('timesheetError', data);\n  });\n\n  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync\nasync function initializeOBSStateSync(competitionId) {\n  if (!competitionId) {\n    console.log('No competition ID provided, skipping OBS State Sync initialization');\n    return;\n  }\n\n  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n\n  // Get or create the singleton instance\n  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n\n  // Initialize with competition ID\n  await obsStateSync.initialize(competitionId);\n\n  // Wire up state change event to broadcast\n  obsStateSync.on('broadcast', ({ event, data }) => {\n    // State changes are already broadcast by obsStateSync\n    // This listener is here for logging or additional handling if needed\n  });\n\n  // Sync legacy showState.obsCurrentScene from new system\n  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n    showState.obsCurrentScene = sceneName;\n  });\n\n  console.log('OBS State Sync initialized and ready');\n}\n\n// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\nfunction initializeVMPoolManager() {\n  const vmPoolManager = getVMPoolManager();\n\n  // Wire up VM pool events to broadcast to all clients\n  vmPoolManager.on('poolUpdated', (data) => {\n    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmAssigned', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n    io.emit('vmAssigned', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmReleased', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} released from competition ${data.competitionId}`);\n    io.emit('vmReleased', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStarting', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is starting`);\n    io.emit('vmStarting', {\n      ...data,\n      estimatedReadyTime: new Date(Date.now() + 180000).toISOString() // ~3 minutes\n    });\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmReady', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is ready at ${data.publicIp}`);\n    io.emit('vmReady', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStopping', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is stopping`);\n    io.emit('vmStopping', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStopped', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is stopped`);\n    io.emit('vmStopped', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmError', (data) => {\n    console.error(`[VMPool] VM ${data.vmId} error: ${data.error || data.reason}`);\n    io.emit('vmError', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmInUse', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is now in use for competition ${data.competitionId}`);\n    io.emit('vmInUse', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('configUpdated', (config) => {\n    console.log('[VMPool] Pool config updated');\n    io.emit('vmPoolConfigUpdated', config);\n  });\n\n  vmPoolManager.on('poolMaintenance', (data) => {\n    console.log(`[VMPool] Pool maintenance: started ${data.startedCount} VMs`);\n    io.emit('vmPoolMaintenance', data);\n  });\n\n  // Try to initialize the pool (non-blocking, will log errors)\n  vmPoolManager.initializePool().then(() => {\n    console.log('[VMPool] VM pool manager initialized and listening for events');\n    // Broadcast initial pool status\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  }).catch((error) => {\n    console.log(`[VMPool] VM pool not available: ${error.message}`);\n    console.log('[VMPool] VM pool features disabled - this is normal for local development');\n  });\n}\n\n// Initialize Auto-Shutdown Service (P19-02)\nasync function initializeAutoShutdown() {\n  const isCoordinatorMode = process.env.COORDINATOR_MODE === 'true';\n\n  if (!isCoordinatorMode) {\n    console.log('[AutoShutdown] Not in coordinator mode, skipping initialization');\n    return;\n  }\n\n  const autoShutdown = getAutoShutdownService();\n\n  // Wire up shutdown events to broadcast to all clients\n  autoShutdown.on('shutdownPending', (data) => {\n    console.log(`[AutoShutdown] Shutdown pending: ${data.reason} (${data.secondsRemaining}s)`);\n    io.emit('shutdownPending', data);\n  });\n\n  autoShutdown.on('shutdownCancelled', (data) => {\n    console.log(`[AutoShutdown] Shutdown cancelled: ${data.reason}`);\n    io.emit('shutdownCancelled', data);\n  });\n\n  autoShutdown.on('shutdownExecuting', (data) => {\n    console.log(`[AutoShutdown] Shutdown executing: ${data.reason}`);\n    io.emit('shutdownExecuting', data);\n  });\n\n  // Custom stop callback for graceful shutdown\n  const gracefulStopCallback = async () => {\n    console.log('[AutoShutdown] Graceful shutdown initiated');\n\n    // Notify all connected clients\n    io.emit('serverShuttingDown', {\n      timestamp: new Date().toISOString(),\n      message: 'Server shutting down due to idle timeout'\n    });\n\n    // Close all socket connections gracefully\n    const sockets = await io.fetchSockets();\n    for (const socket of sockets) {\n      socket.disconnect(true);\n    }\n\n    // Stop camera health polling\n    if (cameraHealthMonitor) {\n      cameraHealthMonitor.stop();\n    }\n\n    // Stop timesheet engine\n    if (timesheetEngine) {\n      timesheetEngine.stop();\n    }\n\n    console.log('[AutoShutdown] Graceful shutdown complete');\n  };\n\n  // Initialize with socket.io and AWS service\n  try {\n    const awsService = getAWSService();\n    await autoShutdown.initialize({\n      io,\n      awsService,\n      stopCallback: gracefulStopCallback\n    });\n    console.log('[AutoShutdown] Auto-shutdown service initialized');\n\n    // Initialize self-stop service and wire it to auto-shutdown\n    const selfStop = getSelfStopService();\n    await selfStop.initialize({ io });\n    console.log('[SelfStop] Self-stop service initialized');\n\n    // Wire auto-shutdown completion to EC2 self-stop\n    autoShutdown.on('shutdownComplete', async (data) => {\n      console.log('[SelfStop] Auto-shutdown complete, initiating EC2 self-stop');\n      const result = await selfStop.stopSelf({\n        reason: data.reason || 'Auto-shutdown idle timeout',\n        idleMinutes: data.idleMinutes || 0\n      });\n      console.log('[SelfStop] Self-stop result:', result);\n    });\n  } catch (error) {\n    console.warn('[AutoShutdown] Failed to initialize:', error.message);\n  }\n}\n\n// Watch for config changes (hot reload)\nwatchFile(join(__dirname, 'config', 'show-config.json'), () => {\n  console.log('Show config changed, reloading...');\n  loadShowConfig();\n  // Update camera modules with new config\n  if (cameraHealthMonitor) {\n    cameraHealthMonitor.updateConfig(showConfig);\n  }\n  if (cameraRuntimeState) {\n    cameraRuntimeState.updateConfig(showConfig);\n  }\n  if (cameraFallbackManager) {\n    cameraFallbackManager.updateConfig({ cameras: showConfig.cameras });\n  }\n  // Update scene generator with new config\n  if (obsSceneGenerator) {\n    obsSceneGenerator.updateConfig(showConfig);\n  }\n  // Update timesheet engine with new config\n  if (timesheetEngine) {\n    timesheetEngine.updateConfig(showConfig);\n  }\n  broadcastState();\n});\n\n// Update current segment based on index\nfunction updateCurrentSegment() {\n  if (!showConfig || !showConfig.segments) return;\n\n  showState.currentSegment = showConfig.segments[showState.currentSegmentIndex] || null;\n  showState.nextSegment = showConfig.segments[showState.currentSegmentIndex + 1] || null;\n  showState.showProgress.completed = showState.currentSegmentIndex;\n}\n\n// Broadcast state to all clients\nfunction broadcastState() {\n  io.emit('stateUpdate', {\n    ...showState,\n    showConfig: showConfig ? {\n      showName: showConfig.showName,\n      segments: showConfig.segments,\n      sponsors: showConfig.sponsors\n    } : null,\n    obsState: obsStateSync && obsStateSync.isInitialized() ? obsStateSync.getState() : null\n  });\n}\n\n// Connect to OBS\nlet obsReconnectTimer = null;\nlet obsConnecting = false;\n\nasync function connectToOBS() {\n  if (obsConnecting) return; // Prevent multiple simultaneous connection attempts\n  obsConnecting = true;\n\n  try {\n    await obs.connect(OBS_WEBSOCKET_URL, OBS_WEBSOCKET_PASSWORD || undefined);\n    showState.obsConnected = true;\n    obsConnecting = false;\n    console.log('Connected to OBS WebSocket');\n\n    // Get initial scene\n    const { currentProgramSceneName } = await obs.call('GetCurrentProgramScene');\n    showState.obsCurrentScene = currentProgramSceneName;\n\n    // Get streaming/recording status\n    try {\n      const streamStatus = await obs.call('GetStreamStatus');\n      showState.obsIsStreaming = streamStatus.outputActive;\n    } catch (e) {\n      // Streaming might not be available\n    }\n\n    try {\n      const recordStatus = await obs.call('GetRecordStatus');\n      showState.obsIsRecording = recordStatus.outputActive;\n    } catch (e) {\n      // Recording might not be available\n    }\n\n    broadcastState();\n  } catch (error) {\n    console.error('Failed to connect to OBS:', error.message);\n    showState.obsConnected = false;\n    obsConnecting = false;\n\n    // Retry connection after 30 seconds (longer delay to avoid spam)\n    if (obsReconnectTimer) clearTimeout(obsReconnectTimer);\n    obsReconnectTimer = setTimeout(connectToOBS, 30000);\n  }\n}\n\n// OBS Event Handlers\n// Note: CurrentProgramSceneChanged is now handled by obsStateSync (line ~3670)\n// Legacy showState.obsCurrentScene is synced via obsStateSync.on('currentSceneChanged')\n\nobs.on('StreamStateChanged', ({ outputActive }) => {\n  showState.obsIsStreaming = outputActive;\n  broadcastState();\n});\n\nobs.on('RecordStateChanged', ({ outputActive }) => {\n  showState.obsIsRecording = outputActive;\n  broadcastState();\n});\n\nobs.on('ConnectionClosed', () => {\n  console.log('OBS connection closed');\n  showState.obsConnected = false;\n  obsConnecting = false;\n  broadcastState();\n  // Attempt reconnect after 30 seconds\n  if (obsReconnectTimer) clearTimeout(obsReconnectTimer);\n  obsReconnectTimer = setTimeout(connectToOBS, 30000);\n});\n\n// Switch OBS scene\nasync function switchScene(sceneName) {\n  if (!showState.obsConnected) {\n    console.error('Cannot switch scene: OBS not connected');\n    return false;\n  }\n\n  try {\n    await obs.call('SetCurrentProgramScene', { sceneName });\n    console.log(`Switched to scene: ${sceneName}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to switch scene to ${sceneName}:`, error.message);\n    return false;\n  }\n}\n\n// Get available OBS scenes\nasync function getSceneList() {\n  if (!showState.obsConnected) return [];\n\n  try {\n    const { scenes } = await obs.call('GetSceneList');\n    return scenes.map(s => s.sceneName);\n  } catch (error) {\n    console.error('Failed to get scene list:', error.message);\n    return [];\n  }\n}\n\n// Default media source name in OBS (user should create this)\nconst VIDEO_SOURCE_NAME = process.env.OBS_VIDEO_SOURCE || 'Video Player';\n\n// Set video file for media source\nasync function setVideoFile(filePath, sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) {\n    console.error('Cannot set video: OBS not connected');\n    return false;\n  }\n\n  try {\n    // Get current settings first\n    const { inputSettings } = await obs.call('GetInputSettings', { inputName: sourceName });\n\n    // Update with new file path\n    await obs.call('SetInputSettings', {\n      inputName: sourceName,\n      inputSettings: {\n        ...inputSettings,\n        local_file: filePath,\n        is_local_file: true\n      }\n    });\n\n    // Restart the media source to play from beginning\n    await obs.call('TriggerMediaInputAction', {\n      inputName: sourceName,\n      mediaAction: 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n    });\n\n    console.log(`Set video file: ${filePath}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to set video file:`, error.message);\n    return false;\n  }\n}\n\n// Play/pause/stop media source\nasync function controlMedia(action, sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) return false;\n\n  const actionMap = {\n    'play': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PLAY',\n    'pause': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PAUSE',\n    'stop': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_STOP',\n    'restart': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n  };\n\n  try {\n    await obs.call('TriggerMediaInputAction', {\n      inputName: sourceName,\n      mediaAction: actionMap[action] || action\n    });\n    console.log(`Media action: ${action}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to control media:`, error.message);\n    return false;\n  }\n}\n\n// Get media source status (for progress tracking)\nasync function getMediaStatus(sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) return null;\n\n  try {\n    const status = await obs.call('GetMediaInputStatus', { inputName: sourceName });\n    return {\n      state: status.mediaState,\n      duration: status.mediaDuration,\n      cursor: status.mediaCursor // current position in ms\n    };\n  } catch (error) {\n    console.error(`Failed to get media status:`, error.message);\n    return null;\n  }\n}\n\n// Advance to next segment\nasync function advanceSegment(clientId = null) {\n  if (showState.talentLocked && clientId) {\n    const client = showState.connectedClients.find(c => c.id === clientId);\n    if (client && client.role === 'talent') {\n      console.log('Talent controls locked, ignoring advance request');\n      return false;\n    }\n  }\n\n  if (!showConfig || showState.currentSegmentIndex >= showConfig.segments.length - 1) {\n    console.log('Already at last segment');\n    return false;\n  }\n\n  showState.currentSegmentIndex++;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  // Switch OBS scene if specified\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  // Set video file if specified (for video segments)\n  if (showState.currentSegment?.videoFile) {\n    await setVideoFile(showState.currentSegment.videoFile);\n  }\n\n  // Trigger graphic if specified\n  if (showState.currentSegment?.graphic) {\n    io.emit('triggerGraphic', {\n      graphic: showState.currentSegment.graphic,\n      data: showState.currentSegment.graphicData || {}\n    });\n  }\n\n  // Set up auto-advance if applicable\n  if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n    setupAutoAdvance(showState.currentSegment.duration);\n  }\n\n  broadcastState();\n  console.log(`Advanced to segment ${showState.currentSegmentIndex}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Go to previous segment\nasync function previousSegment() {\n  if (!showConfig || showState.currentSegmentIndex <= 0) {\n    console.log('Already at first segment');\n    return false;\n  }\n\n  showState.currentSegmentIndex--;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  broadcastState();\n  console.log(`Went back to segment ${showState.currentSegmentIndex}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Jump to specific segment\nasync function jumpToSegment(segmentId) {\n  if (!showConfig) return false;\n\n  const index = showConfig.segments.findIndex(s => s.id === segmentId);\n  if (index === -1) {\n    console.error(`Segment not found: ${segmentId}`);\n    return false;\n  }\n\n  showState.currentSegmentIndex = index;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  // Set video file if specified\n  if (showState.currentSegment?.videoFile) {\n    await setVideoFile(showState.currentSegment.videoFile);\n  }\n\n  if (showState.currentSegment?.graphic) {\n    io.emit('triggerGraphic', {\n      graphic: showState.currentSegment.graphic,\n      data: showState.currentSegment.graphicData || {}\n    });\n  }\n\n  if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n    setupAutoAdvance(showState.currentSegment.duration);\n  }\n\n  broadcastState();\n  console.log(`Jumped to segment ${index}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Auto-advance timer\nlet autoAdvanceTimer = null;\n\nfunction setupAutoAdvance(durationSeconds) {\n  if (autoAdvanceTimer) {\n    clearTimeout(autoAdvanceTimer);\n  }\n\n  if (showState.isPaused) return;\n\n  autoAdvanceTimer = setTimeout(() => {\n    if (!showState.isPaused) {\n      console.log('Auto-advancing to next segment');\n      advanceSegment();\n    }\n  }, durationSeconds * 1000);\n}\n\nfunction clearAutoAdvance() {\n  if (autoAdvanceTimer) {\n    clearTimeout(autoAdvanceTimer);\n    autoAdvanceTimer = null;\n  }\n}\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.static(join(__dirname, '..', 'show-controller', 'dist')));\n// Serve graphics output files from project root (output.html, overlays/)\napp.use(express.static(join(__dirname, '..')));\n\n// Activity tracking middleware - updates last activity on every REST request\napp.use((req, res, next) => {\n  updateLastActivity();\n  // Also update auto-shutdown service if initialized\n  const autoShutdown = getAutoShutdownService();\n  if (autoShutdown.isInitialized()) {\n    autoShutdown.resetActivity();\n  }\n  next();\n});\n\n// REST API endpoints\napp.get('/api/status', (req, res) => {\n  res.json(showState);\n});\n\napp.get('/api/scenes', async (req, res) => {\n  const scenes = await getSceneList();\n  res.json(scenes);\n});\n\napp.get('/api/config', (req, res) => {\n  res.json(showConfig);\n});\n\n// Config validation endpoint\napp.get('/api/config/validate', (req, res) => {\n  if (!showConfig) {\n    return res.json({ valid: false, errors: ['No configuration loaded'] });\n  }\n  const validation = validateShowConfig(showConfig);\n  res.json(validation);\n});\n\n// Update cameras configuration\napp.put('/api/config/cameras', (req, res) => {\n  const { cameras } = req.body;\n  if (!cameras || !Array.isArray(cameras)) {\n    return res.status(400).json({ error: 'cameras must be an array' });\n  }\n\n  try {\n    // Update showConfig with new cameras\n    showConfig.cameras = cameras;\n\n    // Save to file\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    writeFileSync(configPath, JSON.stringify(showConfig, null, 2));\n\n    // Re-validate the config\n    const validation = validateShowConfig(showConfig);\n    if (!validation.valid) {\n      return res.status(400).json({\n        error: 'Invalid configuration',\n        errors: validation.errors\n      });\n    }\n\n    // Reinitialize camera modules with new config\n    initializeCameraModules();\n\n    // Update scene generator\n    if (obsSceneGenerator) {\n      obsSceneGenerator.updateConfig(showConfig);\n    }\n\n    console.log(`Camera config updated: ${cameras.length} cameras`);\n    res.json({ success: true, cameras: cameras.length });\n  } catch (error) {\n    console.error('Failed to save camera config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Apparatus API Endpoints\n// ============================================\n\n// GET /api/apparatus/:gender - Get apparatus for a specific gender\napp.get('/api/apparatus/:gender', (req, res) => {\n  const { gender } = req.params;\n\n  // Handle invalid gender gracefully (defaults to womens internally)\n  const apparatus = getApparatusForGender(gender);\n\n  // Determine normalized gender for response\n  const normalizedGender = (gender && (gender.toLowerCase() === 'mens' ||\n    gender.toLowerCase() === 'mag' ||\n    gender.toLowerCase() === 'male' ||\n    gender.toLowerCase() === 'm')) ? 'mens' : 'womens';\n\n  res.json({\n    gender: normalizedGender,\n    apparatus\n  });\n});\n\n// ============================================\n// Production Config API Endpoints\n// ============================================\n\n// GET /api/competitions/active - Get current active competition\napp.get('/api/competitions/active', (req, res) => {\n  const activeCompetitionId = configLoader.getActiveCompetition();\n  res.json({\n    activeCompetitionId,\n    isActive: !!activeCompetitionId\n  });\n});\n\n// POST /api/competitions/deactivate - Clear active competition\napp.post('/api/competitions/deactivate', (req, res) => {\n  configLoader.clearActiveCompetition();\n  res.json({\n    success: true,\n    message: 'Active competition cleared'\n  });\n});\n\n// GET /api/competitions/:id/production - Get full production config\napp.get('/api/competitions/:id/production', async (req, res) => {\n  const { id } = req.params;\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const productionConfig = await productionConfigService.getProductionConfig(id);\n    if (!productionConfig) {\n      return res.status(404).json({ error: 'Production config not found', competitionId: id });\n    }\n    res.json(productionConfig);\n  } catch (error) {\n    console.error(`Failed to get production config for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/cameras - Save cameras for a competition\napp.put('/api/competitions/:id/production/cameras', async (req, res) => {\n  const { id } = req.params;\n  const { cameras } = req.body;\n\n  if (!cameras || !Array.isArray(cameras)) {\n    return res.status(400).json({ error: 'cameras must be an array' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveCameras(id, cameras);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save cameras' });\n    }\n    res.json({ success: true, cameras: cameras.length, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save cameras for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/rundown - Save rundown for a competition\napp.put('/api/competitions/:id/production/rundown', async (req, res) => {\n  const { id } = req.params;\n  const rundown = req.body;\n\n  if (!rundown || typeof rundown !== 'object') {\n    return res.status(400).json({ error: 'rundown must be an object' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveRundown(id, rundown);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save rundown' });\n    }\n    res.json({ success: true, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save rundown for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/settings - Save settings for a competition\napp.put('/api/competitions/:id/production/settings', async (req, res) => {\n  const { id } = req.params;\n  const settings = req.body;\n\n  if (!settings || typeof settings !== 'object') {\n    return res.status(400).json({ error: 'settings must be an object' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveSettings(id, settings);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save settings' });\n    }\n    res.json({ success: true, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save settings for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/competitions/:id/production/history - Get history for a competition\napp.get('/api/competitions/:id/production/history', async (req, res) => {\n  const { id } = req.params;\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const history = await productionConfigService.getHistory(id);\n    res.json(history);\n  } catch (error) {\n    console.error(`Failed to get history for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/competitions/:id/activate - Set active competition\napp.post('/api/competitions/:id/activate', async (req, res) => {\n  const { id } = req.params;\n\n  configLoader.setActiveCompetition(id);\n\n  // Initialize OBS State Sync for this competition\n  try {\n    await initializeOBSStateSync(id);\n    console.log(`OBS State Sync initialized for competition: ${id}`);\n  } catch (error) {\n    console.error(`Failed to initialize OBS State Sync for ${id}:`, error);\n    // Don't fail the activation if OBS State Sync fails\n  }\n\n  res.json({\n    success: true,\n    activeCompetitionId: id,\n    message: `Competition ${id} activated`\n  });\n});\n\n// ============================================\n// VM Pool Management API Endpoints\n// ============================================\n\n// GET /api/admin/vm-pool - Get full pool status\napp.get('/api/admin/vm-pool', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.json({\n        initialized: false,\n        message: 'VM pool manager not initialized. Call initializePool() first.',\n        config: null,\n        counts: { total: 0, available: 0, assigned: 0, inUse: 0, stopped: 0, starting: 0, stopping: 0, error: 0 },\n        vms: []\n      });\n    }\n    res.json(vmPoolManager.getPoolStatus());\n  } catch (error) {\n    console.error('Failed to get VM pool status:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/admin/vm-pool/config - Get pool configuration\napp.get('/api/admin/vm-pool/config', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    const status = vmPoolManager.getPoolStatus();\n    const awsService = getAWSService();\n    const awsConfig = awsService.getConfig();\n\n    // Merge pool config with AWS config (AMI, region, instance type)\n    res.json({\n      ...status.config,\n      region: awsConfig.region,\n      amiId: awsConfig.amiId,\n      defaultInstanceType: awsConfig.defaultInstanceType,\n    });\n  } catch (error) {\n    console.error('Failed to get VM pool config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/admin/vm-pool/config - Update pool configuration\napp.put('/api/admin/vm-pool/config', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const config = req.body;\n    if (!config || typeof config !== 'object') {\n      return res.status(400).json({ error: 'config must be an object' });\n    }\n    const updatedConfig = await vmPoolManager.updatePoolConfig(config);\n    res.json({ success: true, config: updatedConfig });\n  } catch (error) {\n    console.error('Failed to update VM pool config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/admin/vm-pool/:vmId - Get single VM details\napp.get('/api/admin/vm-pool/:vmId', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const vm = vmPoolManager.getVM(vmId);\n    if (!vm) {\n      return res.status(404).json({ error: 'VM not found', vmId });\n    }\n    res.json(vm);\n  } catch (error) {\n    console.error('Failed to get VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/:vmId/start - Start a stopped VM\napp.post('/api/admin/vm-pool/:vmId/start', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const result = await vmPoolManager.startVM(vmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to start VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/:vmId/stop - Stop a VM\napp.post('/api/admin/vm-pool/:vmId/stop', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const result = await vmPoolManager.stopVM(vmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to stop VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/launch - Launch a new VM from AMI\napp.post('/api/admin/vm-pool/launch', async (req, res) => {\n  try {\n    const awsService = getAWSService();\n    const { name, instanceType, tags } = req.body || {};\n    // Note: Project and ManagedBy tags are added automatically by awsService.launchInstance()\n    const result = await awsService.launchInstance({\n      name: name || `gymnastics-vm-${Date.now()}`,\n      instanceType,\n      tags: tags || {}\n    });\n\n    // Sync the pool to include the new instance\n    const vmPoolManager = getVMPoolManager();\n    if (vmPoolManager.isInitialized()) {\n      // Allow time for AWS to process then re-sync\n      setTimeout(async () => {\n        try {\n          await vmPoolManager._syncWithAWS();\n        } catch (syncError) {\n          console.error('Failed to sync after launch:', syncError);\n        }\n      }, 5000);\n    }\n\n    res.json({\n      success: true,\n      instance: result,\n      message: 'VM launched successfully. It will appear in the pool after startup.'\n    });\n  } catch (error) {\n    console.error('Failed to launch VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// DELETE /api/admin/vm-pool/:vmId - Terminate a VM\napp.delete('/api/admin/vm-pool/:vmId', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const vm = vmPoolManager.getVM(vmId);\n    if (!vm) {\n      return res.status(404).json({ error: 'VM not found', vmId });\n    }\n\n    // Don't allow terminating assigned VMs\n    if (vm.assignedTo) {\n      return res.status(400).json({\n        error: 'Cannot terminate assigned VM',\n        assignedTo: vm.assignedTo,\n        message: 'Release the VM from its competition first'\n      });\n    }\n\n    const awsService = getAWSService();\n    const result = await awsService.terminateInstance(vm.instanceId);\n\n    res.json({\n      success: true,\n      vmId,\n      instanceId: vm.instanceId,\n      result,\n      message: 'VM termination initiated'\n    });\n  } catch (error) {\n    console.error('Failed to terminate VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Competition VM Assignment API Endpoints\n// ============================================\n\n// POST /api/competitions/:compId/vm/assign - Assign a VM to a competition\napp.post('/api/competitions/:compId/vm/assign', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const { preferredVmId } = req.body || {};\n\n    // Check if competition already has a VM assigned\n    const existingVM = vmPoolManager.getVMForCompetition(compId);\n    if (existingVM) {\n      return res.status(400).json({\n        error: 'Competition already has a VM assigned',\n        competitionId: compId,\n        vmId: existingVM.vmId,\n        publicIp: existingVM.publicIp\n      });\n    }\n\n    const result = await vmPoolManager.assignVM(compId, preferredVmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to assign VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/competitions/:compId/vm/release - Release a VM from a competition\napp.post('/api/competitions/:compId/vm/release', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const result = await vmPoolManager.releaseVM(compId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to release VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/competitions/:compId/vm - Get the VM assigned to a competition\napp.get('/api/competitions/:compId/vm', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const vm = vmPoolManager.getVMForCompetition(compId);\n\n    if (!vm) {\n      return res.status(404).json({\n        error: 'No VM assigned to this competition',\n        competitionId: compId\n      });\n    }\n\n    res.json({\n      competitionId: compId,\n      vmId: vm.vmId,\n      instanceId: vm.instanceId,\n      publicIp: vm.publicIp,\n      status: vm.status,\n      services: vm.services,\n      vmAddress: vm.publicIp ? `${vm.publicIp}:${vmPoolManager.getPoolStatus().config.servicePort}` : null\n    });\n  } catch (error) {\n    console.error('Failed to get competition VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/vm/:compId/status - Proxy VM status check (avoids Mixed Content in production)\n// Frontend calls this instead of hitting the VM directly\napp.get('/api/vm/:compId/status', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.json({ online: false, noVm: true, error: 'VM pool not initialized' });\n    }\n\n    // Find VM assigned to this competition\n    let vm = null;\n    for (const [, v] of vmPoolManager._vms) {\n      if (v.assignedTo === compId) {\n        vm = v;\n        break;\n      }\n    }\n\n    if (!vm || !vm.publicIp) {\n      return res.json({ online: false, noVm: true });\n    }\n\n    // Server-side request to VM (no Mixed Content issues)\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n    try {\n      const response = await fetch(`http://${vm.publicIp}:3003/api/status`, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n\n      if (response.ok) {\n        const data = await response.json();\n        return res.json({\n          online: true,\n          obsConnected: data.obsConnected || false,\n          uptime: data.uptime,\n          version: data.version\n        });\n      }\n      return res.json({ online: false, error: `HTTP ${response.status}` });\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      const errorMessage = fetchError.name === 'AbortError' ? 'Request timeout' : fetchError.message;\n      return res.json({ online: false, error: errorMessage });\n    }\n  } catch (error) {\n    console.error(`[API] Failed to check VM status for ${compId}:`, error);\n    res.json({ online: false, error: error.message });\n  }\n});\n\n// ============================================\n// Camera Health API Endpoints\n// ============================================\n\n// GET /api/cameras/health - Get health status for all cameras\napp.get('/api/cameras/health', (req, res) => {\n  if (!cameraHealthMonitor) {\n    return res.status(503).json({ error: 'Camera health monitoring not initialized' });\n  }\n  res.json(cameraHealthMonitor.getAllHealth());\n});\n\n// GET /api/cameras/:id/health - Get health status for a specific camera\napp.get('/api/cameras/:id/health', (req, res) => {\n  if (!cameraHealthMonitor) {\n    return res.status(503).json({ error: 'Camera health monitoring not initialized' });\n  }\n  const health = cameraHealthMonitor.getCameraHealth(req.params.id);\n  if (!health) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(health);\n});\n\n// GET /api/cameras/runtime - Get runtime state for all cameras\napp.get('/api/cameras/runtime', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  res.json(cameraRuntimeState.getAllState());\n});\n\n// POST /api/cameras/:id/reassign - Reassign apparatus to a camera\napp.post('/api/cameras/:id/reassign', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  const { apparatus, assignedBy } = req.body;\n  if (!apparatus || !Array.isArray(apparatus)) {\n    return res.status(400).json({ error: 'apparatus must be an array of apparatus codes' });\n  }\n  const result = cameraRuntimeState.reassignApparatus(req.params.id, apparatus, assignedBy);\n  if (!result) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// POST /api/cameras/:id/verify - Verify a camera\napp.post('/api/cameras/:id/verify', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  const { verifiedBy } = req.body || {};\n  const result = cameraRuntimeState.verifyCamera(req.params.id, verifiedBy);\n  if (!result) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// GET /api/cameras/fallbacks - Get active fallbacks\napp.get('/api/cameras/fallbacks', (req, res) => {\n  if (!cameraFallbackManager) {\n    return res.status(503).json({ error: 'Camera fallback manager not initialized' });\n  }\n  res.json(cameraFallbackManager.getActiveFallbacks());\n});\n\n// POST /api/cameras/:id/clear-fallback - Clear fallback for a camera\napp.post('/api/cameras/:id/clear-fallback', (req, res) => {\n  if (!cameraFallbackManager) {\n    return res.status(503).json({ error: 'Camera fallback manager not initialized' });\n  }\n  const result = cameraFallbackManager.clearFallback(req.params.id);\n  if (!result.success) {\n    return res.status(404).json({ error: result.error, cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// ============================================\n// OBS Scene Generation API Endpoints\n// ============================================\n\n// POST /api/scenes/generate - Generate OBS scenes from camera config\napp.post('/api/scenes/generate', async (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n  if (!showState.obsConnected) {\n    return res.status(503).json({ error: 'OBS not connected' });\n  }\n\n  try {\n    const { types } = req.body || {};\n\n    // If types are specified, generate only those scene types\n    // Otherwise generate all scenes\n    let results;\n    if (types && Array.isArray(types) && types.length > 0) {\n      // Generate scenes filtered by types\n      // For filtered generation, we need to manually call each type\n      results = {\n        created: [],\n        skipped: [],\n        failed: [],\n        summary: { created: 0, skipped: 0, failed: 0, total: 0 }\n      };\n\n      const graphicsUrl = obsSceneGenerator.buildGraphicsUrl();\n      const cameras = obsSceneGenerator.cameras;\n\n      // Helper to categorize results\n      const categorize = (result) => {\n        if (result.status === 'created') results.created.push(result);\n        else if (result.status === 'skipped') results.skipped.push(result);\n        else results.failed.push(result);\n      };\n\n      if (types.includes('static')) {\n        for (const name of ['Starting Soon', 'BRB', 'Thanks for Watching']) {\n          const result = await obsSceneGenerator.createStaticScene(name, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('single')) {\n        for (const camera of cameras) {\n          const result = await obsSceneGenerator.createSingleCameraScene(camera, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('dual') && cameras.length >= 2) {\n        const combos = getCombinations(cameras, 2);\n        for (const [cam1, cam2] of combos) {\n          const result = await obsSceneGenerator.createDualCameraScene(cam1, cam2, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('triple') && cameras.length >= 3) {\n        const combos = getCombinations(cameras, 3);\n        for (const [cam1, cam2, cam3] of combos) {\n          const result = await obsSceneGenerator.createTriCameraScene(cam1, cam2, cam3, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('quad') && cameras.length >= 4) {\n        const combos = getCombinations(cameras, 4);\n        for (const cams of combos) {\n          const result = await obsSceneGenerator.createQuadCameraScene(cams, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('graphics')) {\n        const result = await obsSceneGenerator.createGraphicsFullscreenScene(graphicsUrl);\n        categorize(result);\n      }\n\n      results.summary.created = results.created.length;\n      results.summary.skipped = results.skipped.length;\n      results.summary.failed = results.failed.length;\n      results.summary.total = results.summary.created + results.summary.skipped + results.summary.failed;\n    } else {\n      // Generate all scenes\n      results = await obsSceneGenerator.generateAllScenes();\n    }\n\n    res.json(results);\n  } catch (error) {\n    console.error('Scene generation error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Helper function for combinations (used in filtered generation)\nfunction getCombinations(arr, size) {\n  if (size === 0) return [[]];\n  if (arr.length === 0) return [];\n  const [first, ...rest] = arr;\n  const withFirst = getCombinations(rest, size - 1).map(combo => [first, ...combo]);\n  const withoutFirst = getCombinations(rest, size);\n  return [...withFirst, ...withoutFirst];\n}\n\n// GET /api/scenes/preview - Preview what scenes would be generated\napp.get('/api/scenes/preview', (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n\n  try {\n    const types = req.query.types ? req.query.types.split(',') : undefined;\n    const preview = obsSceneGenerator.previewScenes({ types });\n    res.json(preview);\n  } catch (error) {\n    console.error('Scene preview error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// DELETE /api/scenes/generated - Delete all generated scenes\napp.delete('/api/scenes/generated', async (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n  if (!showState.obsConnected) {\n    return res.status(503).json({ error: 'OBS not connected' });\n  }\n\n  try {\n    const results = await obsSceneGenerator.deleteGeneratedScenes();\n    res.json(results);\n  } catch (error) {\n    console.error('Scene deletion error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Timesheet Engine API Endpoints\n// ============================================\n\n// GET /api/timesheet/state - Get current timesheet state\napp.get('/api/timesheet/state', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getState());\n});\n\n// GET /api/timesheet/overrides - Get timesheet override history\napp.get('/api/timesheet/overrides', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getOverrides());\n});\n\n// GET /api/timesheet/history - Get segment history\napp.get('/api/timesheet/history', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getHistory());\n});\n\n// POST /api/timesheet/start - Start the timesheet show\napp.post('/api/timesheet/start', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  try {\n    await timesheetEngine.start();\n    res.json({ success: true, state: timesheetEngine.getState() });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/timesheet/stop - Stop the timesheet show\napp.post('/api/timesheet/stop', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  timesheetEngine.stop();\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/advance - Advance to next segment\napp.post('/api/timesheet/advance', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { advancedBy } = req.body || {};\n  const success = await timesheetEngine.advance(advancedBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: 'Cannot advance segment', state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/previous - Go to previous segment\napp.post('/api/timesheet/previous', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { triggeredBy } = req.body || {};\n  const success = await timesheetEngine.previous(triggeredBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: 'Cannot go to previous segment', state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/jump - Jump to specific segment\napp.post('/api/timesheet/jump', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { segmentId, triggeredBy } = req.body || {};\n  if (!segmentId) {\n    return res.status(400).json({ error: 'segmentId is required' });\n  }\n  const success = await timesheetEngine.goToSegment(segmentId, triggeredBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: `Cannot jump to segment: ${segmentId}`, state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// ============================================\n// Alert System API Endpoints\n// ============================================\n\n// GET /api/alerts/:compId - Get active alerts for a competition\napp.get('/api/alerts/:compId', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      // Try to initialize\n      try {\n        await alertService.initialize();\n      } catch (initError) {\n        return res.status(503).json({\n          error: 'Alert service not initialized',\n          details: 'Firebase credentials not configured'\n        });\n      }\n    }\n\n    const alerts = await alertService.getActiveAlerts(compId);\n    res.json(alerts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get alerts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/alerts/:compId/counts - Get alert counts for a competition\napp.get('/api/alerts/:compId/counts', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized',\n        details: 'Firebase credentials not configured'\n      });\n    }\n\n    const counts = await alertService.getAlertCounts(compId);\n    res.json(counts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get counts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/alerts/:compId/all - Get all alerts (including resolved)\napp.get('/api/alerts/:compId/all', async (req, res) => {\n  const { compId } = req.params;\n  const { includeResolved, limit } = req.query;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alerts = await alertService.getAllAlerts(compId, {\n      includeResolved: includeResolved !== 'false',\n      limit: limit ? parseInt(limit, 10) : 100\n    });\n    res.json(alerts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get all alerts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId - Create a new alert\napp.post('/api/alerts/:compId', async (req, res) => {\n  const { compId } = req.params;\n  const { level, category, title, message, sourceId, metadata } = req.body;\n\n  // Validate required fields\n  if (!level || !category || !title || !message) {\n    return res.status(400).json({\n      error: 'Missing required fields',\n      required: ['level', 'category', 'title', 'message']\n    });\n  }\n\n  // Validate level\n  if (!Object.values(ALERT_LEVEL).includes(level)) {\n    return res.status(400).json({\n      error: `Invalid alert level: ${level}`,\n      validLevels: Object.values(ALERT_LEVEL)\n    });\n  }\n\n  // Validate category\n  if (!Object.values(ALERT_CATEGORY).includes(category)) {\n    return res.status(400).json({\n      error: `Invalid alert category: ${category}`,\n      validCategories: Object.values(ALERT_CATEGORY)\n    });\n  }\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      try {\n        await alertService.initialize();\n      } catch (initError) {\n        return res.status(503).json({\n          error: 'Alert service not initialized',\n          details: 'Firebase credentials not configured'\n        });\n      }\n    }\n\n    const alert = await alertService.createAlert(compId, {\n      level,\n      category,\n      title,\n      message,\n      sourceId: sourceId || null,\n      metadata: metadata || {}\n    });\n\n    res.json({ success: true, id: alert.id, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to create alert for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/:alertId/acknowledge - Acknowledge an alert\napp.post('/api/alerts/:compId/:alertId/acknowledge', async (req, res) => {\n  const { compId, alertId } = req.params;\n  const { acknowledgedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alert = await alertService.acknowledgeAlert(compId, alertId, acknowledgedBy || 'api');\n\n    if (!alert) {\n      return res.status(404).json({\n        error: 'Alert not found',\n        alertId\n      });\n    }\n\n    res.json({ success: true, acknowledged: true, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to acknowledge alert ${alertId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/:alertId/resolve - Resolve an alert\napp.post('/api/alerts/:compId/:alertId/resolve', async (req, res) => {\n  const { compId, alertId } = req.params;\n  const { resolvedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alert = await alertService.resolveAlert(compId, alertId, resolvedBy || 'api', false);\n\n    if (!alert) {\n      return res.status(404).json({\n        error: 'Alert not found',\n        alertId\n      });\n    }\n\n    res.json({ success: true, resolved: true, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to resolve alert ${alertId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/resolve-by-source - Resolve alerts by source ID\napp.post('/api/alerts/:compId/resolve-by-source', async (req, res) => {\n  const { compId } = req.params;\n  const { sourceId, resolvedBy } = req.body || {};\n\n  if (!sourceId) {\n    return res.status(400).json({\n      error: 'sourceId is required'\n    });\n  }\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const count = await alertService.resolveBySourceId(compId, sourceId, resolvedBy || 'api');\n    res.json({ success: true, count });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to resolve by sourceId ${sourceId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/acknowledge-all - Acknowledge all alerts\napp.post('/api/alerts/:compId/acknowledge-all', async (req, res) => {\n  const { compId } = req.params;\n  const { acknowledgedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const count = await alertService.acknowledgeAll(compId, acknowledgedBy || 'api');\n    res.json({ success: true, count });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to acknowledge all for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Coordinator Health API Endpoints\n// ============================================\n\n// GET /api/coordinator/status - Get coordinator health and status\napp.get('/api/coordinator/status', async (req, res) => {\n  updateLastActivity();\n\n  const isCoordinatorMode = process.env.COORDINATOR_MODE === 'true';\n\n  // Check Firebase connection status\n  let firebaseStatus = 'unknown';\n  try {\n    if (productionConfigService.isAvailable()) {\n      firebaseStatus = 'connected';\n    } else {\n      firebaseStatus = 'unavailable';\n    }\n  } catch (error) {\n    firebaseStatus = 'error';\n  }\n\n  // Check AWS SDK status (can we reach EC2 API?)\n  let awsStatus = 'unknown';\n  try {\n    const awsService = getAWSService();\n    // Try a simple describe call with a filter that returns quickly\n    await awsService.describeInstances({ limit: 1 });\n    awsStatus = 'connected';\n  } catch (error) {\n    // Check if it's a credentials error vs network error\n    if (error.name === 'CredentialsProviderError' || error.message?.includes('credentials')) {\n      awsStatus = 'no_credentials';\n    } else if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n      awsStatus = 'unreachable';\n    } else {\n      awsStatus = 'error';\n    }\n  }\n\n  // Check OBS connection status\n  const obsStatus = showState.obsConnected ? 'connected' : 'disconnected';\n\n  // Get auto-shutdown status if initialized\n  const autoShutdown = getAutoShutdownService();\n  const autoShutdownStatus = autoShutdown.isInitialized() ? autoShutdown.getStatus() : null;\n\n  // Build response\n  // Include 'state' and 'appReady' fields for frontend compatibility\n  // (frontend expects EC2-style state from Netlify functions)\n  const status = {\n    success: true,\n    state: 'running',  // EC2-style state for frontend\n    appReady: true,    // App is responding, so it's ready\n    status: 'online',\n    uptime: getUptime(),\n    uptimeFormatted: formatUptime(getUptime()),\n    version: SERVER_VERSION,\n    mode: isCoordinatorMode ? 'coordinator' : 'standalone',\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    idleSeconds: getIdleTime(),\n    idleMinutes: Math.floor(getIdleTime() / 60),\n    publicIp: process.env.PUBLIC_IP || null,\n    connections: {\n      firebase: firebaseStatus,\n      aws: awsStatus,\n      obs: obsStatus\n    },\n    connectedClients: showState.connectedClients.length,\n    autoShutdown: autoShutdownStatus\n  };\n\n  res.json(status);\n});\n\n// GET /api/coordinator/activity - Get last activity timestamp\napp.get('/api/coordinator/activity', (req, res) => {\n  res.json({\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    idleSeconds: getIdleTime()\n  });\n});\n\n// POST /api/coordinator/activity - Update last activity timestamp (keep-alive)\napp.post('/api/coordinator/activity', (req, res) => {\n  updateLastActivity();\n  res.json({\n    success: true,\n    lastActivity: new Date(lastActivityTimestamp).toISOString()\n  });\n});\n\n// GET /api/coordinator/idle - Get detailed idle status for auto-shutdown (P19-02)\napp.get('/api/coordinator/idle', (req, res) => {\n  const autoShutdown = getAutoShutdownService();\n  const idleSeconds = getIdleTime();\n  const idleMinutes = Math.floor(idleSeconds / 60);\n\n  // Get auto-shutdown config if available\n  const autoShutdownStatus = autoShutdown.isInitialized() ? autoShutdown.getStatus() : null;\n\n  res.json({\n    idleSeconds,\n    idleMinutes,\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    autoShutdown: autoShutdownStatus ? {\n      enabled: autoShutdownStatus.enabled,\n      timeoutMinutes: autoShutdownStatus.idleTimeoutMinutes,\n      shutdownPending: autoShutdownStatus.shutdownPending,\n      timeUntilShutdown: autoShutdownStatus.enabled\n        ? Math.max(0, autoShutdownStatus.idleTimeoutMinutes - idleMinutes)\n        : null\n    } : null\n  });\n});\n\n// POST /api/coordinator/keep-alive - Reset activity and cancel pending shutdown (P19-02)\napp.post('/api/coordinator/keep-alive', (req, res) => {\n  // Update local activity timestamp\n  updateLastActivity();\n\n  // Also update auto-shutdown service if initialized\n  const autoShutdown = getAutoShutdownService();\n  if (autoShutdown.isInitialized()) {\n    autoShutdown.keepAlive();\n  }\n\n  res.json({\n    success: true,\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    message: 'Keep-alive received, activity timestamp updated'\n  });\n});\n\n/**\n * Format uptime seconds into human readable string\n * @param {number} seconds - Uptime in seconds\n * @returns {string} Formatted uptime\n */\nfunction formatUptime(seconds) {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n\n  const parts = [];\n  if (days > 0) parts.push(`${days}d`);\n  if (hours > 0) parts.push(`${hours}h`);\n  if (minutes > 0) parts.push(`${minutes}m`);\n  if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);\n\n  return parts.join(' ');\n}\n\n// CSV Upload endpoint\napp.post('/api/import-csv', upload.single('csv'), (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No CSV file uploaded' });\n    }\n\n    const csvContent = req.file.buffer.toString('utf-8');\n    const records = parse(csvContent, {\n      columns: true,\n      skip_empty_lines: true,\n      trim: true\n    });\n\n    if (records.length === 0) {\n      return res.status(400).json({ error: 'CSV file is empty' });\n    }\n\n    // Get show name from query param or first row or default\n    const showName = req.body.showName || req.query.showName || 'Imported Show';\n\n    // Convert CSV records to segments\n    const segments = records.map((row, index) => {\n      // Generate ID from name if not provided\n      const id = row.id || row.name?.toLowerCase().replace(/[^a-z0-9]+/g, '-') || `segment-${index}`;\n\n      // Parse duration (can be \"mm:ss\" format or just seconds)\n      let duration = null;\n      if (row.duration) {\n        if (row.duration.includes(':')) {\n          const [mins, secs] = row.duration.split(':').map(Number);\n          duration = mins * 60 + secs;\n        } else {\n          duration = parseInt(row.duration) || null;\n        }\n      }\n\n      // Parse autoAdvance (various true/false formats)\n      const autoAdvance = ['true', 'yes', '1', 'auto'].includes(\n        (row.autoAdvance || row.auto_advance || row.auto || '').toLowerCase()\n      );\n\n      // Build segment object\n      const segment = {\n        id,\n        name: row.name || row.segment_name || row.title || `Segment ${index + 1}`,\n        type: row.type || 'live',\n        obsScene: row.obsScene || row.obs_scene || row.scene || null,\n        duration,\n        autoAdvance,\n        notes: row.notes || row.description || null,\n        videoFile: row.videoFile || row.video_file || row.video || null\n      };\n\n      // Add graphic if specified\n      if (row.graphic) {\n        segment.graphic = row.graphic;\n\n        // Parse graphicData if provided as JSON string\n        if (row.graphicData || row.graphic_data) {\n          try {\n            segment.graphicData = JSON.parse(row.graphicData || row.graphic_data);\n          } catch (e) {\n            // If not valid JSON, try to parse as key=value pairs\n            const data = {};\n            const dataStr = row.graphicData || row.graphic_data;\n            if (dataStr.includes('=')) {\n              dataStr.split(';').forEach(pair => {\n                const [key, value] = pair.split('=');\n                if (key && value) data[key.trim()] = value.trim();\n              });\n              segment.graphicData = data;\n            }\n          }\n        }\n      }\n\n      return segment;\n    });\n\n    // Build the show config\n    const newConfig = {\n      showName,\n      segments,\n      sponsors: showConfig?.sponsors || {},\n      quickActions: showConfig?.quickActions || []\n    };\n\n    // Save to file\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    writeFileSync(configPath, JSON.stringify(newConfig, null, 2));\n\n    // Reload config (the file watcher will also trigger this)\n    loadShowConfig();\n    broadcastState();\n\n    res.json({\n      success: true,\n      message: `Imported ${segments.length} segments`,\n      segments: segments.length,\n      showName\n    });\n\n  } catch (error) {\n    console.error('CSV import error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Virtius API proxy (avoids CORS issues)\napp.get('/api/virtius/:sessionId', async (req, res) => {\n  try {\n    const response = await fetch(`https://api.virti.us/session/${req.params.sessionId}/json`);\n    if (!response.ok) {\n      return res.status(404).json({ error: 'Virtius session not found' });\n    }\n    const data = await response.json();\n    res.json(data);\n  } catch (error) {\n    console.error('Virtius API error:', error.message);\n    res.status(500).json({ error: 'Failed to fetch Virtius session' });\n  }\n});\n\n// Get CSV template\napp.get('/api/csv-template', (req, res) => {\n  const template = `id,name,type,obsScene,duration,autoAdvance,graphic,graphicData,videoFile,notes\nintro,Show Intro,video,Video Scene,0:45,true,,,/path/to/videos/intro.mp4,Intro video plays automatically\nwelcome,Welcome & Host Intro,live,Talent Camera,,,,,,Welcome viewers and introduce sponsors\nevent-intro,Event Introduction,graphic,Graphics,8,true,event-bar,,,\nteam1-stats,Team 1 Stats,graphic,Graphics,10,true,team1-stats,,,\nrotation1-floor,Floor Exercise Intro,graphic,Graphics,5,true,event-frame,frameTitle=FLOOR EXERCISE,,\nrotation1-floor-live,Floor Exercise,live,Competition Camera,,,,,,Floor exercise routines\nhalftime-video,Halftime Video,video,Video Scene,2:00,true,,,/path/to/videos/halftime.mp4,Plays sponsor video\nhalftime,Halftime Break,live,BRB,5:00,false,,,,5 minute break\nclosing,Closing Remarks,live,Talent Camera,,,,,,Thank viewers and recap\noutro,Thanks for Watching,video,Video Scene,0:15,false,,,/path/to/videos/outro.mp4,End card video`;\n\n  res.setHeader('Content-Type', 'text/csv');\n  res.setHeader('Content-Disposition', 'attachment; filename=\"show-template.csv\"');\n  res.send(template);\n});\n\n// Setup OBS Scene CRUD API routes (OBS-06)\n// Pass getter function for obsStateSync since it may be null until competition is activated\nsetupOBSRoutes(app, obs, () => obsStateSync);\n\n// Redirect Netlify function paths to API endpoints (for compatibility when not on Netlify)\napp.get('/.netlify/functions/coordinator-status', (req, res) => {\n  res.redirect(307, '/api/coordinator/status');\n});\napp.post('/.netlify/functions/wake-coordinator', (req, res) => {\n  res.redirect(307, '/api/coordinator/wake');\n});\napp.post('/.netlify/functions/stop-coordinator', (req, res) => {\n  res.redirect(307, '/api/coordinator/stop');\n});\n\n// Serve React app for all other routes (Express 5 syntax)\napp.get('/{*path}', (req, res) => {\n  res.sendFile(join(__dirname, '..', 'show-controller', 'dist', 'index.html'));\n});\n\n// Helper function to categorize scene by name (for coordinator)\n// Note: This function mirrors the categorization logic from obsStateSync.js\n// but operates independently since obsStateSync is only for local development\nfunction categorizeSceneByName(sceneName, templateScenes = []) {\n  if (!sceneName) {\n    return 'manual';\n  }\n\n  // Check if scene is in templateScenes list (from Firebase)\n  if (templateScenes && templateScenes.includes(sceneName)) {\n    return 'template';\n  }\n\n  const name = sceneName.toLowerCase();\n\n  // Generated single-camera scenes\n  // Template patterns: \"Full Screen - Camera X\", \"Replay - Camera X\"\n  // Legacy patterns: \"Single - Camera X\"\n  if (name.startsWith('full screen - ') ||\n      name.startsWith('replay - ') ||\n      name.startsWith('single - ')) {\n    return 'generated-single';\n  }\n\n  // Generated multi-camera scenes\n  // Template patterns: \"Dual View - ...\", \"Triple View - ...\", \"Quad View\"\n  // Legacy patterns: \"Dual - ...\", \"Triple - ...\", \"Quad - ...\"\n  if (name.startsWith('dual view') ||\n      name.startsWith('triple view') ||\n      name.startsWith('quad view') ||\n      name === 'quad view' ||\n      name.startsWith('dual - ') ||\n      name.startsWith('triple - ') ||\n      name.startsWith('quad - ')) {\n    return 'generated-multi';\n  }\n\n  // Static production scenes\n  // Template patterns: \"Stream Starting Soon\", \"End Stream\"\n  // Legacy patterns: \"Starting Soon\", \"BRB\", \"Thanks for Watching\", \"Be Right Back\"\n  const staticScenes = ['starting soon', 'brb', 'thanks for watching', 'be right back', 'end stream'];\n  if (staticScenes.some(s => name.includes(s))) {\n    return 'static';\n  }\n\n  // Graphics-only scenes\n  // Template pattern: \"Web-graphics-only-no-video\"\n  // Legacy pattern: \"Graphics Fullscreen\"\n  if (name.includes('graphics fullscreen') ||\n      name.includes('web-graphics-only') ||\n      name.includes('graphics-only')) {\n    return 'graphics';\n  }\n\n  // Everything else is manual\n  return 'manual';\n}\n\n// Helper function to fetch and broadcast OBS state for a competition\nasync function broadcastOBSState(compId, obsConnManager, io) {\n  const room = `competition:${compId}`;\n  const compObs = obsConnManager.getConnection(compId);\n\n  if (!compObs) {\n    console.log(`[broadcastOBSState] No OBS connection for ${compId}`);\n    return;\n  }\n\n  try {\n    // Fetch template scenes from Firebase for proper categorization\n    let templateScenes = [];\n    try {\n      const db = productionConfigService.getDb();\n      if (db) {\n        const snapshot = await db.ref(`competitions/${compId}/obs/templateScenes`).once('value');\n        templateScenes = snapshot.val() || [];\n        if (!Array.isArray(templateScenes)) {\n          templateScenes = [];\n        }\n      }\n    } catch (fbError) {\n      console.log(`[broadcastOBSState] Could not fetch template scenes: ${fbError.message}`);\n    }\n\n    // Fetch scene list\n    const sceneListResponse = await compObs.call('GetSceneList');\n    const currentScene = sceneListResponse.currentProgramSceneName || null;\n\n    // Fetch scene items for each scene\n    const scenes = await Promise.all((sceneListResponse.scenes || []).map(async (scene) => {\n      let items = [];\n      try {\n        const itemsResponse = await compObs.call('GetSceneItemList', { sceneName: scene.sceneName });\n        items = (itemsResponse.sceneItems || []).map(item => ({\n          id: item.sceneItemId,\n          sourceName: item.sourceName,\n          sourceType: item.sourceType,\n          inputKind: item.inputKind,\n          enabled: item.sceneItemEnabled,\n          locked: item.sceneItemLocked,\n          transform: item.sceneItemTransform\n        }));\n      } catch (itemError) {\n        console.log(`[broadcastOBSState] Could not fetch items for scene ${scene.sceneName}: ${itemError.message}`);\n      }\n      return {\n        name: scene.sceneName,\n        sceneName: scene.sceneName, // Include both for compatibility\n        uuid: scene.sceneUuid,\n        index: scene.sceneIndex,\n        items,\n        category: categorizeSceneByName(scene.sceneName, templateScenes)\n      };\n    }));\n\n    // Fetch ALL inputs (sources)\n    let inputs = [];\n    let audioSources = [];\n    try {\n      const inputsResponse = await compObs.call('GetInputList');\n      inputs = (inputsResponse.inputs || []).map(input => ({\n        name: input.inputName,\n        kind: input.inputKind,\n        uuid: input.inputUuid\n      }));\n      // Also filter for audio sources separately\n      // Include sources that can produce audio: dedicated audio, media sources, and browser sources\n      const audioInputs = inputs.filter(input =>\n        input.kind?.includes('audio') ||\n        input.kind?.includes('wasapi') ||\n        input.kind?.includes('pulse') ||\n        input.kind?.includes('coreaudio') ||\n        input.kind === 'ffmpeg_source' ||     // Media sources (video files, SRT streams)\n        input.kind === 'browser_source'        // Browser sources (VDO.Ninja talent)\n      );\n\n      // Fetch volume/mute/monitor status for each audio source\n      audioSources = await Promise.all(audioInputs.map(async (input) => {\n        try {\n          const [volumeRes, muteRes, monitorRes] = await Promise.all([\n            compObs.call('GetInputVolume', { inputName: input.name }),\n            compObs.call('GetInputMute', { inputName: input.name }),\n            compObs.call('GetInputAudioMonitorType', { inputName: input.name })\n          ]);\n          return {\n            inputName: input.name,\n            kind: input.kind,\n            uuid: input.uuid,\n            volumeDb: volumeRes.inputVolumeDb ?? 0,\n            volumeMul: volumeRes.inputVolumeMul ?? 1,\n            muted: muteRes.inputMuted ?? false,\n            monitorType: monitorRes.monitorType ?? 'OBS_MONITORING_TYPE_NONE'\n          };\n        } catch (e) {\n          // Source might not have audio capabilities - skip it\n          console.log(`[broadcastOBSState] Skipping audio source ${input.name}: ${e.message}`);\n          return null;\n        }\n      }));\n      // Filter out nulls (sources that don't have audio)\n      audioSources = audioSources.filter(s => s !== null);\n    } catch (audioError) {\n      console.log(`[broadcastOBSState] Could not fetch inputs for ${compId}: ${audioError.message}`);\n    }\n\n    // Fetch transitions (PRD-OBS-05: Transition Management)\n    let transitions = [];\n    let currentTransition = null;\n    let transitionDuration = 300;\n    try {\n      const transitionResponse = await compObs.call('GetSceneTransitionList');\n      transitions = (transitionResponse.transitions || []).map(t => ({\n        name: t.transitionName,\n        kind: t.transitionKind,\n        configurable: t.transitionConfigurable || false\n      }));\n      currentTransition = transitionResponse.currentSceneTransitionName;\n      transitionDuration = transitionResponse.currentSceneTransitionDuration || 300;\n    } catch (transitionError) {\n      console.log(`[broadcastOBSState] Could not fetch transitions for ${compId}: ${transitionError.message}`);\n    }\n\n    // Fetch studio mode state (PRD-OBS-11: Advanced Features)\n    let studioModeEnabled = false;\n    let previewScene = null;\n    try {\n      const studioModeResponse = await compObs.call('GetStudioModeEnabled');\n      studioModeEnabled = studioModeResponse.studioModeEnabled || false;\n\n      if (studioModeEnabled) {\n        const previewResponse = await compObs.call('GetCurrentPreviewScene');\n        previewScene = previewResponse.currentPreviewSceneName || null;\n      }\n    } catch (studioError) {\n      console.log(`[broadcastOBSState] Could not fetch studio mode state for ${compId}: ${studioError.message}`);\n    }\n\n    // Broadcast full state\n    const obsState = {\n      connected: true,\n      connectionError: null,\n      scenes,\n      currentScene,\n      previewScene,\n      studioModeEnabled,\n      inputs,\n      audioSources,\n      transitions,\n      currentTransition,\n      transitionDuration,\n      isStreaming: false,\n      isRecording: false\n    };\n\n    console.log(`[broadcastOBSState] Broadcasting for ${compId}: ${scenes.length} scenes, current: ${currentScene}, studioMode: ${studioModeEnabled}, inputs: ${inputs.length}`);\n    io.to(room).emit('obs:stateUpdated', obsState);\n  } catch (error) {\n    console.error(`[broadcastOBSState] Failed to fetch state for ${compId}:`, error.message);\n  }\n}\n\n// Socket.io connection handling\nio.on('connection', async (socket) => {\n  // Extract compId from connection query (sent by frontend)\n  const clientCompId = socket.handshake.query.compId;\n  console.log(`Client connected: ${socket.id} for competition: ${clientCompId || 'none'}`);\n\n  // Track activity on every socket event using socket.io middleware\n  socket.use((packet, next) => {\n    updateLastActivity();\n    const autoShutdown = getAutoShutdownService();\n    if (autoShutdown.isInitialized()) {\n      autoShutdown.resetActivity();\n    }\n    next();\n  });\n\n  // If client has a compId, try to connect to that competition's VM OBS\n  if (clientCompId && clientCompId !== 'local') {\n    try {\n      // Join a room for this competition to receive targeted broadcasts\n      socket.join(`competition:${clientCompId}`);\n\n      // Look up VM for this competition\n      const vmPoolManager = getVMPoolManager();\n      if (vmPoolManager.isInitialized()) {\n        const vm = vmPoolManager.getVMForCompetition(clientCompId);\n        if (vm && vm.publicIp) {\n          console.log(`[Socket] Competition ${clientCompId} has VM at ${vm.publicIp}`);\n\n          // Connect to OBS on that VM (if not already connected)\n          const obsConnManager = getOBSConnectionManager();\n          if (!obsConnManager.isConnected(clientCompId)) {\n            try {\n              await obsConnManager.connectToVM(clientCompId, vm.publicIp);\n              console.log(`[Socket] Connected to OBS for competition ${clientCompId}`);\n            } catch (obsError) {\n              console.warn(`[Socket] Failed to connect to OBS for ${clientCompId}: ${obsError.message}`);\n              // Continue without OBS - some features won't work\n            }\n          }\n        } else {\n          console.log(`[Socket] No VM assigned to competition ${clientCompId}`);\n        }\n      }\n\n      // Set active competition so REST API routes can access the competition ID\n      configLoader.setActiveCompetition(clientCompId);\n      console.log(`[Socket] Active competition set to ${clientCompId}`);\n\n      // Initialize OBS State Sync for this competition (enables REST API routes)\n      try {\n        await initializeOBSStateSync(clientCompId);\n        console.log(`[Socket] OBS State Sync initialized for competition ${clientCompId}`);\n      } catch (syncError) {\n        console.warn(`[Socket] Failed to initialize OBS State Sync for ${clientCompId}: ${syncError.message}`);\n        // Continue - Socket.io events will still work, but REST API endpoints won't\n      }\n    } catch (error) {\n      console.error(`[Socket] Error setting up competition ${clientCompId}:`, error.message);\n    }\n  }\n\n  // Add client to list\n  const clientInfo = {\n    id: socket.id,\n    role: 'unknown',\n    name: 'Unknown',\n    compId: clientCompId || null\n  };\n  showState.connectedClients.push(clientInfo);\n\n  // Send initial state\n  socket.emit('connected', {\n    clientId: socket.id,\n    state: {\n      ...showState,\n      showConfig: showConfig ? {\n        showName: showConfig.showName,\n        segments: showConfig.segments,\n        sponsors: showConfig.sponsors\n      } : null\n    }\n  });\n\n  // Send initial camera state if available\n  if (cameraHealthMonitor) {\n    socket.emit('cameraHealth', cameraHealthMonitor.getAllHealth());\n  }\n  if (cameraRuntimeState) {\n    socket.emit('cameraRuntimeState', cameraRuntimeState.getAllState());\n  }\n  if (cameraFallbackManager) {\n    socket.emit('activeFallbacks', cameraFallbackManager.getActiveFallbacks());\n  }\n\n  // Send initial timesheet state if available\n  if (timesheetEngine) {\n    socket.emit('timesheetState', timesheetEngine.getState());\n  }\n\n  // Send initial OBS state if available\n  // First, try to get OBS state from the competition's VM connection\n  if (clientCompId && clientCompId !== 'local') {\n    const obsConnManager = getOBSConnectionManager();\n    const connState = obsConnManager.getConnectionState(clientCompId);\n    if (connState) {\n      // Send basic connection info immediately\n      socket.emit('obs:stateUpdated', {\n        connected: connState.connected,\n        connectionError: connState.error\n      });\n      // If connected, also broadcast full OBS state (scenes, current scene, etc.)\n      if (connState.connected) {\n        broadcastOBSState(clientCompId, obsConnManager, io);\n      }\n    }\n  } else if (obsStateSync && obsStateSync.isInitialized()) {\n    // Fall back to local OBS state\n    socket.emit('obs:stateUpdated', obsStateSync.getState());\n  }\n\n  broadcastState();\n\n  // Client identifies themselves\n  socket.on('identify', ({ role, name }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client) {\n      client.role = role;\n      client.name = name;\n      console.log(`Client ${socket.id} identified as ${role}: ${name}`);\n      broadcastState();\n    }\n  });\n\n  // Advance to next segment\n  socket.on('advance', async () => {\n    const success = await advanceSegment(socket.id);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot advance' });\n    }\n  });\n\n  // Go to previous segment\n  socket.on('previous', async () => {\n    const success = await previousSegment();\n    if (!success) {\n      socket.emit('error', { message: 'Cannot go back' });\n    }\n  });\n\n  // Jump to specific segment\n  socket.on('jumpTo', async ({ segmentId }) => {\n    const success = await jumpToSegment(segmentId);\n    if (!success) {\n      socket.emit('error', { message: `Cannot jump to segment: ${segmentId}` });\n    }\n  });\n\n  // Override scene (producer only)\n  socket.on('overrideScene', async ({ sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override scenes' });\n      return;\n    }\n\n    const success = await switchScene(sceneName);\n    if (!success) {\n      socket.emit('error', { message: `Failed to switch to scene: ${sceneName}` });\n    }\n  });\n\n  // Switch scene (alias for overrideScene - used by OBS Manager UI)\n  socket.on('switchScene', async ({ sceneName }) => {\n    console.log(`[switchScene] Received request to switch to: ${sceneName}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    console.log(`[switchScene] Client:`, client ? { id: client.id, role: client.role, compId: client.compId } : 'not found');\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can switch scenes' });\n      return;\n    }\n\n    // Get the client's competition ID to use the per-competition OBS connection\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    // Use per-competition OBS connection\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentProgramScene', { sceneName });\n      console.log(`[switchScene] Switched to scene: ${sceneName} for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[switchScene] Failed to switch scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to switch to scene: ${sceneName}` });\n    }\n  });\n\n  // Create scene (producer only) - supports creating from template\n  socket.on('obs:createScene', async ({ sceneName, templateId }) => {\n    console.log(`[createScene] Received request to create: ${sceneName}${templateId ? ` from template ${templateId}` : ''}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can create scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Create the scene first\n      await compObs.call('CreateScene', { sceneName });\n      console.log(`[createScene] Created scene: ${sceneName} for ${clientCompId}`);\n\n      // If templateId is provided, copy sources from template to the new scene\n      if (templateId) {\n        try {\n          // Fetch the template from Firebase via productionConfigService\n          productionConfigService.initialize();\n          if (productionConfigService.isAvailable()) {\n            // Use Firebase Admin SDK directly to read template\n            const admin = await import('firebase-admin');\n            const database = admin.default.database();\n            const templateRef = database.ref(`templates/obs/${templateId}`);\n            const snapshot = await templateRef.once('value');\n            const template = snapshot.val();\n\n            if (template && template.scenes && template.scenes.length > 0) {\n              // Use the first scene from the template as the source configuration\n              const templateScene = template.scenes[0];\n              const items = templateScene.items || templateScene.sceneItems || [];\n\n              console.log(`[createScene] Copying ${items.length} items from template to ${sceneName}`);\n\n              // Add each item from the template to the new scene\n              for (const item of items) {\n                try {\n                  // CreateSceneItem adds an existing input to the scene\n                  await compObs.call('CreateSceneItem', {\n                    sceneName: sceneName,\n                    sourceName: item.sourceName,\n                    sceneItemEnabled: item.sceneItemEnabled !== undefined ? item.sceneItemEnabled : true\n                  });\n                  console.log(`[createScene] Added source ${item.sourceName} to ${sceneName}`);\n                } catch (itemError) {\n                  // Source might not exist - that's okay, just log and continue\n                  console.warn(`[createScene] Could not add source ${item.sourceName}: ${itemError.message}`);\n                }\n              }\n              console.log(`[createScene] Created scene from template: ${sceneName} for ${clientCompId}`);\n\n              // Store scene name in templateScenes list in Firebase for proper categorization\n              try {\n                const templateScenesRef = database.ref(`competitions/${clientCompId}/obs/templateScenes`);\n                const templateScenesSnapshot = await templateScenesRef.once('value');\n                let templateScenes = templateScenesSnapshot.val() || [];\n                if (!Array.isArray(templateScenes)) {\n                  templateScenes = [];\n                }\n                if (!templateScenes.includes(sceneName)) {\n                  templateScenes.push(sceneName);\n                  await templateScenesRef.set(templateScenes);\n                  console.log(`[createScene] Added ${sceneName} to templateScenes list`);\n                }\n              } catch (fbError) {\n                console.warn(`[createScene] Could not update templateScenes list: ${fbError.message}`);\n              }\n            } else {\n              console.warn(`[createScene] Template ${templateId} has no scenes, created empty scene`);\n            }\n          } else {\n            console.warn('[createScene] Firebase not available, created empty scene');\n          }\n        } catch (templateError) {\n          // Template copy failed but scene was created - log warning but don't fail\n          console.warn(`[createScene] Failed to copy template content: ${templateError.message}`);\n          socket.emit('obs:warning', { message: `Scene created but template copy failed: ${templateError.message}` });\n        }\n      }\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[createScene] Failed to create scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to create scene: ${sceneName}` });\n    }\n  });\n\n  // Delete scene (producer only)\n  socket.on('obs:deleteScene', async ({ sceneName }) => {\n    console.log(`[deleteScene] Received request to delete: ${sceneName}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('RemoveScene', { sceneName });\n      console.log(`[deleteScene] Deleted scene: ${sceneName} for ${clientCompId}`);\n\n      // Remove scene from templateScenes list in Firebase if present\n      try {\n        const db = productionConfigService.getDb();\n        if (db) {\n          const templateScenesRef = db.ref(`competitions/${clientCompId}/obs/templateScenes`);\n          const templateScenesSnapshot = await templateScenesRef.once('value');\n          let templateScenes = templateScenesSnapshot.val() || [];\n          if (Array.isArray(templateScenes) && templateScenes.includes(sceneName)) {\n            templateScenes = templateScenes.filter(s => s !== sceneName);\n            await templateScenesRef.set(templateScenes);\n            console.log(`[deleteScene] Removed ${sceneName} from templateScenes list`);\n          }\n        }\n      } catch (fbError) {\n        console.warn(`[deleteScene] Could not update templateScenes list: ${fbError.message}`);\n      }\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteScene] Failed to delete scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete scene: ${sceneName}` });\n    }\n  });\n\n  // Delete all scenes (producer only)\n  socket.on('obs:deleteAllScenes', async () => {\n    console.log(`[deleteAllScenes] Received request to delete all scenes`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get all scenes\n      const sceneListResponse = await compObs.call('GetSceneList');\n      const scenes = sceneListResponse.scenes || [];\n      const currentScene = sceneListResponse.currentProgramSceneName;\n\n      if (scenes.length === 0) {\n        socket.emit('obs:deleteAllScenesResult', { success: true, deletedCount: 0, message: 'No scenes to delete' });\n        return;\n      }\n\n      // OBS requires at least one scene, so we need to create a temporary scene first\n      // if we're deleting everything\n      const tempSceneName = '__temp_delete_all__';\n\n      // Check if temp scene already exists (from a previous failed attempt)\n      const tempSceneExists = scenes.some(s => (s.sceneName || s.name) === tempSceneName);\n\n      if (!tempSceneExists) {\n        await compObs.call('CreateScene', { sceneName: tempSceneName });\n      }\n\n      // Switch to the temp scene so we can delete all others\n      await compObs.call('SetCurrentProgramScene', { sceneName: tempSceneName });\n\n      let deletedCount = 0;\n      const errors = [];\n\n      // Delete all original scenes (skip the temp scene if it was pre-existing)\n      for (const scene of scenes) {\n        const sceneName = scene.sceneName || scene.name;\n        // Skip the temp scene - we'll rename it at the end\n        if (sceneName === tempSceneName) {\n          continue;\n        }\n        try {\n          await compObs.call('RemoveScene', { sceneName });\n          deletedCount++;\n          console.log(`[deleteAllScenes] Deleted scene: ${sceneName}`);\n        } catch (err) {\n          console.error(`[deleteAllScenes] Failed to delete scene ${sceneName}: ${err.message}`);\n          errors.push({ sceneName, error: err.message });\n        }\n      }\n\n      // Now delete the temp scene - this will fail because OBS requires at least one scene\n      // But that's actually what we want for a clean slate - one empty scene\n      // Rename the temp scene to something more user-friendly\n      try {\n        // Try \"Scene 1\", then \"Scene 2\", etc. until we find an available name\n        let renamed = false;\n        for (let i = 1; i <= 10 && !renamed; i++) {\n          try {\n            const newName = i === 1 ? 'Scene 1' : `Scene ${i}`;\n            await compObs.call('SetSceneName', { sceneName: tempSceneName, newSceneName: newName });\n            renamed = true;\n            console.log(`[deleteAllScenes] Renamed temp scene to: ${newName}`);\n          } catch (renameErr) {\n            // Scene name might already exist, try next number\n            if (i === 10) {\n              console.warn(`[deleteAllScenes] Could not rename temp scene after 10 attempts`);\n            }\n          }\n        }\n      } catch (err) {\n        // If rename fails, just leave it\n        console.warn(`[deleteAllScenes] Could not rename temp scene: ${err.message}`);\n      }\n\n      // Clear templateScenes list in Firebase\n      try {\n        const db = productionConfigService.getDb();\n        if (db) {\n          const templateScenesRef = db.ref(`competitions/${clientCompId}/obs/templateScenes`);\n          await templateScenesRef.set([]);\n          console.log(`[deleteAllScenes] Cleared templateScenes list`);\n        }\n      } catch (fbError) {\n        console.warn(`[deleteAllScenes] Could not clear templateScenes list: ${fbError.message}`);\n      }\n\n      console.log(`[deleteAllScenes] Deleted ${deletedCount} scenes for ${clientCompId}`);\n      socket.emit('obs:deleteAllScenesResult', {\n        success: errors.length === 0,\n        deletedCount,\n        errors: errors.length > 0 ? errors : undefined,\n        message: `Deleted ${deletedCount} scenes${errors.length > 0 ? ` with ${errors.length} errors` : ''}`\n      });\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteAllScenes] Failed to delete all scenes: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete all scenes: ${error.message}` });\n    }\n  });\n\n  // Reorder scenes in OBS\n  socket.on('obs:reorderScenes', async ({ sceneNames }) => {\n    console.log(`[reorderScenes] Received request to reorder scenes:`, sceneNames);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reorder scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get current scene list to get UUIDs\n      const currentSceneList = await compObs.call('GetSceneList');\n      const sceneMap = {};\n      currentSceneList.scenes.forEach(scene => {\n        sceneMap[scene.sceneName] = scene.sceneUuid;\n      });\n\n      // Build new scene list with UUIDs in requested order\n      const newSceneList = sceneNames.map(name => ({\n        sceneName: name,\n        sceneUuid: sceneMap[name]\n      })).filter(s => s.sceneUuid); // Only include scenes that exist\n\n      // Note: OBS WebSocket expects scenes in reverse order (last = bottom of list in OBS)\n      // The SetSceneList API orders scenes from bottom to top\n      await compObs.call('SetSceneList', { scenes: newSceneList.reverse() });\n      console.log(`[reorderScenes] Reordered ${newSceneList.length} scenes for ${clientCompId}`);\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[reorderScenes] Failed to reorder scenes: ${error.message}`);\n      socket.emit('error', { message: `Failed to reorder scenes: ${error.message}` });\n    }\n  });\n\n  // Toggle scene item visibility\n  socket.on('obs:toggleItemVisibility', async ({ sceneName, sceneItemId, enabled }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can toggle item visibility' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemEnabled', { sceneName, sceneItemId, sceneItemEnabled: enabled });\n      console.log(`[toggleItemVisibility] Set item ${sceneItemId} in ${sceneName} to ${enabled ? 'visible' : 'hidden'} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[toggleItemVisibility] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to toggle visibility: ${error.message}` });\n    }\n  });\n\n  // Toggle scene item lock\n  socket.on('obs:toggleItemLock', async ({ sceneName, sceneItemId, locked }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can toggle item lock' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemLocked', { sceneName, sceneItemId, sceneItemLocked: locked });\n      console.log(`[toggleItemLock] Set item ${sceneItemId} in ${sceneName} to ${locked ? 'locked' : 'unlocked'} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[toggleItemLock] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to toggle lock: ${error.message}` });\n    }\n  });\n\n  // Delete scene item\n  socket.on('obs:deleteSceneItem', async ({ sceneName, sceneItemId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scene items' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('RemoveSceneItem', { sceneName, sceneItemId });\n      console.log(`[deleteSceneItem] Removed item ${sceneItemId} from ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteSceneItem] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete scene item: ${error.message}` });\n    }\n  });\n\n  // Reorder scene items\n  socket.on('obs:reorderSceneItems', async ({ sceneName, sceneItemId, newIndex }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reorder scene items' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemIndex', { sceneName, sceneItemId, sceneItemIndex: newIndex });\n      console.log(`[reorderSceneItems] Moved item ${sceneItemId} to index ${newIndex} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[reorderSceneItems] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to reorder scene items: ${error.message}` });\n    }\n  });\n\n  // Apply transform preset to scene item\n  socket.on('obs:applyTransformPreset', async ({ sceneName, sceneItemId, transform }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can apply transform presets' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemTransform', { sceneName, sceneItemId, sceneItemTransform: transform });\n      console.log(`[applyTransformPreset] Applied transform to item ${sceneItemId} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[applyTransformPreset] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to apply transform: ${error.message}` });\n    }\n  });\n\n  // Add source to scene\n  socket.on('obs:addSourceToScene', async ({ sceneName, sourceName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can add sources to scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('CreateSceneItem', { sceneName, sourceName });\n      console.log(`[addSourceToScene] Added source ${sourceName} to ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[addSourceToScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to add source: ${error.message}` });\n    }\n  });\n\n  // Create a new input/source in OBS\n  socket.on('obs:createInput', async ({ inputName, inputKind, inputSettings, sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can create inputs' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // CreateInput with sceneName will create the input AND add it to the scene\n      const params = {\n        inputName,\n        inputKind,\n        inputSettings: inputSettings || {}\n      };\n\n      if (sceneName) {\n        params.sceneName = sceneName;\n      }\n\n      const result = await compObs.call('CreateInput', params);\n      console.log(`[createInput] Created input ${inputName} (${inputKind})${sceneName ? ` in scene ${sceneName}` : ''} for ${clientCompId}`, result);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[createInput] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to create input: ${error.message}` });\n    }\n  });\n\n  // Remove an input entirely from OBS (PRD-OBS-03: Source Management)\n  socket.on('obs:removeInput', async ({ inputName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can remove inputs' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // RemoveInput removes the input from OBS entirely (from all scenes)\n      await compObs.call('RemoveInput', { inputName });\n      console.log(`[removeInput] Removed input ${inputName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[removeInput] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to remove input: ${error.message}` });\n    }\n  });\n\n  // Update input settings (PRD-OBS-03: Source Management)\n  socket.on('obs:updateInputSettings', async ({ inputName, inputSettings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can update input settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // SetInputSettings with overlay: true merges with existing settings\n      await compObs.call('SetInputSettings', { inputName, inputSettings, overlay: true });\n      console.log(`[updateInputSettings] Updated settings for ${inputName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[updateInputSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to update input settings: ${error.message}` });\n    }\n  });\n\n  // Get input settings (for SourceEditor to load current values)\n  socket.on('obs:getInputSettings', async ({ inputName }, callback) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      if (callback) callback({ error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      if (callback) callback({ error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetInputSettings', { inputName });\n      console.log(`[getInputSettings] Retrieved settings for ${inputName} for ${clientCompId}`);\n      if (callback) {\n        callback({\n          inputKind: response.inputKind,\n          inputSettings: response.inputSettings\n        });\n      }\n    } catch (error) {\n      console.error(`[getInputSettings] Failed: ${error.message}`);\n      if (callback) callback({ error: error.message });\n    }\n  });\n\n  // Set scene item transform (PRD-OBS-03: Source Management)\n  socket.on('obs:setSceneItemTransform', async ({ sceneName, sceneItemId, transform }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set scene item transforms' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemTransform', { sceneName, sceneItemId, sceneItemTransform: transform });\n      console.log(`[setSceneItemTransform] Updated transform for item ${sceneItemId} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setSceneItemTransform] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set scene item transform: ${error.message}` });\n    }\n  });\n\n  // Duplicate scene\n  socket.on('obs:duplicateScene', async ({ sceneName, newSceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can duplicate scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get items from source scene\n      const { sceneItems } = await compObs.call('GetSceneItemList', { sceneName });\n\n      // Create new scene\n      await compObs.call('CreateScene', { sceneName: newSceneName });\n\n      // Add each item to new scene (in reverse order to maintain z-order)\n      for (const item of sceneItems.reverse()) {\n        try {\n          const { sceneItemId } = await compObs.call('CreateSceneItem', {\n            sceneName: newSceneName,\n            sourceName: item.sourceName\n          });\n          // Apply original transform\n          if (item.sceneItemTransform) {\n            await compObs.call('SetSceneItemTransform', {\n              sceneName: newSceneName,\n              sceneItemId,\n              sceneItemTransform: item.sceneItemTransform\n            });\n          }\n          // Apply visibility\n          await compObs.call('SetSceneItemEnabled', {\n            sceneName: newSceneName,\n            sceneItemId,\n            sceneItemEnabled: item.sceneItemEnabled\n          });\n        } catch (itemError) {\n          console.warn(`[duplicateScene] Could not copy item ${item.sourceName}: ${itemError.message}`);\n        }\n      }\n\n      console.log(`[duplicateScene] Duplicated ${sceneName} to ${newSceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[duplicateScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to duplicate scene: ${error.message}` });\n    }\n  });\n\n  // Rename scene (OBS doesn't have native rename, so we duplicate and delete)\n  socket.on('obs:renameScene', async ({ sceneName, newSceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can rename scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get items from source scene\n      const { sceneItems } = await compObs.call('GetSceneItemList', { sceneName });\n\n      // Create new scene with new name\n      await compObs.call('CreateScene', { sceneName: newSceneName });\n\n      // Copy each item to new scene\n      for (const item of sceneItems.reverse()) {\n        try {\n          const { sceneItemId } = await compObs.call('CreateSceneItem', {\n            sceneName: newSceneName,\n            sourceName: item.sourceName\n          });\n          if (item.sceneItemTransform) {\n            await compObs.call('SetSceneItemTransform', {\n              sceneName: newSceneName,\n              sceneItemId,\n              sceneItemTransform: item.sceneItemTransform\n            });\n          }\n          await compObs.call('SetSceneItemEnabled', {\n            sceneName: newSceneName,\n            sceneItemId,\n            sceneItemEnabled: item.sceneItemEnabled\n          });\n        } catch (itemError) {\n          console.warn(`[renameScene] Could not copy item ${item.sourceName}: ${itemError.message}`);\n        }\n      }\n\n      // Delete original scene\n      await compObs.call('RemoveScene', { sceneName });\n\n      console.log(`[renameScene] Renamed ${sceneName} to ${newSceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[renameScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to rename scene: ${error.message}` });\n    }\n  });\n\n  // Set audio input volume (PRD-OBS-04: Audio Management)\n  socket.on('obs:setVolume', async ({ inputName, volumeDb, volumeMul }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change volume' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Build payload - prefer volumeDb if provided, otherwise use volumeMul\n      const payload = { inputName };\n      if (volumeDb !== undefined) {\n        payload.inputVolumeDb = volumeDb;\n      } else if (volumeMul !== undefined) {\n        payload.inputVolumeMul = volumeMul;\n      } else {\n        socket.emit('error', { message: 'Must provide volumeDb or volumeMul' });\n        return;\n      }\n\n      await compObs.call('SetInputVolume', payload);\n      console.log(`[setVolume] Set ${inputName} volume to ${volumeDb !== undefined ? volumeDb + 'dB' : volumeMul} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setVolume] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set volume: ${error.message}` });\n    }\n  });\n\n  // Set audio input mute state (PRD-OBS-04: Audio Management)\n  socket.on('obs:setMute', async ({ inputName, muted }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can mute/unmute audio' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetInputMute', { inputName, inputMuted: muted });\n      console.log(`[setMute] Set ${inputName} muted=${muted} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setMute] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set mute: ${error.message}` });\n    }\n  });\n\n  // Set audio monitor type\n  socket.on('obs:setMonitorType', async ({ inputName, monitorType }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change monitor type' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetInputAudioMonitorType', { inputName, monitorType });\n      console.log(`[setMonitorType] Set ${inputName} monitor type to ${monitorType} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setMonitorType] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set monitor type: ${error.message}` });\n    }\n  });\n\n  // Subscribe/unsubscribe from real-time audio level updates (Phase 2)\n  socket.on('obs:subscribeAudioLevels', ({ enabled }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      console.log(`[subscribeAudioLevels] No compId for socket ${socket.id}`);\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n\n    if (enabled) {\n      obsConnManager.subscribeAudioLevels(clientCompId, socket.id);\n      console.log(`[subscribeAudioLevels] ${socket.id} subscribed to audio levels for ${clientCompId}`);\n    } else {\n      obsConnManager.unsubscribeAudioLevels(clientCompId, socket.id);\n      console.log(`[subscribeAudioLevels] ${socket.id} unsubscribed from audio levels for ${clientCompId}`);\n    }\n  });\n\n  // ============================================================================\n  // Audio Preset Management (PRD-OBS-04 Phase 1.5)\n  // ============================================================================\n\n  // Apply an audio preset (default or user-created)\n  socket.on('obs:applyPreset', async ({ presetId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const connection = obsConnManager.getConnection(clientCompId);\n\n    if (!connection || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      console.log(`[applyPreset] Applying preset ${presetId} for ${clientCompId}`);\n\n      // 1. Check default presets first\n      let preset = DEFAULT_PRESETS[presetId];\n\n      // 2. If not default, load from Firebase\n      if (!preset && productionConfigService.isAvailable()) {\n        const db = productionConfigService.getDb();\n        const snapshot = await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).once('value');\n        preset = snapshot.val();\n      }\n\n      if (!preset) {\n        socket.emit('obs:error', { message: `Preset not found: ${presetId}` });\n        return;\n      }\n\n      // 3. Apply each source setting via OBS WebSocket\n      const sources = Array.isArray(preset.sources) ? preset.sources : Object.values(preset.sources || {});\n      let applied = 0;\n      const errors = [];\n\n      for (const source of sources) {\n        try {\n          if (source.volumeDb !== undefined) {\n            await connection.call('SetInputVolume', {\n              inputName: source.inputName,\n              inputVolumeDb: source.volumeDb\n            });\n          }\n          if (source.muted !== undefined) {\n            await connection.call('SetInputMute', {\n              inputName: source.inputName,\n              inputMuted: source.muted\n            });\n          }\n          applied++;\n        } catch (err) {\n          console.warn(`[applyPreset] Failed to apply to ${source.inputName}: ${err.message}`);\n          errors.push({ inputName: source.inputName, error: err.message });\n        }\n      }\n\n      // 4. Broadcast state update to all clients\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n\n      // 5. Send success response\n      socket.emit('obs:presetApplied', {\n        presetId,\n        presetName: preset.name,\n        applied,\n        total: sources.length,\n        errors\n      });\n\n      console.log(`[applyPreset] Applied preset \"${preset.name}\": ${applied}/${sources.length} sources for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[applyPreset] Error applying preset ${presetId}:`, error.message);\n      socket.emit('obs:error', { message: `Failed to apply preset: ${error.message}` });\n    }\n  });\n\n  // List all audio presets (default + user-created)\n  socket.on('obs:listPresets', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    try {\n      console.log(`[listPresets] Listing presets for ${clientCompId}`);\n\n      // Get default presets\n      const defaultPresets = Object.values(DEFAULT_PRESETS).map(p => ({\n        ...p,\n        isDefault: true\n      }));\n\n      // Get user presets from Firebase\n      let userPresets = [];\n      if (productionConfigService.isAvailable()) {\n        const db = productionConfigService.getDb();\n        const snapshot = await db.ref(`competitions/${clientCompId}/obs/presets`).once('value');\n        const presetsData = snapshot.val();\n        if (presetsData) {\n          userPresets = Object.entries(presetsData).map(([id, preset]) => ({\n            ...preset,\n            id,\n            isDefault: false\n          }));\n        }\n      }\n\n      const allPresets = [...defaultPresets, ...userPresets];\n      socket.emit('obs:presetsList', { presets: allPresets });\n\n      console.log(`[listPresets] Sent ${allPresets.length} presets (${defaultPresets.length} default, ${userPresets.length} user) for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[listPresets] Error listing presets:`, error.message);\n      socket.emit('obs:error', { message: `Failed to list presets: ${error.message}` });\n    }\n  });\n\n  // Save current audio mix as a new preset\n  socket.on('obs:savePreset', async ({ name, description, sources }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('obs:error', { message: 'Firebase not available' });\n      return;\n    }\n\n    if (!name || !sources || Object.keys(sources).length === 0) {\n      socket.emit('obs:error', { message: 'Name and sources are required' });\n      return;\n    }\n\n    try {\n      console.log(`[savePreset] Saving preset \"${name}\" for ${clientCompId}`);\n\n      const db = productionConfigService.getDb();\n      const presetId = `user-${Date.now()}`;\n\n      // Convert sources object to array format\n      const sourcesArray = Object.entries(sources).map(([inputName, settings]) => ({\n        inputName,\n        ...settings\n      }));\n\n      const preset = {\n        id: presetId,\n        name,\n        description: description || '',\n        sources: sourcesArray,\n        createdAt: new Date().toISOString(),\n        isDefault: false\n      };\n\n      await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).set(preset);\n\n      socket.emit('obs:presetSaved', { preset });\n      console.log(`[savePreset] Saved preset \"${name}\" (${presetId}) for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[savePreset] Error saving preset:`, error.message);\n      socket.emit('obs:error', { message: `Failed to save preset: ${error.message}` });\n    }\n  });\n\n  // Delete a user-created preset\n  socket.on('obs:deletePreset', async ({ presetId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('obs:error', { message: 'Firebase not available' });\n      return;\n    }\n\n    // Prevent deletion of default presets\n    if (DEFAULT_PRESETS[presetId]) {\n      socket.emit('obs:error', { message: 'Cannot delete default presets' });\n      return;\n    }\n\n    try {\n      console.log(`[deletePreset] Deleting preset ${presetId} for ${clientCompId}`);\n\n      const db = productionConfigService.getDb();\n      await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).remove();\n\n      socket.emit('obs:presetDeleted', { presetId });\n      console.log(`[deletePreset] Deleted preset ${presetId} for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[deletePreset] Error deleting preset:`, error.message);\n      socket.emit('obs:error', { message: `Failed to delete preset: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Transition Management (PRD-OBS-05)\n  // ============================================================================\n\n  // Get available transitions\n  socket.on('obs:getTransitions', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetSceneTransitionList');\n      const transitions = (response.transitions || []).map(t => ({\n        name: t.transitionName,\n        kind: t.transitionKind,\n        configurable: t.transitionConfigurable || false\n      }));\n      socket.emit('obs:transitionsList', {\n        transitions,\n        currentTransition: response.currentSceneTransitionName,\n        transitionDuration: response.currentSceneTransitionDuration || 300\n      });\n      console.log(`[getTransitions] Sent ${transitions.length} transitions for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[getTransitions] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get transitions: ${error.message}` });\n    }\n  });\n\n  // Set current transition (PRD-OBS-05)\n  socket.on('obs:setCurrentTransition', async ({ transitionName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transitions' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransition', { transitionName });\n      console.log(`[setCurrentTransition] Set transition to ${transitionName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setCurrentTransition] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition: ${error.message}` });\n    }\n  });\n\n  // Set transition duration (PRD-OBS-05)\n  socket.on('obs:setTransitionDuration', async ({ transitionDuration }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transition duration' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransitionDuration', { transitionDuration });\n      console.log(`[setTransitionDuration] Set duration to ${transitionDuration}ms for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setTransitionDuration] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition duration: ${error.message}` });\n    }\n  });\n\n  // Set transition settings (PRD-OBS-05)\n  socket.on('obs:setTransitionSettings', async ({ transitionName, transitionSettings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transition settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransitionSettings', {\n        transitionSettings,\n        overlay: true\n      });\n      console.log(`[setTransitionSettings] Updated settings for ${transitionName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setTransitionSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition settings: ${error.message}` });\n    }\n  });\n\n  // Get transition settings (PRD-OBS-11: Stinger Transitions)\n  socket.on('obs:getTransitionSettings', async ({ transitionName }, callback) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      if (callback) callback({ error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      if (callback) callback({ error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetCurrentSceneTransitionSettings');\n      console.log(`[getTransitionSettings] Retrieved settings for ${transitionName} for ${clientCompId}`);\n      if (callback) {\n        callback({\n          transitionName: response.transitionName,\n          transitionSettings: response.transitionSettings,\n          transitionKind: response.transitionKind\n        });\n      }\n    } catch (error) {\n      console.error(`[getTransitionSettings] Failed: ${error.message}`);\n      if (callback) callback({ error: `Failed to get transition settings: ${error.message}` });\n    }\n  });\n\n  // Take screenshot of current output\n  socket.on('obs:takeScreenshot', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can take screenshots' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get current program scene name\n      const { currentProgramSceneName } = await compObs.call('GetCurrentProgramScene');\n\n      // Take screenshot of the current program scene\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: currentProgramSceneName,\n        imageFormat: 'png',\n        imageWidth: 1920,\n        imageHeight: 1080\n      });\n\n      console.log(`[takeScreenshot] Captured screenshot of ${currentProgramSceneName} for ${clientCompId}`);\n\n      // Emit screenshot data back to the client (base64 encoded PNG)\n      socket.emit('obs:screenshotCaptured', {\n        imageData: response.imageData,\n        sceneName: currentProgramSceneName,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error(`[takeScreenshot] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to take screenshot: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Preview System (PRD-OBS-09)\n  // ============================================================================\n\n  // Request screenshot for preview (with configurable options)\n  socket.on('obs:requestScreenshot', async (options = {}) => {\n    const { sceneName = null, imageWidth = 640, imageHeight = 360, imageFormat = 'jpg' } = options;\n\n    // Get compId from socket handshake query (same as other handlers)\n    const clientCompId = socket.handshake?.query?.compId;\n    if (!clientCompId) {\n      socket.emit('obs:screenshotError', { error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:screenshotError', { error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get target scene name - use provided sceneName or get current program scene\n      let targetScene = sceneName;\n      if (!targetScene) {\n        const { currentProgramSceneName } = await compObs.call('GetCurrentProgramScene');\n        targetScene = currentProgramSceneName;\n      }\n\n      // Take screenshot with specified options\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: targetScene,\n        imageFormat: imageFormat === 'jpg' ? 'jpeg' : imageFormat,\n        imageWidth,\n        imageHeight\n      });\n\n      console.log(`[requestScreenshot] Captured ${imageWidth}x${imageHeight} ${imageFormat} of ${targetScene} for ${clientCompId}`);\n\n      // Emit screenshot data back to the requesting client\n      socket.emit('obs:screenshotData', {\n        success: true,\n        imageData: response.imageData,\n        sceneName: targetScene,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error(`[requestScreenshot] Failed: ${error.message}`);\n      socket.emit('obs:screenshotError', {\n        error: error.message,\n        sceneName\n      });\n    }\n  });\n\n  // Request scene thumbnail (PRD-OBS-11: Scene Thumbnails)\n  socket.on('obs:requestSceneThumbnail', async (options = {}) => {\n    const { sceneName, imageWidth = 80, imageHeight = 45, isHoverPreview = false } = options;\n\n    if (!sceneName) {\n      socket.emit('obs:sceneThumbnailError', { error: 'Scene name required', sceneName, isHoverPreview });\n      return;\n    }\n\n    // Get compId from socket handshake query\n    const clientCompId = socket.handshake?.query?.compId;\n    if (!clientCompId) {\n      socket.emit('obs:sceneThumbnailError', { error: 'No competition ID', sceneName, isHoverPreview });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:sceneThumbnailError', { error: 'OBS not connected', sceneName, isHoverPreview });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: sceneName,\n        imageFormat: 'jpeg',\n        imageWidth,\n        imageHeight\n      });\n\n      socket.emit('obs:sceneThumbnailData', {\n        success: true,\n        imageData: response.imageData,\n        sceneName,\n        isHoverPreview,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error(`[requestSceneThumbnail] Failed for ${sceneName}: ${error.message}`);\n      socket.emit('obs:sceneThumbnailError', {\n        error: error.message,\n        sceneName,\n        isHoverPreview\n      });\n    }\n  });\n\n  // ============================================================================\n  // Studio Mode (PRD-OBS-11: Advanced Features)\n  // ============================================================================\n\n  // Enable studio mode\n  socket.on('obs:enableStudioMode', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can enable studio mode' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStudioModeEnabled', { studioModeEnabled: true });\n      console.log(`[enableStudioMode] Studio mode enabled for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[enableStudioMode] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to enable studio mode: ${error.message}` });\n    }\n  });\n\n  // Disable studio mode\n  socket.on('obs:disableStudioMode', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can disable studio mode' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStudioModeEnabled', { studioModeEnabled: false });\n      console.log(`[disableStudioMode] Studio mode disabled for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[disableStudioMode] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to disable studio mode: ${error.message}` });\n    }\n  });\n\n  // Set preview scene (only works in studio mode)\n  socket.on('obs:setPreviewScene', async ({ sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set preview scene' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentPreviewScene', { sceneName });\n      console.log(`[setPreviewScene] Preview scene set to ${sceneName} for ${clientCompId}`);\n      // Broadcast updated state (will include new previewScene)\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setPreviewScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set preview scene: ${error.message}` });\n    }\n  });\n\n  // Transition preview to program (only works in studio mode)\n  socket.on('obs:transitionToProgram', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can transition to program' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('TriggerStudioModeTransition');\n      console.log(`[transitionToProgram] Triggered transition for ${clientCompId}`);\n      // State will be updated by OBS events (CurrentProgramSceneChanged, etc.)\n    } catch (error) {\n      console.error(`[transitionToProgram] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to transition: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Template Auto-Loading (PRD-OBS-11)\n  // ============================================================================\n\n  // Set a template as default for specific meet types\n  socket.on('obs:setTemplateDefault', async ({ templateId, meetTypes }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set template defaults' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!templateId || !Array.isArray(meetTypes) || meetTypes.length === 0) {\n      socket.emit('error', { message: 'Template ID and meet types array are required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        socket.emit('error', { message: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n\n      // Get the template to verify it exists\n      const templateRef = database.ref(`templates/obs/${templateId}`);\n      const templateSnapshot = await templateRef.once('value');\n      const template = templateSnapshot.val();\n\n      if (!template) {\n        socket.emit('error', { message: `Template not found: ${templateId}` });\n        return;\n      }\n\n      // Clear this default from any other templates for the same meet types\n      const allTemplatesRef = database.ref('templates/obs');\n      const allTemplatesSnapshot = await allTemplatesRef.once('value');\n      const allTemplates = allTemplatesSnapshot.val() || {};\n\n      for (const [otherTemplateId, otherTemplate] of Object.entries(allTemplates)) {\n        if (otherTemplateId !== templateId && otherTemplate.isDefaultFor) {\n          // Remove overlapping meet types from other templates\n          const updatedIsDefaultFor = otherTemplate.isDefaultFor.filter(mt => !meetTypes.includes(mt));\n          if (updatedIsDefaultFor.length !== otherTemplate.isDefaultFor.length) {\n            await database.ref(`templates/obs/${otherTemplateId}/isDefaultFor`).set(\n              updatedIsDefaultFor.length > 0 ? updatedIsDefaultFor : null\n            );\n            console.log(`[setTemplateDefault] Cleared ${meetTypes.filter(mt => otherTemplate.isDefaultFor.includes(mt)).join(', ')} from ${otherTemplateId}`);\n          }\n        }\n      }\n\n      // Set the new default\n      const currentIsDefaultFor = template.isDefaultFor || [];\n      const newIsDefaultFor = [...new Set([...currentIsDefaultFor, ...meetTypes])];\n      await templateRef.update({\n        isDefaultFor: newIsDefaultFor,\n        updatedAt: new Date().toISOString()\n      });\n\n      console.log(`[setTemplateDefault] Set ${templateId} as default for ${meetTypes.join(', ')}`);\n\n      // Notify all clients in this competition room\n      io.to(`competition:${clientCompId}`).emit('obs:templateDefaultChanged', {\n        templateId,\n        meetTypes: newIsDefaultFor,\n        action: 'set'\n      });\n\n      socket.emit('obs:templateDefaultSet', { templateId, meetTypes: newIsDefaultFor });\n    } catch (error) {\n      console.error(`[setTemplateDefault] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set template default: ${error.message}` });\n    }\n  });\n\n  // Clear a template's default status for specific meet types\n  socket.on('obs:clearTemplateDefault', async ({ templateId, meetTypes }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can clear template defaults' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!templateId || !Array.isArray(meetTypes) || meetTypes.length === 0) {\n      socket.emit('error', { message: 'Template ID and meet types array are required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        socket.emit('error', { message: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n      const templateRef = database.ref(`templates/obs/${templateId}`);\n      const templateSnapshot = await templateRef.once('value');\n      const template = templateSnapshot.val();\n\n      if (!template) {\n        socket.emit('error', { message: `Template not found: ${templateId}` });\n        return;\n      }\n\n      // Remove the specified meet types from isDefaultFor\n      const currentIsDefaultFor = template.isDefaultFor || [];\n      const newIsDefaultFor = currentIsDefaultFor.filter(mt => !meetTypes.includes(mt));\n\n      await templateRef.update({\n        isDefaultFor: newIsDefaultFor.length > 0 ? newIsDefaultFor : null,\n        updatedAt: new Date().toISOString()\n      });\n\n      console.log(`[clearTemplateDefault] Cleared ${meetTypes.join(', ')} from ${templateId}`);\n\n      // Notify all clients in this competition room\n      io.to(`competition:${clientCompId}`).emit('obs:templateDefaultChanged', {\n        templateId,\n        meetTypes: newIsDefaultFor,\n        action: 'clear'\n      });\n\n      socket.emit('obs:templateDefaultCleared', { templateId, meetTypes: newIsDefaultFor });\n    } catch (error) {\n      console.error(`[clearTemplateDefault] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to clear template default: ${error.message}` });\n    }\n  });\n\n  // Get the default template for a specific meet type\n  socket.on('obs:getDefaultTemplate', async ({ meetType }, callback) => {\n    if (!meetType) {\n      if (callback) callback({ error: 'Meet type is required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        if (callback) callback({ error: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n      const templatesRef = database.ref('templates/obs');\n      const templatesSnapshot = await templatesRef.once('value');\n      const templates = templatesSnapshot.val() || {};\n\n      // Find templates that are default for this meet type\n      const defaultTemplates = Object.values(templates).filter(\n        t => t.isDefaultFor && t.isDefaultFor.includes(meetType)\n      );\n\n      if (defaultTemplates.length === 0) {\n        console.log(`[getDefaultTemplate] No default template for ${meetType}`);\n        if (callback) callback({ template: null });\n        return;\n      }\n\n      // If multiple defaults, use the most recently updated one\n      const defaultTemplate = defaultTemplates.sort((a, b) =>\n        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)\n      )[0];\n\n      console.log(`[getDefaultTemplate] Found default template \"${defaultTemplate.name}\" for ${meetType}`);\n      if (callback) callback({ template: defaultTemplate });\n    } catch (error) {\n      console.error(`[getDefaultTemplate] Failed: ${error.message}`);\n      if (callback) callback({ error: error.message });\n    }\n  });\n\n  // ============================================================================\n  // Stream & Recording Control (PRD-OBS-06)\n  // ============================================================================\n\n  // Start streaming\n  socket.on('obs:startStream', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can start streaming' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StartStream');\n      console.log(`[startStream] Started streaming for ${clientCompId}`);\n      socket.emit('obs:streamStarted');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[startStream] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to start stream: ${error.message}` });\n    }\n  });\n\n  // Stop streaming\n  socket.on('obs:stopStream', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can stop streaming' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StopStream');\n      console.log(`[stopStream] Stopped streaming for ${clientCompId}`);\n      socket.emit('obs:streamStopped');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[stopStream] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to stop stream: ${error.message}` });\n    }\n  });\n\n  // Get stream status\n  socket.on('obs:getStreamStatus', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetStreamStatus');\n      socket.emit('obs:streamStatus', {\n        active: response.outputActive,\n        reconnecting: response.outputReconnecting || false,\n        timecode: response.outputTimecode || '00:00:00.000',\n        duration: response.outputDuration || 0,\n        bytes: response.outputBytes || 0,\n        skippedFrames: response.outputSkippedFrames || 0,\n        totalFrames: response.outputTotalFrames || 0\n      });\n      console.log(`[getStreamStatus] Sent stream status for ${clientCompId} (active: ${response.outputActive})`);\n    } catch (error) {\n      console.error(`[getStreamStatus] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get stream status: ${error.message}` });\n    }\n  });\n\n  // Get stream settings\n  socket.on('obs:getStreamSettings', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetStreamServiceSettings');\n      // Mask the stream key\n      const settings = { ...response.streamServiceSettings };\n      if (settings.key) {\n        settings.key = '****' + settings.key.slice(-4);\n      }\n      socket.emit('obs:streamSettings', {\n        serviceType: response.streamServiceType,\n        settings\n      });\n      console.log(`[getStreamSettings] Sent stream settings for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[getStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get stream settings: ${error.message}` });\n    }\n  });\n\n  // Set stream settings\n  socket.on('obs:setStreamSettings', async ({ serviceType, settings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change stream settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStreamServiceSettings', {\n        streamServiceType: serviceType,\n        streamServiceSettings: settings\n      });\n      console.log(`[setStreamSettings] Updated stream settings for ${clientCompId} (type: ${serviceType})`);\n\n      // Store encrypted stream key in Firebase for backup/recovery\n      if (settings?.key && productionConfigService.isAvailable()) {\n        try {\n          const encryptedKey = encryptStreamKey(settings.key);\n          const db = productionConfigService.getDb();\n          if (db) {\n            await db.ref(`competitions/${clientCompId}/obs/streamConfig`).update({\n              streamKeyEncrypted: encryptedKey,\n              serviceType: serviceType,\n              server: settings.server || null,\n              lastUpdated: new Date().toISOString()\n            });\n            console.log(`[setStreamSettings] Stored encrypted stream key in Firebase for ${clientCompId}`);\n          }\n        } catch (fbError) {\n          // Don't fail the request if Firebase storage fails - OBS was still updated\n          console.warn(`[setStreamSettings] Failed to store encrypted key in Firebase: ${fbError.message}`);\n        }\n      }\n\n      socket.emit('obs:streamSettingsUpdated', { success: true });\n    } catch (error) {\n      console.error(`[setStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set stream settings: ${error.message}` });\n    }\n  });\n\n  // Restore stream settings from Firebase backup\n  socket.on('obs:restoreStreamSettings', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can restore stream settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('error', { message: 'Firebase not available' });\n      return;\n    }\n\n    try {\n      const db = productionConfigService.getDb();\n      const snapshot = await db.ref(`competitions/${clientCompId}/obs/streamConfig`).once('value');\n      const config = snapshot.val();\n\n      if (!config || !config.streamKeyEncrypted) {\n        socket.emit('error', { message: 'No stored stream configuration found' });\n        return;\n      }\n\n      // Decrypt the stream key\n      const decryptedKey = decryptStreamKey(config.streamKeyEncrypted);\n\n      // Build settings object\n      const settings = { key: decryptedKey };\n      if (config.server) {\n        settings.server = config.server;\n      }\n\n      // Apply to OBS\n      await compObs.call('SetStreamServiceSettings', {\n        streamServiceType: config.serviceType || 'rtmp_common',\n        streamServiceSettings: settings\n      });\n\n      console.log(`[restoreStreamSettings] Restored stream settings from Firebase for ${clientCompId}`);\n      socket.emit('obs:streamSettingsRestored', { success: true, lastUpdated: config.lastUpdated });\n    } catch (error) {\n      console.error(`[restoreStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to restore stream settings: ${error.message}` });\n    }\n  });\n\n  // Delete stored stream key from Firebase\n  socket.on('obs:deleteStoredStreamKey', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete stream keys' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('error', { message: 'Firebase not available' });\n      return;\n    }\n\n    try {\n      const db = productionConfigService.getDb();\n      await db.ref(`competitions/${clientCompId}/obs/streamConfig/streamKeyEncrypted`).remove();\n      console.log(`[deleteStoredStreamKey] Deleted stored stream key for ${clientCompId}`);\n      socket.emit('obs:storedStreamKeyDeleted', { success: true });\n    } catch (error) {\n      console.error(`[deleteStoredStreamKey] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete stored stream key: ${error.message}` });\n    }\n  });\n\n  // Start recording\n  socket.on('obs:startRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can start recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StartRecord');\n      console.log(`[startRecording] Started recording for ${clientCompId}`);\n      socket.emit('obs:recordingStarted');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[startRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to start recording: ${error.message}` });\n    }\n  });\n\n  // Stop recording\n  socket.on('obs:stopRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can stop recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const result = await compObs.call('StopRecord');\n      console.log(`[stopRecording] Stopped recording for ${clientCompId}, file: ${result.outputPath}`);\n      socket.emit('obs:recordingStopped', { path: result.outputPath });\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[stopRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to stop recording: ${error.message}` });\n    }\n  });\n\n  // Pause recording\n  socket.on('obs:pauseRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can pause recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('PauseRecord');\n      console.log(`[pauseRecording] Paused recording for ${clientCompId}`);\n      socket.emit('obs:recordingPaused');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[pauseRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to pause recording: ${error.message}` });\n    }\n  });\n\n  // Resume recording\n  socket.on('obs:resumeRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can resume recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('ResumeRecord');\n      console.log(`[resumeRecording] Resumed recording for ${clientCompId}`);\n      socket.emit('obs:recordingResumed');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[resumeRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to resume recording: ${error.message}` });\n    }\n  });\n\n  // Get recording status\n  socket.on('obs:getRecordingStatus', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetRecordStatus');\n      socket.emit('obs:recordingStatus', {\n        active: response.outputActive,\n        paused: response.outputPaused || false,\n        timecode: response.outputTimecode || '00:00:00.000',\n        duration: response.outputDuration || 0,\n        bytes: response.outputBytes || 0\n      });\n      console.log(`[getRecordingStatus] Sent recording status for ${clientCompId} (active: ${response.outputActive}, paused: ${response.outputPaused})`);\n    } catch (error) {\n      console.error(`[getRecordingStatus] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get recording status: ${error.message}` });\n    }\n  });\n\n  // Toggle talent lock\n  socket.on('lockTalent', ({ locked }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can lock talent controls' });\n      return;\n    }\n\n    showState.talentLocked = locked;\n    console.log(`Talent controls ${locked ? 'locked' : 'unlocked'}`);\n    broadcastState();\n  });\n\n  // Toggle pause\n  socket.on('togglePause', () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can pause the show' });\n      return;\n    }\n\n    showState.isPaused = !showState.isPaused;\n\n    if (showState.isPaused) {\n      clearAutoAdvance();\n    } else if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n      // Resume auto-advance with remaining time\n      const elapsed = (Date.now() - showState.segmentStartTime) / 1000;\n      const remaining = showState.currentSegment.duration - elapsed;\n      if (remaining > 0) {\n        setupAutoAdvance(remaining);\n      }\n    }\n\n    console.log(`Show ${showState.isPaused ? 'paused' : 'resumed'}`);\n    broadcastState();\n  });\n\n  // Trigger graphic manually\n  socket.on('triggerGraphic', ({ graphic, data }) => {\n    io.emit('triggerGraphic', { graphic, data });\n    console.log(`Triggered graphic: ${graphic}`);\n  });\n\n  // Clear graphic\n  socket.on('clearGraphic', () => {\n    io.emit('clearGraphic');\n    console.log('Cleared graphic');\n  });\n\n  // OBS State Sync: Refresh full state from OBS\n  socket.on('obs:refreshState', async () => {\n    console.log(`[obs:refreshState] Request from client, compId: ${clientCompId || 'none'}`);\n\n    // First, try competition-based OBS connection (via obsConnectionManager)\n    if (clientCompId && clientCompId !== 'local') {\n      const obsConnManager = getOBSConnectionManager();\n      const connState = obsConnManager.getConnectionState(clientCompId);\n      console.log(`[obs:refreshState] Connection state for ${clientCompId}:`, connState ? { connected: connState.connected, error: connState.error } : 'null');\n\n      if (connState && connState.connected) {\n        try {\n          console.log(`[obs:refreshState] Broadcasting full state for competition ${clientCompId}`);\n          await broadcastOBSState(clientCompId, obsConnManager, io);\n          return;\n        } catch (error) {\n          console.error(`[obs:refreshState] Failed to refresh OBS state for ${clientCompId}:`, error);\n          socket.emit('error', { message: 'Failed to refresh OBS state' });\n          return;\n        }\n      } else {\n        console.log(`[obs:refreshState] OBS not connected for ${clientCompId}, falling back to local`);\n      }\n    }\n\n    // Fall back to local obsStateSync\n    if (obsStateSync && obsStateSync.isInitialized()) {\n      try {\n        console.log('Client requested OBS state refresh (local)');\n        await obsStateSync.refreshFullState();\n      } catch (error) {\n        console.error('Failed to refresh OBS state:', error);\n        socket.emit('error', { message: 'Failed to refresh OBS state' });\n      }\n    } else {\n      console.warn('OBS State Sync not initialized, cannot refresh state');\n      socket.emit('error', { message: 'OBS State Sync not initialized' });\n    }\n  });\n\n  // ============================================\n  // Camera Management Socket Events\n  // ============================================\n\n  // Reassign apparatus to a camera\n  socket.on('reassignApparatus', ({ cameraId, apparatus, assignedBy }) => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    if (!apparatus || !Array.isArray(apparatus)) {\n      socket.emit('error', { message: 'apparatus must be an array of apparatus codes' });\n      return;\n    }\n    const result = cameraRuntimeState.reassignApparatus(cameraId, apparatus, assignedBy || socket.id);\n    if (!result) {\n      socket.emit('error', { message: `Camera not found: ${cameraId}` });\n      return;\n    }\n    console.log(`Socket: Apparatus reassigned for camera ${cameraId} to [${apparatus.join(', ')}]`);\n  });\n\n  // Verify a camera\n  socket.on('verifyCamera', ({ cameraId, verifiedBy }) => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    const result = cameraRuntimeState.verifyCamera(cameraId, verifiedBy || socket.id);\n    if (!result) {\n      socket.emit('error', { message: `Camera not found: ${cameraId}` });\n      return;\n    }\n    console.log(`Socket: Camera ${cameraId} verified by ${verifiedBy || socket.id}`);\n  });\n\n  // Clear fallback for a camera\n  socket.on('clearFallback', ({ cameraId }) => {\n    if (!cameraFallbackManager) {\n      socket.emit('error', { message: 'Camera fallback manager not initialized' });\n      return;\n    }\n    const result = cameraFallbackManager.clearFallback(cameraId);\n    if (!result.success) {\n      socket.emit('error', { message: result.error });\n      return;\n    }\n    console.log(`Socket: Fallback cleared for camera ${cameraId}`);\n  });\n\n  // Reset all camera verifications\n  socket.on('resetVerifications', () => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    cameraRuntimeState.resetAllVerifications();\n    console.log('Socket: All camera verifications reset');\n  });\n\n  // ============================================\n  // Timesheet Engine Socket Events\n  // ============================================\n\n  // Start show via timesheet engine\n  socket.on('startTimesheetShow', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    await timesheetEngine.start();\n    console.log('Socket: Timesheet show started');\n  });\n\n  // Stop show via timesheet engine\n  socket.on('stopTimesheetShow', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    timesheetEngine.stop();\n    console.log('Socket: Timesheet show stopped');\n  });\n\n  // Advance to next segment via timesheet engine\n  socket.on('advanceSegment', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const advancedBy = client?.name || socket.id;\n    const success = await timesheetEngine.advance(advancedBy);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot advance segment' });\n    }\n    console.log(`Socket: Segment advanced by ${advancedBy}`);\n  });\n\n  // Go to previous segment via timesheet engine\n  socket.on('previousSegment', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.previous(triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot go to previous segment' });\n    }\n    console.log(`Socket: Previous segment triggered by ${triggeredBy}`);\n  });\n\n  // Jump to specific segment via timesheet engine\n  socket.on('goToSegment', async ({ segmentId }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    if (!segmentId) {\n      socket.emit('error', { message: 'segmentId is required' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.goToSegment(segmentId, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Cannot jump to segment: ${segmentId}` });\n    }\n    console.log(`Socket: Jump to segment ${segmentId} by ${triggeredBy}`);\n  });\n\n  // Override scene via timesheet engine (producer only)\n  socket.on('timesheetOverrideScene', async ({ sceneName }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override scenes' });\n      return;\n    }\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.overrideScene(sceneName, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Failed to override scene: ${sceneName}` });\n    }\n    console.log(`Socket: Scene overridden to ${sceneName} by ${triggeredBy}`);\n  });\n\n  // Override camera via timesheet engine (producer only)\n  socket.on('overrideCamera', async ({ cameraId }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override cameras' });\n      return;\n    }\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.overrideCamera(cameraId, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Failed to override camera: ${cameraId}` });\n    }\n    console.log(`Socket: Camera overridden to ${cameraId} by ${triggeredBy}`);\n  });\n\n  // Get current timesheet state\n  socket.on('getTimesheetState', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  // Get timesheet overrides history\n  socket.on('getTimesheetOverrides', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetOverrides', timesheetEngine.getOverrides());\n  });\n\n  // Get timesheet segment history\n  socket.on('getTimesheetHistory', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetHistory', timesheetEngine.getHistory());\n  });\n\n  // Start the show\n  socket.on('startShow', async () => {\n    showState.isPlaying = true;\n    showState.isPaused = false;\n    showState.currentSegmentIndex = 0;\n    updateCurrentSegment();\n    showState.segmentStartTime = Date.now();\n\n    if (showState.currentSegment?.obsScene) {\n      await switchScene(showState.currentSegment.obsScene);\n    }\n\n    if (showState.currentSegment?.graphic) {\n      io.emit('triggerGraphic', {\n        graphic: showState.currentSegment.graphic,\n        data: showState.currentSegment.graphicData || {}\n      });\n    }\n\n    if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n      setupAutoAdvance(showState.currentSegment.duration);\n    }\n\n    console.log('Show started');\n    broadcastState();\n  });\n\n  // Reset show\n  socket.on('resetShow', () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reset the show' });\n      return;\n    }\n\n    clearAutoAdvance();\n    showState.isPlaying = false;\n    showState.isPaused = false;\n    showState.currentSegmentIndex = 0;\n    showState.segmentStartTime = null;\n    showState.segmentElapsed = 0;\n    updateCurrentSegment();\n\n    console.log('Show reset');\n    broadcastState();\n  });\n\n  // =====================================================\n  // VM Pool Socket Events (P15-03)\n  // =====================================================\n\n  // Assign a VM to a competition\n  socket.on('assignVM', async ({ competitionId, preferredVmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.assignVM(competitionId, preferredVmId);\n      // vmAssigned event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmAssignmentResult', result);\n    } catch (error) {\n      console.error(`[Socket] assignVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        competitionId\n      });\n    }\n  });\n\n  // Release a VM from a competition\n  socket.on('releaseVM', async ({ competitionId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.releaseVM(competitionId);\n      // vmReleased event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmReleaseResult', result);\n    } catch (error) {\n      console.error(`[Socket] releaseVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        competitionId\n      });\n    }\n  });\n\n  // Start a stopped VM\n  socket.on('startVM', async ({ vmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.startVM(vmId);\n      // vmStarting event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmStartResult', result);\n    } catch (error) {\n      console.error(`[Socket] startVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        vmId\n      });\n    }\n  });\n\n  // Stop a VM\n  socket.on('stopVM', async ({ vmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.stopVM(vmId);\n      // vmStopping event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmStopResult', result);\n    } catch (error) {\n      console.error(`[Socket] stopVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        vmId\n      });\n    }\n  });\n\n  // Acknowledge an alert (placeholder for P17)\n  socket.on('acknowledgeAlert', ({ competitionId, alertId }) => {\n    console.log(`[Socket] acknowledgeAlert: competition=${competitionId}, alert=${alertId}`);\n    // Alert service will be implemented in P17-01\n    // For now, just acknowledge receipt\n    socket.emit('alertAcknowledged', { competitionId, alertId });\n  });\n\n  // Request current VM pool status\n  socket.on('getVMPoolStatus', () => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmPoolStatus', {\n          initialized: false,\n          vms: [],\n          counts: { total: 0 }\n        });\n        return;\n      }\n\n      socket.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n    } catch (error) {\n      console.error(`[Socket] getVMPoolStatus failed:`, error.message);\n      socket.emit('vmError', { error: error.message });\n    }\n  });\n\n  // Disconnect handling\n  socket.on('disconnect', () => {\n    console.log(`Client disconnected: ${socket.id}`);\n\n    // Clean up audio level subscriptions\n    const obsConnManager = getOBSConnectionManager();\n    obsConnManager.unsubscribeAudioLevelsAll(socket.id);\n\n    showState.connectedClients = showState.connectedClients.filter(c => c.id !== socket.id);\n    broadcastState();\n  });\n});\n\n// Update segment elapsed time every second\nsetInterval(() => {\n  if (showState.isPlaying && !showState.isPaused && showState.segmentStartTime) {\n    showState.segmentElapsed = Math.floor((Date.now() - showState.segmentStartTime) / 1000);\n    io.emit('timeUpdate', { elapsed: showState.segmentElapsed });\n  }\n}, 1000);\n\n// Initialize OBS Connection Manager event forwarding\nfunction initializeOBSConnectionManager() {\n  const obsConnManager = getOBSConnectionManager();\n\n  // Forward OBS events to the appropriate competition room\n  obsConnManager.on('obsEvent', ({ compId, eventName, data }) => {\n    const room = `competition:${compId}`;\n    console.log(`[OBSConnManager] Forwarding ${eventName} to room ${room}`);\n\n    // Map OBS events to Socket.io events\n    switch (eventName) {\n      case 'CurrentProgramSceneChanged':\n        io.to(room).emit('sceneChanged', data.sceneName);\n        io.to(room).emit('obs:currentSceneChanged', { sceneName: data.sceneName });\n        break;\n      case 'SceneListChanged':\n        io.to(room).emit('obs:sceneListChanged', data);\n        break;\n      case 'InputVolumeChanged':\n        io.to(room).emit('obs:volumeChanged', {\n          inputName: data.inputName,\n          volumeDb: data.inputVolumeDb,\n          volumeMul: data.inputVolumeMul\n        });\n        break;\n      case 'InputMuteStateChanged':\n        io.to(room).emit('obs:muteChanged', {\n          inputName: data.inputName,\n          muted: data.inputMuted\n        });\n        break;\n      case 'StreamStateChanged':\n        io.to(room).emit('obs:streamStateChanged', {\n          active: data.outputActive,\n          state: data.outputState\n        });\n        break;\n      case 'RecordStateChanged':\n        io.to(room).emit('obs:recordStateChanged', {\n          active: data.outputActive,\n          state: data.outputState\n        });\n        break;\n      case 'StudioModeStateChanged':\n        io.to(room).emit('obs:studioModeChanged', {\n          studioModeEnabled: data.studioModeEnabled\n        });\n        break;\n      case 'CurrentPreviewSceneChanged':\n        io.to(room).emit('obs:previewSceneChanged', {\n          sceneName: data.sceneName\n        });\n        break;\n      default:\n        // Forward unknown events generically\n        io.to(room).emit(`obs:${eventName}`, data);\n    }\n  });\n\n  // Handle connection events\n  obsConnManager.on('connected', async ({ compId, vmAddress }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:connected', { connected: true, vmAddress });\n\n    // Fetch and broadcast OBS state when connected\n    await broadcastOBSState(compId, obsConnManager, io);\n  });\n\n  obsConnManager.on('disconnected', ({ compId }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:disconnected', { connected: false });\n  });\n\n  // Handle unexpected connection loss (TCP close or heartbeat failure)\n  obsConnManager.on('connectionClosed', ({ compId }) => {\n    const room = `competition:${compId}`;\n    console.log(`[OBS] Connection closed for ${compId}, notifying clients`);\n    io.to(room).emit('obs:disconnected', { connected: false });\n  });\n\n  obsConnManager.on('connectionError', ({ compId, error }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:error', { error });\n  });\n\n  // Forward audio levels to competition room (Phase 2 - Real-time audio meters)\n  obsConnManager.on('audioLevels', ({ compId, levels }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:audioLevels', levels);\n  });\n\n  console.log('[Server] OBS Connection Manager initialized');\n}\n\n// Start server\nhttpServer.listen(PORT, () => {\n  console.log(`Show Controller Server running on port ${PORT}`);\n  console.log(`Talent View: http://localhost:${PORT}/talent`);\n  console.log(`Producer View: http://localhost:${PORT}/producer`);\n\n  // Load and validate show config (exit if invalid on startup)\n  loadShowConfig(true);\n\n  // Initialize camera management modules\n  initializeCameraModules();\n\n  // Initialize OBS scene generator\n  initializeSceneGenerator();\n\n  // Initialize timesheet engine\n  initializeTimesheetEngine();\n\n  // Initialize VM pool manager (for VM management features)\n  initializeVMPoolManager();\n\n  // Initialize auto-shutdown service (for coordinator mode)\n  initializeAutoShutdown();\n\n  // Initialize OBS Connection Manager for per-competition OBS connections\n  initializeOBSConnectionManager();\n\n  // Connect to OBS (for local/default OBS)\n  connectToOBS();\n});\n","structuredPatch":[{"oldStart":114,"oldLines":7,"newStart":114,"newLines":9,"lines":[" // OBS Scene Generator"," let obsSceneGenerator = null;"," ","-// Timesheet Engine","+// Timesheet Engines (per-competition Map for multi-competition support)","+const timesheetEngines = new Map();","+// Legacy single-engine reference (for backward compatibility during transition)"," let timesheetEngine = null;"," "," // OBS State Sync"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KmSPBXPaZKwr139FJdBBz2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the `getOrCreateEngine` function after the `initializeTimesheetEngine` function. First let me find the end of that function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":379,"cache_read_input_tokens":73837,"cache_creation":{"ephemeral_5m_input_tokens":379,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"06d93fb5-3f1f-4454-95e0-97cb02b67a69"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KmSPBXPaZKwr139FJdBBz2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0125pMjgz2MvShj3YNgjy4Fz","name":"Read","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","offset":340,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":379,"cache_read_input_tokens":73837,"cache_creation":{"ephemeral_5m_input_tokens":379,"ephemeral_1h_input_tokens":0},"output_tokens":142,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"e5ac623a-c189-4f88-a432-2c62dde3dcc6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0125pMjgz2MvShj3YNgjy4Fz","type":"tool_result","content":"   340→    console.error(`Timesheet error: ${data.message}`);\n   341→    io.emit('timesheetError', data);\n   342→  });\n   343→\n   344→  console.log('Timesheet engine initialized');\n   345→}\n   346→\n   347→// Initialize OBS State Sync\n   348→async function initializeOBSStateSync(competitionId) {\n   349→  if (!competitionId) {\n   350→    console.log('No competition ID provided, skipping OBS State Sync initialization');\n   351→    return;\n   352→  }\n   353→\n   354→  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n   355→\n   356→  // Get or create the singleton instance\n   357→  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n   358→\n   359→  // Initialize with competition ID\n   360→  await obsStateSync.initialize(competitionId);\n   361→\n   362→  // Wire up state change event to broadcast\n   363→  obsStateSync.on('broadcast', ({ event, data }) => {\n   364→    // State changes are already broadcast by obsStateSync\n   365→    // This listener is here for logging or additional handling if needed\n   366→  });\n   367→\n   368→  // Sync legacy showState.obsCurrentScene from new system\n   369→  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n   370→    showState.obsCurrentScene = sceneName;\n   371→  });\n   372→\n   373→  console.log('OBS State Sync initialized and ready');\n   374→}\n   375→\n   376→// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\n   377→function initializeVMPoolManager() {\n   378→  const vmPoolManager = getVMPoolManager();\n   379→\n   380→  // Wire up VM pool events to broadcast to all clients\n   381→  vmPoolManager.on('poolUpdated', (data) => {\n   382→    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n   383→    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n   384→  });\n   385→\n   386→  vmPoolManager.on('vmAssigned', (data) => {\n   387→    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n   388→    io.emit('vmAssigned', data);\n   389→    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"4cbad3ca-b549-42ad-9c7b-84734b88e0f4","tool_use_result":{"type":"text","file":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","content":"    console.error(`Timesheet error: ${data.message}`);\n    io.emit('timesheetError', data);\n  });\n\n  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync\nasync function initializeOBSStateSync(competitionId) {\n  if (!competitionId) {\n    console.log('No competition ID provided, skipping OBS State Sync initialization');\n    return;\n  }\n\n  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n\n  // Get or create the singleton instance\n  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n\n  // Initialize with competition ID\n  await obsStateSync.initialize(competitionId);\n\n  // Wire up state change event to broadcast\n  obsStateSync.on('broadcast', ({ event, data }) => {\n    // State changes are already broadcast by obsStateSync\n    // This listener is here for logging or additional handling if needed\n  });\n\n  // Sync legacy showState.obsCurrentScene from new system\n  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n    showState.obsCurrentScene = sceneName;\n  });\n\n  console.log('OBS State Sync initialized and ready');\n}\n\n// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\nfunction initializeVMPoolManager() {\n  const vmPoolManager = getVMPoolManager();\n\n  // Wire up VM pool events to broadcast to all clients\n  vmPoolManager.on('poolUpdated', (data) => {\n    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmAssigned', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n    io.emit('vmAssigned', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());","numLines":50,"startLine":340,"totalLines":5655}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AapvKk6G5rX8XkeBy9Scp5","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the `getOrCreateEngine` function after the existing `initializeTimesheetEngine` function:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1045,"cache_read_input_tokens":74216,"cache_creation":{"ephemeral_5m_input_tokens":1045,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"b67c20a7-521d-4fe2-81e7-11a6cf14c29f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AapvKk6G5rX8XkeBy9Scp5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016gdyrgq4HdhLnkfrCiF42g","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","old_string":"  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync","new_string":"  console.log('Timesheet engine initialized');\n}\n\n/**\n * Get or create a TimesheetEngine for a specific competition\n * This is the new multi-competition approach - each competition gets its own engine instance\n *\n * @param {string} compId - Competition ID\n * @param {Object} obsConnectionManager - OBS connection manager for per-competition OBS connections\n * @param {Object} firebase - Firebase Admin instance for graphics\n * @param {Object} socketIo - Socket.io server for broadcasting\n * @returns {TimesheetEngine} The engine instance for this competition\n */\nfunction getOrCreateEngine(compId, obsConnectionManager, firebase, socketIo) {\n  if (!compId) {\n    throw new Error('compId is required to get or create a TimesheetEngine');\n  }\n\n  if (timesheetEngines.has(compId)) {\n    return timesheetEngines.get(compId);\n  }\n\n  console.log(`[Timesheet] Creating new engine for competition: ${compId}`);\n\n  const engine = new TimesheetEngine({\n    compId,\n    obsConnectionManager,\n    firebase,\n    io: socketIo,\n    showConfig: { segments: [] } // Start with empty config - segments loaded via loadRundown\n  });\n\n  // Wire up timesheet events to broadcast to competition room only\n  const roomName = `competition:${compId}`;\n\n  engine.on('tick', (data) => {\n    socketIo.to(roomName).emit('timesheetTick', data);\n  });\n\n  engine.on('segmentActivated', (data) => {\n    console.log(`[Timesheet:${compId}] Segment activated - ${data.segment.name} (${data.reason})`);\n    socketIo.to(roomName).emit('timesheetSegmentActivated', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('segmentCompleted', (data) => {\n    console.log(`[Timesheet:${compId}] Segment completed - ${data.segmentId} (${data.endReason})`);\n    socketIo.to(roomName).emit('timesheetSegmentCompleted', data);\n  });\n\n  engine.on('showStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Show started`);\n    socketIo.to(roomName).emit('timesheetShowStarted', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('showStopped', (data) => {\n    console.log(`[Timesheet:${compId}] Show stopped`);\n    socketIo.to(roomName).emit('timesheetShowStopped', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('stateChanged', (data) => {\n    socketIo.to(roomName).emit('timesheetStateChanged', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('holdStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Hold started - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetHoldStarted', data);\n  });\n\n  engine.on('holdMaxReached', (data) => {\n    console.log(`[Timesheet:${compId}] Hold max reached - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetHoldMaxReached', data);\n  });\n\n  engine.on('autoAdvancing', (data) => {\n    console.log(`[Timesheet:${compId}] Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n    socketIo.to(roomName).emit('timesheetAutoAdvancing', data);\n  });\n\n  engine.on('overrideRecorded', (data) => {\n    console.log(`[Timesheet:${compId}] Override recorded - ${data.type}`);\n    socketIo.to(roomName).emit('timesheetOverrideRecorded', data);\n  });\n\n  engine.on('sceneChanged', (data) => {\n    socketIo.to(roomName).emit('timesheetSceneChanged', data);\n  });\n\n  engine.on('sceneOverridden', (data) => {\n    console.log(`[Timesheet:${compId}] Scene overridden to ${data.sceneName}`);\n    socketIo.to(roomName).emit('timesheetSceneOverridden', data);\n  });\n\n  engine.on('cameraOverridden', (data) => {\n    console.log(`[Timesheet:${compId}] Camera overridden to ${data.cameraName}`);\n    socketIo.to(roomName).emit('timesheetCameraOverridden', data);\n  });\n\n  engine.on('graphicTriggered', (data) => {\n    socketIo.to(roomName).emit('timesheetGraphicTriggered', data);\n  });\n\n  engine.on('videoStarted', (data) => {\n    socketIo.to(roomName).emit('timesheetVideoStarted', data);\n  });\n\n  engine.on('breakStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Break started - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetBreakStarted', data);\n  });\n\n  engine.on('error', (data) => {\n    console.error(`[Timesheet:${compId}] Error: ${data.message}`);\n    socketIo.to(roomName).emit('timesheetError', data);\n  });\n\n  timesheetEngines.set(compId, engine);\n  console.log(`[Timesheet] Engine created for competition: ${compId} (total engines: ${timesheetEngines.size})`);\n\n  return engine;\n}\n\n/**\n * Get an existing TimesheetEngine for a competition (does not create)\n * @param {string} compId - Competition ID\n * @returns {TimesheetEngine|null} The engine instance or null if not found\n */\nfunction getEngine(compId) {\n  return timesheetEngines.get(compId) || null;\n}\n\n/**\n * Remove a TimesheetEngine for a competition\n * @param {string} compId - Competition ID\n */\nfunction removeEngine(compId) {\n  const engine = timesheetEngines.get(compId);\n  if (engine) {\n    // Stop the engine if running\n    if (engine.isRunning) {\n      engine.stop();\n    }\n    // Remove all listeners to prevent memory leaks\n    engine.removeAllListeners();\n    timesheetEngines.delete(compId);\n    console.log(`[Timesheet] Engine removed for competition: ${compId} (remaining engines: ${timesheetEngines.size})`);\n  }\n}\n\n// Initialize OBS State Sync"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1045,"cache_read_input_tokens":74216,"cache_creation":{"ephemeral_5m_input_tokens":1045,"ephemeral_1h_input_tokens":0},"output_tokens":1949,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"b4de9738-f0e3-45bf-852a-36eab90f2230"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016gdyrgq4HdhLnkfrCiF42g","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/server/index.js has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"34d993bd-7149-4257-94f4-27e1945fe5f9","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/server/index.js","oldString":"  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync","newString":"  console.log('Timesheet engine initialized');\n}\n\n/**\n * Get or create a TimesheetEngine for a specific competition\n * This is the new multi-competition approach - each competition gets its own engine instance\n *\n * @param {string} compId - Competition ID\n * @param {Object} obsConnectionManager - OBS connection manager for per-competition OBS connections\n * @param {Object} firebase - Firebase Admin instance for graphics\n * @param {Object} socketIo - Socket.io server for broadcasting\n * @returns {TimesheetEngine} The engine instance for this competition\n */\nfunction getOrCreateEngine(compId, obsConnectionManager, firebase, socketIo) {\n  if (!compId) {\n    throw new Error('compId is required to get or create a TimesheetEngine');\n  }\n\n  if (timesheetEngines.has(compId)) {\n    return timesheetEngines.get(compId);\n  }\n\n  console.log(`[Timesheet] Creating new engine for competition: ${compId}`);\n\n  const engine = new TimesheetEngine({\n    compId,\n    obsConnectionManager,\n    firebase,\n    io: socketIo,\n    showConfig: { segments: [] } // Start with empty config - segments loaded via loadRundown\n  });\n\n  // Wire up timesheet events to broadcast to competition room only\n  const roomName = `competition:${compId}`;\n\n  engine.on('tick', (data) => {\n    socketIo.to(roomName).emit('timesheetTick', data);\n  });\n\n  engine.on('segmentActivated', (data) => {\n    console.log(`[Timesheet:${compId}] Segment activated - ${data.segment.name} (${data.reason})`);\n    socketIo.to(roomName).emit('timesheetSegmentActivated', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('segmentCompleted', (data) => {\n    console.log(`[Timesheet:${compId}] Segment completed - ${data.segmentId} (${data.endReason})`);\n    socketIo.to(roomName).emit('timesheetSegmentCompleted', data);\n  });\n\n  engine.on('showStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Show started`);\n    socketIo.to(roomName).emit('timesheetShowStarted', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('showStopped', (data) => {\n    console.log(`[Timesheet:${compId}] Show stopped`);\n    socketIo.to(roomName).emit('timesheetShowStopped', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('stateChanged', (data) => {\n    socketIo.to(roomName).emit('timesheetStateChanged', data);\n    socketIo.to(roomName).emit('timesheetState', engine.getState());\n  });\n\n  engine.on('holdStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Hold started - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetHoldStarted', data);\n  });\n\n  engine.on('holdMaxReached', (data) => {\n    console.log(`[Timesheet:${compId}] Hold max reached - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetHoldMaxReached', data);\n  });\n\n  engine.on('autoAdvancing', (data) => {\n    console.log(`[Timesheet:${compId}] Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n    socketIo.to(roomName).emit('timesheetAutoAdvancing', data);\n  });\n\n  engine.on('overrideRecorded', (data) => {\n    console.log(`[Timesheet:${compId}] Override recorded - ${data.type}`);\n    socketIo.to(roomName).emit('timesheetOverrideRecorded', data);\n  });\n\n  engine.on('sceneChanged', (data) => {\n    socketIo.to(roomName).emit('timesheetSceneChanged', data);\n  });\n\n  engine.on('sceneOverridden', (data) => {\n    console.log(`[Timesheet:${compId}] Scene overridden to ${data.sceneName}`);\n    socketIo.to(roomName).emit('timesheetSceneOverridden', data);\n  });\n\n  engine.on('cameraOverridden', (data) => {\n    console.log(`[Timesheet:${compId}] Camera overridden to ${data.cameraName}`);\n    socketIo.to(roomName).emit('timesheetCameraOverridden', data);\n  });\n\n  engine.on('graphicTriggered', (data) => {\n    socketIo.to(roomName).emit('timesheetGraphicTriggered', data);\n  });\n\n  engine.on('videoStarted', (data) => {\n    socketIo.to(roomName).emit('timesheetVideoStarted', data);\n  });\n\n  engine.on('breakStarted', (data) => {\n    console.log(`[Timesheet:${compId}] Break started - ${data.segmentId}`);\n    socketIo.to(roomName).emit('timesheetBreakStarted', data);\n  });\n\n  engine.on('error', (data) => {\n    console.error(`[Timesheet:${compId}] Error: ${data.message}`);\n    socketIo.to(roomName).emit('timesheetError', data);\n  });\n\n  timesheetEngines.set(compId, engine);\n  console.log(`[Timesheet] Engine created for competition: ${compId} (total engines: ${timesheetEngines.size})`);\n\n  return engine;\n}\n\n/**\n * Get an existing TimesheetEngine for a competition (does not create)\n * @param {string} compId - Competition ID\n * @returns {TimesheetEngine|null} The engine instance or null if not found\n */\nfunction getEngine(compId) {\n  return timesheetEngines.get(compId) || null;\n}\n\n/**\n * Remove a TimesheetEngine for a competition\n * @param {string} compId - Competition ID\n */\nfunction removeEngine(compId) {\n  const engine = timesheetEngines.get(compId);\n  if (engine) {\n    // Stop the engine if running\n    if (engine.isRunning) {\n      engine.stop();\n    }\n    // Remove all listeners to prevent memory leaks\n    engine.removeAllListeners();\n    timesheetEngines.delete(compId);\n    console.log(`[Timesheet] Engine removed for competition: ${compId} (remaining engines: ${timesheetEngines.size})`);\n  }\n}\n\n// Initialize OBS State Sync","originalFile":"import express from 'express';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport OBSWebSocket from 'obs-websocket-js';\nimport cors from 'cors';\nimport { readFileSync, writeFileSync, watchFile } from 'fs';\nimport { fileURLToPath } from 'url';\nimport { dirname, join } from 'path';\nimport dotenv from 'dotenv';\nimport multer from 'multer';\nimport { parse } from 'csv-parse/sync';\nimport { validateShowConfig } from './lib/showConfigSchema.js';\nimport { CameraHealthMonitor } from './lib/cameraHealth.js';\nimport { CameraRuntimeState } from './lib/cameraRuntimeState.js';\nimport { CameraFallbackManager } from './lib/cameraFallback.js';\nimport { OBSSceneGenerator } from './lib/obsSceneGenerator.js';\nimport { TimesheetEngine } from './lib/timesheetEngine.js';\nimport { getApparatusForGender } from './lib/apparatusConfig.js';\nimport productionConfigService from './lib/productionConfigService.js';\nimport configLoader from './lib/configLoader.js';\nimport { getVMPoolManager, VM_STATUS } from './lib/vmPoolManager.js';\nimport { getAWSService } from './lib/awsService.js';\nimport { getAlertService, ALERT_LEVEL, ALERT_CATEGORY } from './lib/alertService.js';\nimport { getAutoShutdownService } from './lib/autoShutdown.js';\nimport { getSelfStopService } from './lib/selfStop.js';\nimport { getOBSStateSync } from './lib/obsStateSync.js';\nimport { setupOBSRoutes } from './routes/obs.js';\nimport { getOBSConnectionManager } from './lib/obsConnectionManager.js';\nimport { DEFAULT_PRESETS } from './lib/obsAudioManager.js';\nimport { encryptStreamKey, decryptStreamKey, isEncryptedKey } from './lib/obsStreamManager.js';\n\ndotenv.config();\n\n// ============================================\n// Coordinator State Tracking\n// ============================================\nconst serverStartTime = Date.now();\nlet lastActivityTimestamp = Date.now();\nconst SERVER_VERSION = '1.0.0';\n\n/**\n * Update last activity timestamp\n * Called on API requests and socket events\n */\nfunction updateLastActivity() {\n  lastActivityTimestamp = Date.now();\n}\n\n/**\n * Get server uptime in seconds\n */\nfunction getUptime() {\n  return Math.floor((Date.now() - serverStartTime) / 1000);\n}\n\n/**\n * Get idle time in seconds\n */\nfunction getIdleTime() {\n  return Math.floor((Date.now() - lastActivityTimestamp) / 1000);\n}\n\n// Configure multer for file uploads\nconst upload = multer({ storage: multer.memoryStorage() });\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nconst app = express();\nconst httpServer = createServer(app);\nconst io = new Server(httpServer, {\n  cors: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\nconst obs = new OBSWebSocket();\n\n// Configuration\nconst PORT = process.env.PORT || 3003;\nconst OBS_WEBSOCKET_URL = process.env.OBS_WEBSOCKET_URL || 'ws://localhost:4455';\nconst OBS_WEBSOCKET_PASSWORD = process.env.OBS_WEBSOCKET_PASSWORD || '';\n\n// Show State\nlet showState = {\n  currentSegmentIndex: 0,\n  currentSegment: null,\n  nextSegment: null,\n  isPlaying: false,\n  isPaused: false,\n  talentLocked: false,\n  obsConnected: false,\n  obsCurrentScene: null,\n  obsIsStreaming: false,\n  obsIsRecording: false,\n  connectedClients: [],\n  showProgress: {\n    completed: 0,\n    total: 0\n  },\n  segmentStartTime: null,\n  segmentElapsed: 0\n};\n\n// Show Configuration\nlet showConfig = null;\n\n// Camera Management Modules\nlet cameraHealthMonitor = null;\nlet cameraRuntimeState = null;\nlet cameraFallbackManager = null;\n\n// OBS Scene Generator\nlet obsSceneGenerator = null;\n\n// Timesheet Engines (per-competition Map for multi-competition support)\nconst timesheetEngines = new Map();\n// Legacy single-engine reference (for backward compatibility during transition)\nlet timesheetEngine = null;\n\n// OBS State Sync\nlet obsStateSync = null;\n\n// Load show configuration\nfunction loadShowConfig(exitOnInvalid = false) {\n  try {\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    const configData = readFileSync(configPath, 'utf-8');\n    const parsedConfig = JSON.parse(configData);\n\n    // Validate the configuration against schema\n    const validation = validateShowConfig(parsedConfig);\n    if (!validation.valid) {\n      console.error('Show config validation failed:');\n      validation.errors.forEach(err => console.error(`  - ${err}`));\n      if (exitOnInvalid) {\n        console.error('Exiting due to invalid configuration');\n        process.exit(1);\n      }\n      return false;\n    }\n\n    showConfig = parsedConfig;\n    showState.showProgress.total = showConfig.segments.length;\n    updateCurrentSegment();\n    console.log(`Loaded show config: ${showConfig.showName} with ${showConfig.segments.length} segments (validated)`);\n    return true;\n  } catch (error) {\n    console.error('Error loading show config:', error.message);\n    if (exitOnInvalid) {\n      process.exit(1);\n    }\n    return false;\n  }\n}\n\n// Initialize camera management modules\nfunction initializeCameraModules() {\n  if (!showConfig || !showConfig.cameras) {\n    console.log('No cameras configured, skipping camera module initialization');\n    return;\n  }\n\n  // Initialize health monitor\n  if (cameraHealthMonitor) {\n    cameraHealthMonitor.stop();\n  }\n  cameraHealthMonitor = new CameraHealthMonitor({\n    cameras: showConfig.cameras,\n    nimbleServer: showConfig.nimbleServer || {}\n  });\n\n  // Initialize runtime state\n  cameraRuntimeState = new CameraRuntimeState({\n    cameras: showConfig.cameras\n  });\n\n  // Initialize fallback manager\n  cameraFallbackManager = new CameraFallbackManager({\n    cameras: showConfig.cameras,\n    cameraHealthMonitor,\n    cameraRuntimeState,\n    switchScene\n  });\n\n  // Attach event handlers BEFORE starting (to catch initial poll errors)\n  // Broadcast camera health on each poll\n  cameraHealthMonitor.on('cameraHealth', (healthData) => {\n    io.emit('cameraHealth', healthData);\n  });\n\n  // Broadcast status changes to all clients\n  cameraHealthMonitor.on('cameraStatusChanged', (change) => {\n    console.log(`Camera ${change.cameraName} status: ${change.previousStatus} -> ${change.newStatus}`);\n    io.emit('cameraStatusChanged', change);\n  });\n\n  // Handle errors from health monitor (e.g., Nimble server not available)\n  cameraHealthMonitor.on('error', (error) => {\n    // Log but don't crash - Nimble server may not be running\n    console.warn(`Camera health monitor error: ${error.message}`);\n  });\n\n  // Broadcast runtime state changes to all clients\n  cameraRuntimeState.on('stateChanged', (state) => {\n    io.emit('cameraRuntimeState', state);\n  });\n\n  cameraRuntimeState.on('apparatusReassigned', (data) => {\n    io.emit('apparatusReassigned', data);\n  });\n\n  cameraRuntimeState.on('cameraVerified', (data) => {\n    io.emit('cameraVerified', data);\n  });\n\n  cameraRuntimeState.on('mismatchDetected', (data) => {\n    io.emit('mismatchDetected', data);\n  });\n\n  // Broadcast fallback events to all clients\n  cameraFallbackManager.on('fallbackActivated', (data) => {\n    io.emit('fallbackActivated', data);\n  });\n\n  cameraFallbackManager.on('fallbackCleared', (data) => {\n    io.emit('fallbackCleared', data);\n  });\n\n  cameraFallbackManager.on('fallbackUnavailable', (data) => {\n    io.emit('fallbackUnavailable', data);\n  });\n\n  cameraFallbackManager.on('fallbackChainExhausted', (data) => {\n    io.emit('fallbackChainExhausted', data);\n  });\n\n  // Start health monitoring (after event handlers are attached)\n  cameraHealthMonitor.start();\n\n  console.log(`Camera modules initialized with ${showConfig.cameras.length} cameras`);\n}\n\n// Initialize OBS scene generator\nfunction initializeSceneGenerator() {\n  obsSceneGenerator = new OBSSceneGenerator(obs, showConfig);\n  console.log('OBS scene generator initialized');\n}\n\n// Initialize timesheet engine\nfunction initializeTimesheetEngine() {\n  timesheetEngine = new TimesheetEngine({\n    showConfig,\n    obs,\n    io\n  });\n\n  // Wire up timesheet events to broadcast to all clients\n  timesheetEngine.on('tick', (data) => {\n    io.emit('timesheetTick', data);\n  });\n\n  timesheetEngine.on('segmentActivated', (data) => {\n    console.log(`Timesheet: Segment activated - ${data.segment.name} (${data.reason})`);\n    io.emit('timesheetSegmentActivated', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('segmentCompleted', (data) => {\n    console.log(`Timesheet: Segment completed - ${data.segmentId} (${data.endReason})`);\n    io.emit('timesheetSegmentCompleted', data);\n  });\n\n  timesheetEngine.on('showStarted', (data) => {\n    console.log('Timesheet: Show started');\n    io.emit('timesheetShowStarted', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('showStopped', (data) => {\n    console.log('Timesheet: Show stopped');\n    io.emit('timesheetShowStopped', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('stateChanged', (data) => {\n    io.emit('timesheetStateChanged', data);\n    io.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  timesheetEngine.on('holdStarted', (data) => {\n    console.log(`Timesheet: Hold started - ${data.segmentId}`);\n    io.emit('timesheetHoldStarted', data);\n  });\n\n  timesheetEngine.on('holdMaxReached', (data) => {\n    console.log(`Timesheet: Hold max reached - ${data.segmentId}`);\n    io.emit('timesheetHoldMaxReached', data);\n  });\n\n  timesheetEngine.on('autoAdvancing', (data) => {\n    console.log(`Timesheet: Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);\n    io.emit('timesheetAutoAdvancing', data);\n  });\n\n  timesheetEngine.on('overrideRecorded', (data) => {\n    console.log(`Timesheet: Override recorded - ${data.type}`);\n    io.emit('timesheetOverrideRecorded', data);\n  });\n\n  timesheetEngine.on('sceneChanged', (data) => {\n    io.emit('timesheetSceneChanged', data);\n  });\n\n  timesheetEngine.on('sceneOverridden', (data) => {\n    console.log(`Timesheet: Scene overridden to ${data.sceneName}`);\n    io.emit('timesheetSceneOverridden', data);\n  });\n\n  timesheetEngine.on('cameraOverridden', (data) => {\n    console.log(`Timesheet: Camera overridden to ${data.cameraName}`);\n    io.emit('timesheetCameraOverridden', data);\n  });\n\n  timesheetEngine.on('graphicTriggered', (data) => {\n    io.emit('timesheetGraphicTriggered', data);\n  });\n\n  timesheetEngine.on('videoStarted', (data) => {\n    io.emit('timesheetVideoStarted', data);\n  });\n\n  timesheetEngine.on('breakStarted', (data) => {\n    console.log(`Timesheet: Break started - ${data.segmentId}`);\n    io.emit('timesheetBreakStarted', data);\n  });\n\n  timesheetEngine.on('error', (data) => {\n    console.error(`Timesheet error: ${data.message}`);\n    io.emit('timesheetError', data);\n  });\n\n  console.log('Timesheet engine initialized');\n}\n\n// Initialize OBS State Sync\nasync function initializeOBSStateSync(competitionId) {\n  if (!competitionId) {\n    console.log('No competition ID provided, skipping OBS State Sync initialization');\n    return;\n  }\n\n  console.log(`Initializing OBS State Sync for competition: ${competitionId}`);\n\n  // Get or create the singleton instance\n  obsStateSync = getOBSStateSync(obs, io, productionConfigService);\n\n  // Initialize with competition ID\n  await obsStateSync.initialize(competitionId);\n\n  // Wire up state change event to broadcast\n  obsStateSync.on('broadcast', ({ event, data }) => {\n    // State changes are already broadcast by obsStateSync\n    // This listener is here for logging or additional handling if needed\n  });\n\n  // Sync legacy showState.obsCurrentScene from new system\n  obsStateSync.on('currentSceneChanged', ({ sceneName }) => {\n    showState.obsCurrentScene = sceneName;\n  });\n\n  console.log('OBS State Sync initialized and ready');\n}\n\n// Initialize VM Pool Manager and wire up event broadcasts (P15-03)\nfunction initializeVMPoolManager() {\n  const vmPoolManager = getVMPoolManager();\n\n  // Wire up VM pool events to broadcast to all clients\n  vmPoolManager.on('poolUpdated', (data) => {\n    console.log(`[VMPool] Pool updated: ${data.vmCount} VMs`);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmAssigned', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} assigned to competition ${data.competitionId}`);\n    io.emit('vmAssigned', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmReleased', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} released from competition ${data.competitionId}`);\n    io.emit('vmReleased', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStarting', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is starting`);\n    io.emit('vmStarting', {\n      ...data,\n      estimatedReadyTime: new Date(Date.now() + 180000).toISOString() // ~3 minutes\n    });\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmReady', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is ready at ${data.publicIp}`);\n    io.emit('vmReady', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStopping', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is stopping`);\n    io.emit('vmStopping', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmStopped', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is stopped`);\n    io.emit('vmStopped', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmError', (data) => {\n    console.error(`[VMPool] VM ${data.vmId} error: ${data.error || data.reason}`);\n    io.emit('vmError', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('vmInUse', (data) => {\n    console.log(`[VMPool] VM ${data.vmId} is now in use for competition ${data.competitionId}`);\n    io.emit('vmInUse', data);\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  });\n\n  vmPoolManager.on('configUpdated', (config) => {\n    console.log('[VMPool] Pool config updated');\n    io.emit('vmPoolConfigUpdated', config);\n  });\n\n  vmPoolManager.on('poolMaintenance', (data) => {\n    console.log(`[VMPool] Pool maintenance: started ${data.startedCount} VMs`);\n    io.emit('vmPoolMaintenance', data);\n  });\n\n  // Try to initialize the pool (non-blocking, will log errors)\n  vmPoolManager.initializePool().then(() => {\n    console.log('[VMPool] VM pool manager initialized and listening for events');\n    // Broadcast initial pool status\n    io.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n  }).catch((error) => {\n    console.log(`[VMPool] VM pool not available: ${error.message}`);\n    console.log('[VMPool] VM pool features disabled - this is normal for local development');\n  });\n}\n\n// Initialize Auto-Shutdown Service (P19-02)\nasync function initializeAutoShutdown() {\n  const isCoordinatorMode = process.env.COORDINATOR_MODE === 'true';\n\n  if (!isCoordinatorMode) {\n    console.log('[AutoShutdown] Not in coordinator mode, skipping initialization');\n    return;\n  }\n\n  const autoShutdown = getAutoShutdownService();\n\n  // Wire up shutdown events to broadcast to all clients\n  autoShutdown.on('shutdownPending', (data) => {\n    console.log(`[AutoShutdown] Shutdown pending: ${data.reason} (${data.secondsRemaining}s)`);\n    io.emit('shutdownPending', data);\n  });\n\n  autoShutdown.on('shutdownCancelled', (data) => {\n    console.log(`[AutoShutdown] Shutdown cancelled: ${data.reason}`);\n    io.emit('shutdownCancelled', data);\n  });\n\n  autoShutdown.on('shutdownExecuting', (data) => {\n    console.log(`[AutoShutdown] Shutdown executing: ${data.reason}`);\n    io.emit('shutdownExecuting', data);\n  });\n\n  // Custom stop callback for graceful shutdown\n  const gracefulStopCallback = async () => {\n    console.log('[AutoShutdown] Graceful shutdown initiated');\n\n    // Notify all connected clients\n    io.emit('serverShuttingDown', {\n      timestamp: new Date().toISOString(),\n      message: 'Server shutting down due to idle timeout'\n    });\n\n    // Close all socket connections gracefully\n    const sockets = await io.fetchSockets();\n    for (const socket of sockets) {\n      socket.disconnect(true);\n    }\n\n    // Stop camera health polling\n    if (cameraHealthMonitor) {\n      cameraHealthMonitor.stop();\n    }\n\n    // Stop timesheet engine\n    if (timesheetEngine) {\n      timesheetEngine.stop();\n    }\n\n    console.log('[AutoShutdown] Graceful shutdown complete');\n  };\n\n  // Initialize with socket.io and AWS service\n  try {\n    const awsService = getAWSService();\n    await autoShutdown.initialize({\n      io,\n      awsService,\n      stopCallback: gracefulStopCallback\n    });\n    console.log('[AutoShutdown] Auto-shutdown service initialized');\n\n    // Initialize self-stop service and wire it to auto-shutdown\n    const selfStop = getSelfStopService();\n    await selfStop.initialize({ io });\n    console.log('[SelfStop] Self-stop service initialized');\n\n    // Wire auto-shutdown completion to EC2 self-stop\n    autoShutdown.on('shutdownComplete', async (data) => {\n      console.log('[SelfStop] Auto-shutdown complete, initiating EC2 self-stop');\n      const result = await selfStop.stopSelf({\n        reason: data.reason || 'Auto-shutdown idle timeout',\n        idleMinutes: data.idleMinutes || 0\n      });\n      console.log('[SelfStop] Self-stop result:', result);\n    });\n  } catch (error) {\n    console.warn('[AutoShutdown] Failed to initialize:', error.message);\n  }\n}\n\n// Watch for config changes (hot reload)\nwatchFile(join(__dirname, 'config', 'show-config.json'), () => {\n  console.log('Show config changed, reloading...');\n  loadShowConfig();\n  // Update camera modules with new config\n  if (cameraHealthMonitor) {\n    cameraHealthMonitor.updateConfig(showConfig);\n  }\n  if (cameraRuntimeState) {\n    cameraRuntimeState.updateConfig(showConfig);\n  }\n  if (cameraFallbackManager) {\n    cameraFallbackManager.updateConfig({ cameras: showConfig.cameras });\n  }\n  // Update scene generator with new config\n  if (obsSceneGenerator) {\n    obsSceneGenerator.updateConfig(showConfig);\n  }\n  // Update timesheet engine with new config\n  if (timesheetEngine) {\n    timesheetEngine.updateConfig(showConfig);\n  }\n  broadcastState();\n});\n\n// Update current segment based on index\nfunction updateCurrentSegment() {\n  if (!showConfig || !showConfig.segments) return;\n\n  showState.currentSegment = showConfig.segments[showState.currentSegmentIndex] || null;\n  showState.nextSegment = showConfig.segments[showState.currentSegmentIndex + 1] || null;\n  showState.showProgress.completed = showState.currentSegmentIndex;\n}\n\n// Broadcast state to all clients\nfunction broadcastState() {\n  io.emit('stateUpdate', {\n    ...showState,\n    showConfig: showConfig ? {\n      showName: showConfig.showName,\n      segments: showConfig.segments,\n      sponsors: showConfig.sponsors\n    } : null,\n    obsState: obsStateSync && obsStateSync.isInitialized() ? obsStateSync.getState() : null\n  });\n}\n\n// Connect to OBS\nlet obsReconnectTimer = null;\nlet obsConnecting = false;\n\nasync function connectToOBS() {\n  if (obsConnecting) return; // Prevent multiple simultaneous connection attempts\n  obsConnecting = true;\n\n  try {\n    await obs.connect(OBS_WEBSOCKET_URL, OBS_WEBSOCKET_PASSWORD || undefined);\n    showState.obsConnected = true;\n    obsConnecting = false;\n    console.log('Connected to OBS WebSocket');\n\n    // Get initial scene\n    const { currentProgramSceneName } = await obs.call('GetCurrentProgramScene');\n    showState.obsCurrentScene = currentProgramSceneName;\n\n    // Get streaming/recording status\n    try {\n      const streamStatus = await obs.call('GetStreamStatus');\n      showState.obsIsStreaming = streamStatus.outputActive;\n    } catch (e) {\n      // Streaming might not be available\n    }\n\n    try {\n      const recordStatus = await obs.call('GetRecordStatus');\n      showState.obsIsRecording = recordStatus.outputActive;\n    } catch (e) {\n      // Recording might not be available\n    }\n\n    broadcastState();\n  } catch (error) {\n    console.error('Failed to connect to OBS:', error.message);\n    showState.obsConnected = false;\n    obsConnecting = false;\n\n    // Retry connection after 30 seconds (longer delay to avoid spam)\n    if (obsReconnectTimer) clearTimeout(obsReconnectTimer);\n    obsReconnectTimer = setTimeout(connectToOBS, 30000);\n  }\n}\n\n// OBS Event Handlers\n// Note: CurrentProgramSceneChanged is now handled by obsStateSync (line ~3670)\n// Legacy showState.obsCurrentScene is synced via obsStateSync.on('currentSceneChanged')\n\nobs.on('StreamStateChanged', ({ outputActive }) => {\n  showState.obsIsStreaming = outputActive;\n  broadcastState();\n});\n\nobs.on('RecordStateChanged', ({ outputActive }) => {\n  showState.obsIsRecording = outputActive;\n  broadcastState();\n});\n\nobs.on('ConnectionClosed', () => {\n  console.log('OBS connection closed');\n  showState.obsConnected = false;\n  obsConnecting = false;\n  broadcastState();\n  // Attempt reconnect after 30 seconds\n  if (obsReconnectTimer) clearTimeout(obsReconnectTimer);\n  obsReconnectTimer = setTimeout(connectToOBS, 30000);\n});\n\n// Switch OBS scene\nasync function switchScene(sceneName) {\n  if (!showState.obsConnected) {\n    console.error('Cannot switch scene: OBS not connected');\n    return false;\n  }\n\n  try {\n    await obs.call('SetCurrentProgramScene', { sceneName });\n    console.log(`Switched to scene: ${sceneName}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to switch scene to ${sceneName}:`, error.message);\n    return false;\n  }\n}\n\n// Get available OBS scenes\nasync function getSceneList() {\n  if (!showState.obsConnected) return [];\n\n  try {\n    const { scenes } = await obs.call('GetSceneList');\n    return scenes.map(s => s.sceneName);\n  } catch (error) {\n    console.error('Failed to get scene list:', error.message);\n    return [];\n  }\n}\n\n// Default media source name in OBS (user should create this)\nconst VIDEO_SOURCE_NAME = process.env.OBS_VIDEO_SOURCE || 'Video Player';\n\n// Set video file for media source\nasync function setVideoFile(filePath, sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) {\n    console.error('Cannot set video: OBS not connected');\n    return false;\n  }\n\n  try {\n    // Get current settings first\n    const { inputSettings } = await obs.call('GetInputSettings', { inputName: sourceName });\n\n    // Update with new file path\n    await obs.call('SetInputSettings', {\n      inputName: sourceName,\n      inputSettings: {\n        ...inputSettings,\n        local_file: filePath,\n        is_local_file: true\n      }\n    });\n\n    // Restart the media source to play from beginning\n    await obs.call('TriggerMediaInputAction', {\n      inputName: sourceName,\n      mediaAction: 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n    });\n\n    console.log(`Set video file: ${filePath}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to set video file:`, error.message);\n    return false;\n  }\n}\n\n// Play/pause/stop media source\nasync function controlMedia(action, sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) return false;\n\n  const actionMap = {\n    'play': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PLAY',\n    'pause': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_PAUSE',\n    'stop': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_STOP',\n    'restart': 'OBS_WEBSOCKET_MEDIA_INPUT_ACTION_RESTART'\n  };\n\n  try {\n    await obs.call('TriggerMediaInputAction', {\n      inputName: sourceName,\n      mediaAction: actionMap[action] || action\n    });\n    console.log(`Media action: ${action}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to control media:`, error.message);\n    return false;\n  }\n}\n\n// Get media source status (for progress tracking)\nasync function getMediaStatus(sourceName = VIDEO_SOURCE_NAME) {\n  if (!showState.obsConnected) return null;\n\n  try {\n    const status = await obs.call('GetMediaInputStatus', { inputName: sourceName });\n    return {\n      state: status.mediaState,\n      duration: status.mediaDuration,\n      cursor: status.mediaCursor // current position in ms\n    };\n  } catch (error) {\n    console.error(`Failed to get media status:`, error.message);\n    return null;\n  }\n}\n\n// Advance to next segment\nasync function advanceSegment(clientId = null) {\n  if (showState.talentLocked && clientId) {\n    const client = showState.connectedClients.find(c => c.id === clientId);\n    if (client && client.role === 'talent') {\n      console.log('Talent controls locked, ignoring advance request');\n      return false;\n    }\n  }\n\n  if (!showConfig || showState.currentSegmentIndex >= showConfig.segments.length - 1) {\n    console.log('Already at last segment');\n    return false;\n  }\n\n  showState.currentSegmentIndex++;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  // Switch OBS scene if specified\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  // Set video file if specified (for video segments)\n  if (showState.currentSegment?.videoFile) {\n    await setVideoFile(showState.currentSegment.videoFile);\n  }\n\n  // Trigger graphic if specified\n  if (showState.currentSegment?.graphic) {\n    io.emit('triggerGraphic', {\n      graphic: showState.currentSegment.graphic,\n      data: showState.currentSegment.graphicData || {}\n    });\n  }\n\n  // Set up auto-advance if applicable\n  if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n    setupAutoAdvance(showState.currentSegment.duration);\n  }\n\n  broadcastState();\n  console.log(`Advanced to segment ${showState.currentSegmentIndex}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Go to previous segment\nasync function previousSegment() {\n  if (!showConfig || showState.currentSegmentIndex <= 0) {\n    console.log('Already at first segment');\n    return false;\n  }\n\n  showState.currentSegmentIndex--;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  broadcastState();\n  console.log(`Went back to segment ${showState.currentSegmentIndex}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Jump to specific segment\nasync function jumpToSegment(segmentId) {\n  if (!showConfig) return false;\n\n  const index = showConfig.segments.findIndex(s => s.id === segmentId);\n  if (index === -1) {\n    console.error(`Segment not found: ${segmentId}`);\n    return false;\n  }\n\n  showState.currentSegmentIndex = index;\n  updateCurrentSegment();\n  showState.segmentStartTime = Date.now();\n  showState.segmentElapsed = 0;\n\n  if (showState.currentSegment?.obsScene) {\n    await switchScene(showState.currentSegment.obsScene);\n  }\n\n  // Set video file if specified\n  if (showState.currentSegment?.videoFile) {\n    await setVideoFile(showState.currentSegment.videoFile);\n  }\n\n  if (showState.currentSegment?.graphic) {\n    io.emit('triggerGraphic', {\n      graphic: showState.currentSegment.graphic,\n      data: showState.currentSegment.graphicData || {}\n    });\n  }\n\n  if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n    setupAutoAdvance(showState.currentSegment.duration);\n  }\n\n  broadcastState();\n  console.log(`Jumped to segment ${index}: ${showState.currentSegment?.name}`);\n  return true;\n}\n\n// Auto-advance timer\nlet autoAdvanceTimer = null;\n\nfunction setupAutoAdvance(durationSeconds) {\n  if (autoAdvanceTimer) {\n    clearTimeout(autoAdvanceTimer);\n  }\n\n  if (showState.isPaused) return;\n\n  autoAdvanceTimer = setTimeout(() => {\n    if (!showState.isPaused) {\n      console.log('Auto-advancing to next segment');\n      advanceSegment();\n    }\n  }, durationSeconds * 1000);\n}\n\nfunction clearAutoAdvance() {\n  if (autoAdvanceTimer) {\n    clearTimeout(autoAdvanceTimer);\n    autoAdvanceTimer = null;\n  }\n}\n\n// Middleware\napp.use(cors());\napp.use(express.json());\napp.use(express.static(join(__dirname, '..', 'show-controller', 'dist')));\n// Serve graphics output files from project root (output.html, overlays/)\napp.use(express.static(join(__dirname, '..')));\n\n// Activity tracking middleware - updates last activity on every REST request\napp.use((req, res, next) => {\n  updateLastActivity();\n  // Also update auto-shutdown service if initialized\n  const autoShutdown = getAutoShutdownService();\n  if (autoShutdown.isInitialized()) {\n    autoShutdown.resetActivity();\n  }\n  next();\n});\n\n// REST API endpoints\napp.get('/api/status', (req, res) => {\n  res.json(showState);\n});\n\napp.get('/api/scenes', async (req, res) => {\n  const scenes = await getSceneList();\n  res.json(scenes);\n});\n\napp.get('/api/config', (req, res) => {\n  res.json(showConfig);\n});\n\n// Config validation endpoint\napp.get('/api/config/validate', (req, res) => {\n  if (!showConfig) {\n    return res.json({ valid: false, errors: ['No configuration loaded'] });\n  }\n  const validation = validateShowConfig(showConfig);\n  res.json(validation);\n});\n\n// Update cameras configuration\napp.put('/api/config/cameras', (req, res) => {\n  const { cameras } = req.body;\n  if (!cameras || !Array.isArray(cameras)) {\n    return res.status(400).json({ error: 'cameras must be an array' });\n  }\n\n  try {\n    // Update showConfig with new cameras\n    showConfig.cameras = cameras;\n\n    // Save to file\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    writeFileSync(configPath, JSON.stringify(showConfig, null, 2));\n\n    // Re-validate the config\n    const validation = validateShowConfig(showConfig);\n    if (!validation.valid) {\n      return res.status(400).json({\n        error: 'Invalid configuration',\n        errors: validation.errors\n      });\n    }\n\n    // Reinitialize camera modules with new config\n    initializeCameraModules();\n\n    // Update scene generator\n    if (obsSceneGenerator) {\n      obsSceneGenerator.updateConfig(showConfig);\n    }\n\n    console.log(`Camera config updated: ${cameras.length} cameras`);\n    res.json({ success: true, cameras: cameras.length });\n  } catch (error) {\n    console.error('Failed to save camera config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Apparatus API Endpoints\n// ============================================\n\n// GET /api/apparatus/:gender - Get apparatus for a specific gender\napp.get('/api/apparatus/:gender', (req, res) => {\n  const { gender } = req.params;\n\n  // Handle invalid gender gracefully (defaults to womens internally)\n  const apparatus = getApparatusForGender(gender);\n\n  // Determine normalized gender for response\n  const normalizedGender = (gender && (gender.toLowerCase() === 'mens' ||\n    gender.toLowerCase() === 'mag' ||\n    gender.toLowerCase() === 'male' ||\n    gender.toLowerCase() === 'm')) ? 'mens' : 'womens';\n\n  res.json({\n    gender: normalizedGender,\n    apparatus\n  });\n});\n\n// ============================================\n// Production Config API Endpoints\n// ============================================\n\n// GET /api/competitions/active - Get current active competition\napp.get('/api/competitions/active', (req, res) => {\n  const activeCompetitionId = configLoader.getActiveCompetition();\n  res.json({\n    activeCompetitionId,\n    isActive: !!activeCompetitionId\n  });\n});\n\n// POST /api/competitions/deactivate - Clear active competition\napp.post('/api/competitions/deactivate', (req, res) => {\n  configLoader.clearActiveCompetition();\n  res.json({\n    success: true,\n    message: 'Active competition cleared'\n  });\n});\n\n// GET /api/competitions/:id/production - Get full production config\napp.get('/api/competitions/:id/production', async (req, res) => {\n  const { id } = req.params;\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const productionConfig = await productionConfigService.getProductionConfig(id);\n    if (!productionConfig) {\n      return res.status(404).json({ error: 'Production config not found', competitionId: id });\n    }\n    res.json(productionConfig);\n  } catch (error) {\n    console.error(`Failed to get production config for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/cameras - Save cameras for a competition\napp.put('/api/competitions/:id/production/cameras', async (req, res) => {\n  const { id } = req.params;\n  const { cameras } = req.body;\n\n  if (!cameras || !Array.isArray(cameras)) {\n    return res.status(400).json({ error: 'cameras must be an array' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveCameras(id, cameras);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save cameras' });\n    }\n    res.json({ success: true, cameras: cameras.length, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save cameras for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/rundown - Save rundown for a competition\napp.put('/api/competitions/:id/production/rundown', async (req, res) => {\n  const { id } = req.params;\n  const rundown = req.body;\n\n  if (!rundown || typeof rundown !== 'object') {\n    return res.status(400).json({ error: 'rundown must be an object' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveRundown(id, rundown);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save rundown' });\n    }\n    res.json({ success: true, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save rundown for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/competitions/:id/production/settings - Save settings for a competition\napp.put('/api/competitions/:id/production/settings', async (req, res) => {\n  const { id } = req.params;\n  const settings = req.body;\n\n  if (!settings || typeof settings !== 'object') {\n    return res.status(400).json({ error: 'settings must be an object' });\n  }\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const success = await productionConfigService.saveSettings(id, settings);\n    if (!success) {\n      return res.status(500).json({ error: 'Failed to save settings' });\n    }\n    res.json({ success: true, competitionId: id });\n  } catch (error) {\n    console.error(`Failed to save settings for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/competitions/:id/production/history - Get history for a competition\napp.get('/api/competitions/:id/production/history', async (req, res) => {\n  const { id } = req.params;\n\n  if (!productionConfigService.isAvailable()) {\n    return res.status(503).json({ error: 'Firebase not available' });\n  }\n\n  try {\n    const history = await productionConfigService.getHistory(id);\n    res.json(history);\n  } catch (error) {\n    console.error(`Failed to get history for ${id}:`, error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/competitions/:id/activate - Set active competition\napp.post('/api/competitions/:id/activate', async (req, res) => {\n  const { id } = req.params;\n\n  configLoader.setActiveCompetition(id);\n\n  // Initialize OBS State Sync for this competition\n  try {\n    await initializeOBSStateSync(id);\n    console.log(`OBS State Sync initialized for competition: ${id}`);\n  } catch (error) {\n    console.error(`Failed to initialize OBS State Sync for ${id}:`, error);\n    // Don't fail the activation if OBS State Sync fails\n  }\n\n  res.json({\n    success: true,\n    activeCompetitionId: id,\n    message: `Competition ${id} activated`\n  });\n});\n\n// ============================================\n// VM Pool Management API Endpoints\n// ============================================\n\n// GET /api/admin/vm-pool - Get full pool status\napp.get('/api/admin/vm-pool', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.json({\n        initialized: false,\n        message: 'VM pool manager not initialized. Call initializePool() first.',\n        config: null,\n        counts: { total: 0, available: 0, assigned: 0, inUse: 0, stopped: 0, starting: 0, stopping: 0, error: 0 },\n        vms: []\n      });\n    }\n    res.json(vmPoolManager.getPoolStatus());\n  } catch (error) {\n    console.error('Failed to get VM pool status:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/admin/vm-pool/config - Get pool configuration\napp.get('/api/admin/vm-pool/config', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    const status = vmPoolManager.getPoolStatus();\n    const awsService = getAWSService();\n    const awsConfig = awsService.getConfig();\n\n    // Merge pool config with AWS config (AMI, region, instance type)\n    res.json({\n      ...status.config,\n      region: awsConfig.region,\n      amiId: awsConfig.amiId,\n      defaultInstanceType: awsConfig.defaultInstanceType,\n    });\n  } catch (error) {\n    console.error('Failed to get VM pool config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// PUT /api/admin/vm-pool/config - Update pool configuration\napp.put('/api/admin/vm-pool/config', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const config = req.body;\n    if (!config || typeof config !== 'object') {\n      return res.status(400).json({ error: 'config must be an object' });\n    }\n    const updatedConfig = await vmPoolManager.updatePoolConfig(config);\n    res.json({ success: true, config: updatedConfig });\n  } catch (error) {\n    console.error('Failed to update VM pool config:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/admin/vm-pool/:vmId - Get single VM details\napp.get('/api/admin/vm-pool/:vmId', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const vm = vmPoolManager.getVM(vmId);\n    if (!vm) {\n      return res.status(404).json({ error: 'VM not found', vmId });\n    }\n    res.json(vm);\n  } catch (error) {\n    console.error('Failed to get VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/:vmId/start - Start a stopped VM\napp.post('/api/admin/vm-pool/:vmId/start', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const result = await vmPoolManager.startVM(vmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to start VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/:vmId/stop - Stop a VM\napp.post('/api/admin/vm-pool/:vmId/stop', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const result = await vmPoolManager.stopVM(vmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to stop VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/admin/vm-pool/launch - Launch a new VM from AMI\napp.post('/api/admin/vm-pool/launch', async (req, res) => {\n  try {\n    const awsService = getAWSService();\n    const { name, instanceType, tags } = req.body || {};\n    // Note: Project and ManagedBy tags are added automatically by awsService.launchInstance()\n    const result = await awsService.launchInstance({\n      name: name || `gymnastics-vm-${Date.now()}`,\n      instanceType,\n      tags: tags || {}\n    });\n\n    // Sync the pool to include the new instance\n    const vmPoolManager = getVMPoolManager();\n    if (vmPoolManager.isInitialized()) {\n      // Allow time for AWS to process then re-sync\n      setTimeout(async () => {\n        try {\n          await vmPoolManager._syncWithAWS();\n        } catch (syncError) {\n          console.error('Failed to sync after launch:', syncError);\n        }\n      }, 5000);\n    }\n\n    res.json({\n      success: true,\n      instance: result,\n      message: 'VM launched successfully. It will appear in the pool after startup.'\n    });\n  } catch (error) {\n    console.error('Failed to launch VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// DELETE /api/admin/vm-pool/:vmId - Terminate a VM\napp.delete('/api/admin/vm-pool/:vmId', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n    const { vmId } = req.params;\n    const vm = vmPoolManager.getVM(vmId);\n    if (!vm) {\n      return res.status(404).json({ error: 'VM not found', vmId });\n    }\n\n    // Don't allow terminating assigned VMs\n    if (vm.assignedTo) {\n      return res.status(400).json({\n        error: 'Cannot terminate assigned VM',\n        assignedTo: vm.assignedTo,\n        message: 'Release the VM from its competition first'\n      });\n    }\n\n    const awsService = getAWSService();\n    const result = await awsService.terminateInstance(vm.instanceId);\n\n    res.json({\n      success: true,\n      vmId,\n      instanceId: vm.instanceId,\n      result,\n      message: 'VM termination initiated'\n    });\n  } catch (error) {\n    console.error('Failed to terminate VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Competition VM Assignment API Endpoints\n// ============================================\n\n// POST /api/competitions/:compId/vm/assign - Assign a VM to a competition\napp.post('/api/competitions/:compId/vm/assign', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const { preferredVmId } = req.body || {};\n\n    // Check if competition already has a VM assigned\n    const existingVM = vmPoolManager.getVMForCompetition(compId);\n    if (existingVM) {\n      return res.status(400).json({\n        error: 'Competition already has a VM assigned',\n        competitionId: compId,\n        vmId: existingVM.vmId,\n        publicIp: existingVM.publicIp\n      });\n    }\n\n    const result = await vmPoolManager.assignVM(compId, preferredVmId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to assign VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/competitions/:compId/vm/release - Release a VM from a competition\napp.post('/api/competitions/:compId/vm/release', async (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const result = await vmPoolManager.releaseVM(compId);\n    res.json(result);\n  } catch (error) {\n    console.error('Failed to release VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/competitions/:compId/vm - Get the VM assigned to a competition\napp.get('/api/competitions/:compId/vm', (req, res) => {\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.status(503).json({ error: 'VM pool manager not initialized' });\n    }\n\n    const { compId } = req.params;\n    const vm = vmPoolManager.getVMForCompetition(compId);\n\n    if (!vm) {\n      return res.status(404).json({\n        error: 'No VM assigned to this competition',\n        competitionId: compId\n      });\n    }\n\n    res.json({\n      competitionId: compId,\n      vmId: vm.vmId,\n      instanceId: vm.instanceId,\n      publicIp: vm.publicIp,\n      status: vm.status,\n      services: vm.services,\n      vmAddress: vm.publicIp ? `${vm.publicIp}:${vmPoolManager.getPoolStatus().config.servicePort}` : null\n    });\n  } catch (error) {\n    console.error('Failed to get competition VM:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/vm/:compId/status - Proxy VM status check (avoids Mixed Content in production)\n// Frontend calls this instead of hitting the VM directly\napp.get('/api/vm/:compId/status', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const vmPoolManager = getVMPoolManager();\n    if (!vmPoolManager.isInitialized()) {\n      return res.json({ online: false, noVm: true, error: 'VM pool not initialized' });\n    }\n\n    // Find VM assigned to this competition\n    let vm = null;\n    for (const [, v] of vmPoolManager._vms) {\n      if (v.assignedTo === compId) {\n        vm = v;\n        break;\n      }\n    }\n\n    if (!vm || !vm.publicIp) {\n      return res.json({ online: false, noVm: true });\n    }\n\n    // Server-side request to VM (no Mixed Content issues)\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n    try {\n      const response = await fetch(`http://${vm.publicIp}:3003/api/status`, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n\n      if (response.ok) {\n        const data = await response.json();\n        return res.json({\n          online: true,\n          obsConnected: data.obsConnected || false,\n          uptime: data.uptime,\n          version: data.version\n        });\n      }\n      return res.json({ online: false, error: `HTTP ${response.status}` });\n    } catch (fetchError) {\n      clearTimeout(timeoutId);\n      const errorMessage = fetchError.name === 'AbortError' ? 'Request timeout' : fetchError.message;\n      return res.json({ online: false, error: errorMessage });\n    }\n  } catch (error) {\n    console.error(`[API] Failed to check VM status for ${compId}:`, error);\n    res.json({ online: false, error: error.message });\n  }\n});\n\n// ============================================\n// Camera Health API Endpoints\n// ============================================\n\n// GET /api/cameras/health - Get health status for all cameras\napp.get('/api/cameras/health', (req, res) => {\n  if (!cameraHealthMonitor) {\n    return res.status(503).json({ error: 'Camera health monitoring not initialized' });\n  }\n  res.json(cameraHealthMonitor.getAllHealth());\n});\n\n// GET /api/cameras/:id/health - Get health status for a specific camera\napp.get('/api/cameras/:id/health', (req, res) => {\n  if (!cameraHealthMonitor) {\n    return res.status(503).json({ error: 'Camera health monitoring not initialized' });\n  }\n  const health = cameraHealthMonitor.getCameraHealth(req.params.id);\n  if (!health) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(health);\n});\n\n// GET /api/cameras/runtime - Get runtime state for all cameras\napp.get('/api/cameras/runtime', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  res.json(cameraRuntimeState.getAllState());\n});\n\n// POST /api/cameras/:id/reassign - Reassign apparatus to a camera\napp.post('/api/cameras/:id/reassign', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  const { apparatus, assignedBy } = req.body;\n  if (!apparatus || !Array.isArray(apparatus)) {\n    return res.status(400).json({ error: 'apparatus must be an array of apparatus codes' });\n  }\n  const result = cameraRuntimeState.reassignApparatus(req.params.id, apparatus, assignedBy);\n  if (!result) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// POST /api/cameras/:id/verify - Verify a camera\napp.post('/api/cameras/:id/verify', (req, res) => {\n  if (!cameraRuntimeState) {\n    return res.status(503).json({ error: 'Camera runtime state not initialized' });\n  }\n  const { verifiedBy } = req.body || {};\n  const result = cameraRuntimeState.verifyCamera(req.params.id, verifiedBy);\n  if (!result) {\n    return res.status(404).json({ error: 'Camera not found', cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// GET /api/cameras/fallbacks - Get active fallbacks\napp.get('/api/cameras/fallbacks', (req, res) => {\n  if (!cameraFallbackManager) {\n    return res.status(503).json({ error: 'Camera fallback manager not initialized' });\n  }\n  res.json(cameraFallbackManager.getActiveFallbacks());\n});\n\n// POST /api/cameras/:id/clear-fallback - Clear fallback for a camera\napp.post('/api/cameras/:id/clear-fallback', (req, res) => {\n  if (!cameraFallbackManager) {\n    return res.status(503).json({ error: 'Camera fallback manager not initialized' });\n  }\n  const result = cameraFallbackManager.clearFallback(req.params.id);\n  if (!result.success) {\n    return res.status(404).json({ error: result.error, cameraId: req.params.id });\n  }\n  res.json(result);\n});\n\n// ============================================\n// OBS Scene Generation API Endpoints\n// ============================================\n\n// POST /api/scenes/generate - Generate OBS scenes from camera config\napp.post('/api/scenes/generate', async (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n  if (!showState.obsConnected) {\n    return res.status(503).json({ error: 'OBS not connected' });\n  }\n\n  try {\n    const { types } = req.body || {};\n\n    // If types are specified, generate only those scene types\n    // Otherwise generate all scenes\n    let results;\n    if (types && Array.isArray(types) && types.length > 0) {\n      // Generate scenes filtered by types\n      // For filtered generation, we need to manually call each type\n      results = {\n        created: [],\n        skipped: [],\n        failed: [],\n        summary: { created: 0, skipped: 0, failed: 0, total: 0 }\n      };\n\n      const graphicsUrl = obsSceneGenerator.buildGraphicsUrl();\n      const cameras = obsSceneGenerator.cameras;\n\n      // Helper to categorize results\n      const categorize = (result) => {\n        if (result.status === 'created') results.created.push(result);\n        else if (result.status === 'skipped') results.skipped.push(result);\n        else results.failed.push(result);\n      };\n\n      if (types.includes('static')) {\n        for (const name of ['Starting Soon', 'BRB', 'Thanks for Watching']) {\n          const result = await obsSceneGenerator.createStaticScene(name, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('single')) {\n        for (const camera of cameras) {\n          const result = await obsSceneGenerator.createSingleCameraScene(camera, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('dual') && cameras.length >= 2) {\n        const combos = getCombinations(cameras, 2);\n        for (const [cam1, cam2] of combos) {\n          const result = await obsSceneGenerator.createDualCameraScene(cam1, cam2, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('triple') && cameras.length >= 3) {\n        const combos = getCombinations(cameras, 3);\n        for (const [cam1, cam2, cam3] of combos) {\n          const result = await obsSceneGenerator.createTriCameraScene(cam1, cam2, cam3, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('quad') && cameras.length >= 4) {\n        const combos = getCombinations(cameras, 4);\n        for (const cams of combos) {\n          const result = await obsSceneGenerator.createQuadCameraScene(cams, graphicsUrl);\n          categorize(result);\n        }\n      }\n\n      if (types.includes('graphics')) {\n        const result = await obsSceneGenerator.createGraphicsFullscreenScene(graphicsUrl);\n        categorize(result);\n      }\n\n      results.summary.created = results.created.length;\n      results.summary.skipped = results.skipped.length;\n      results.summary.failed = results.failed.length;\n      results.summary.total = results.summary.created + results.summary.skipped + results.summary.failed;\n    } else {\n      // Generate all scenes\n      results = await obsSceneGenerator.generateAllScenes();\n    }\n\n    res.json(results);\n  } catch (error) {\n    console.error('Scene generation error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Helper function for combinations (used in filtered generation)\nfunction getCombinations(arr, size) {\n  if (size === 0) return [[]];\n  if (arr.length === 0) return [];\n  const [first, ...rest] = arr;\n  const withFirst = getCombinations(rest, size - 1).map(combo => [first, ...combo]);\n  const withoutFirst = getCombinations(rest, size);\n  return [...withFirst, ...withoutFirst];\n}\n\n// GET /api/scenes/preview - Preview what scenes would be generated\napp.get('/api/scenes/preview', (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n\n  try {\n    const types = req.query.types ? req.query.types.split(',') : undefined;\n    const preview = obsSceneGenerator.previewScenes({ types });\n    res.json(preview);\n  } catch (error) {\n    console.error('Scene preview error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// DELETE /api/scenes/generated - Delete all generated scenes\napp.delete('/api/scenes/generated', async (req, res) => {\n  if (!obsSceneGenerator) {\n    return res.status(503).json({ error: 'Scene generator not initialized' });\n  }\n  if (!showState.obsConnected) {\n    return res.status(503).json({ error: 'OBS not connected' });\n  }\n\n  try {\n    const results = await obsSceneGenerator.deleteGeneratedScenes();\n    res.json(results);\n  } catch (error) {\n    console.error('Scene deletion error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Timesheet Engine API Endpoints\n// ============================================\n\n// GET /api/timesheet/state - Get current timesheet state\napp.get('/api/timesheet/state', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getState());\n});\n\n// GET /api/timesheet/overrides - Get timesheet override history\napp.get('/api/timesheet/overrides', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getOverrides());\n});\n\n// GET /api/timesheet/history - Get segment history\napp.get('/api/timesheet/history', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  res.json(timesheetEngine.getHistory());\n});\n\n// POST /api/timesheet/start - Start the timesheet show\napp.post('/api/timesheet/start', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  try {\n    await timesheetEngine.start();\n    res.json({ success: true, state: timesheetEngine.getState() });\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/timesheet/stop - Stop the timesheet show\napp.post('/api/timesheet/stop', (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  timesheetEngine.stop();\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/advance - Advance to next segment\napp.post('/api/timesheet/advance', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { advancedBy } = req.body || {};\n  const success = await timesheetEngine.advance(advancedBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: 'Cannot advance segment', state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/previous - Go to previous segment\napp.post('/api/timesheet/previous', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { triggeredBy } = req.body || {};\n  const success = await timesheetEngine.previous(triggeredBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: 'Cannot go to previous segment', state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// POST /api/timesheet/jump - Jump to specific segment\napp.post('/api/timesheet/jump', async (req, res) => {\n  if (!timesheetEngine) {\n    return res.status(503).json({ error: 'Timesheet engine not initialized' });\n  }\n  const { segmentId, triggeredBy } = req.body || {};\n  if (!segmentId) {\n    return res.status(400).json({ error: 'segmentId is required' });\n  }\n  const success = await timesheetEngine.goToSegment(segmentId, triggeredBy || 'api');\n  if (!success) {\n    return res.status(400).json({ error: `Cannot jump to segment: ${segmentId}`, state: timesheetEngine.getState() });\n  }\n  res.json({ success: true, state: timesheetEngine.getState() });\n});\n\n// ============================================\n// Alert System API Endpoints\n// ============================================\n\n// GET /api/alerts/:compId - Get active alerts for a competition\napp.get('/api/alerts/:compId', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      // Try to initialize\n      try {\n        await alertService.initialize();\n      } catch (initError) {\n        return res.status(503).json({\n          error: 'Alert service not initialized',\n          details: 'Firebase credentials not configured'\n        });\n      }\n    }\n\n    const alerts = await alertService.getActiveAlerts(compId);\n    res.json(alerts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get alerts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/alerts/:compId/counts - Get alert counts for a competition\napp.get('/api/alerts/:compId/counts', async (req, res) => {\n  const { compId } = req.params;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized',\n        details: 'Firebase credentials not configured'\n      });\n    }\n\n    const counts = await alertService.getAlertCounts(compId);\n    res.json(counts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get counts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// GET /api/alerts/:compId/all - Get all alerts (including resolved)\napp.get('/api/alerts/:compId/all', async (req, res) => {\n  const { compId } = req.params;\n  const { includeResolved, limit } = req.query;\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alerts = await alertService.getAllAlerts(compId, {\n      includeResolved: includeResolved !== 'false',\n      limit: limit ? parseInt(limit, 10) : 100\n    });\n    res.json(alerts);\n  } catch (error) {\n    console.error(`[Alerts API] Failed to get all alerts for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId - Create a new alert\napp.post('/api/alerts/:compId', async (req, res) => {\n  const { compId } = req.params;\n  const { level, category, title, message, sourceId, metadata } = req.body;\n\n  // Validate required fields\n  if (!level || !category || !title || !message) {\n    return res.status(400).json({\n      error: 'Missing required fields',\n      required: ['level', 'category', 'title', 'message']\n    });\n  }\n\n  // Validate level\n  if (!Object.values(ALERT_LEVEL).includes(level)) {\n    return res.status(400).json({\n      error: `Invalid alert level: ${level}`,\n      validLevels: Object.values(ALERT_LEVEL)\n    });\n  }\n\n  // Validate category\n  if (!Object.values(ALERT_CATEGORY).includes(category)) {\n    return res.status(400).json({\n      error: `Invalid alert category: ${category}`,\n      validCategories: Object.values(ALERT_CATEGORY)\n    });\n  }\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      try {\n        await alertService.initialize();\n      } catch (initError) {\n        return res.status(503).json({\n          error: 'Alert service not initialized',\n          details: 'Firebase credentials not configured'\n        });\n      }\n    }\n\n    const alert = await alertService.createAlert(compId, {\n      level,\n      category,\n      title,\n      message,\n      sourceId: sourceId || null,\n      metadata: metadata || {}\n    });\n\n    res.json({ success: true, id: alert.id, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to create alert for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/:alertId/acknowledge - Acknowledge an alert\napp.post('/api/alerts/:compId/:alertId/acknowledge', async (req, res) => {\n  const { compId, alertId } = req.params;\n  const { acknowledgedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alert = await alertService.acknowledgeAlert(compId, alertId, acknowledgedBy || 'api');\n\n    if (!alert) {\n      return res.status(404).json({\n        error: 'Alert not found',\n        alertId\n      });\n    }\n\n    res.json({ success: true, acknowledged: true, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to acknowledge alert ${alertId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/:alertId/resolve - Resolve an alert\napp.post('/api/alerts/:compId/:alertId/resolve', async (req, res) => {\n  const { compId, alertId } = req.params;\n  const { resolvedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const alert = await alertService.resolveAlert(compId, alertId, resolvedBy || 'api', false);\n\n    if (!alert) {\n      return res.status(404).json({\n        error: 'Alert not found',\n        alertId\n      });\n    }\n\n    res.json({ success: true, resolved: true, alert });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to resolve alert ${alertId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/resolve-by-source - Resolve alerts by source ID\napp.post('/api/alerts/:compId/resolve-by-source', async (req, res) => {\n  const { compId } = req.params;\n  const { sourceId, resolvedBy } = req.body || {};\n\n  if (!sourceId) {\n    return res.status(400).json({\n      error: 'sourceId is required'\n    });\n  }\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const count = await alertService.resolveBySourceId(compId, sourceId, resolvedBy || 'api');\n    res.json({ success: true, count });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to resolve by sourceId ${sourceId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// POST /api/alerts/:compId/acknowledge-all - Acknowledge all alerts\napp.post('/api/alerts/:compId/acknowledge-all', async (req, res) => {\n  const { compId } = req.params;\n  const { acknowledgedBy } = req.body || {};\n\n  try {\n    const alertService = getAlertService();\n\n    if (!alertService.isInitialized()) {\n      return res.status(503).json({\n        error: 'Alert service not initialized'\n      });\n    }\n\n    const count = await alertService.acknowledgeAll(compId, acknowledgedBy || 'api');\n    res.json({ success: true, count });\n  } catch (error) {\n    console.error(`[Alerts API] Failed to acknowledge all for ${compId}:`, error.message);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// ============================================\n// Coordinator Health API Endpoints\n// ============================================\n\n// GET /api/coordinator/status - Get coordinator health and status\napp.get('/api/coordinator/status', async (req, res) => {\n  updateLastActivity();\n\n  const isCoordinatorMode = process.env.COORDINATOR_MODE === 'true';\n\n  // Check Firebase connection status\n  let firebaseStatus = 'unknown';\n  try {\n    if (productionConfigService.isAvailable()) {\n      firebaseStatus = 'connected';\n    } else {\n      firebaseStatus = 'unavailable';\n    }\n  } catch (error) {\n    firebaseStatus = 'error';\n  }\n\n  // Check AWS SDK status (can we reach EC2 API?)\n  let awsStatus = 'unknown';\n  try {\n    const awsService = getAWSService();\n    // Try a simple describe call with a filter that returns quickly\n    await awsService.describeInstances({ limit: 1 });\n    awsStatus = 'connected';\n  } catch (error) {\n    // Check if it's a credentials error vs network error\n    if (error.name === 'CredentialsProviderError' || error.message?.includes('credentials')) {\n      awsStatus = 'no_credentials';\n    } else if (error.code === 'ENOTFOUND' || error.code === 'ETIMEDOUT') {\n      awsStatus = 'unreachable';\n    } else {\n      awsStatus = 'error';\n    }\n  }\n\n  // Check OBS connection status\n  const obsStatus = showState.obsConnected ? 'connected' : 'disconnected';\n\n  // Get auto-shutdown status if initialized\n  const autoShutdown = getAutoShutdownService();\n  const autoShutdownStatus = autoShutdown.isInitialized() ? autoShutdown.getStatus() : null;\n\n  // Build response\n  // Include 'state' and 'appReady' fields for frontend compatibility\n  // (frontend expects EC2-style state from Netlify functions)\n  const status = {\n    success: true,\n    state: 'running',  // EC2-style state for frontend\n    appReady: true,    // App is responding, so it's ready\n    status: 'online',\n    uptime: getUptime(),\n    uptimeFormatted: formatUptime(getUptime()),\n    version: SERVER_VERSION,\n    mode: isCoordinatorMode ? 'coordinator' : 'standalone',\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    idleSeconds: getIdleTime(),\n    idleMinutes: Math.floor(getIdleTime() / 60),\n    publicIp: process.env.PUBLIC_IP || null,\n    connections: {\n      firebase: firebaseStatus,\n      aws: awsStatus,\n      obs: obsStatus\n    },\n    connectedClients: showState.connectedClients.length,\n    autoShutdown: autoShutdownStatus\n  };\n\n  res.json(status);\n});\n\n// GET /api/coordinator/activity - Get last activity timestamp\napp.get('/api/coordinator/activity', (req, res) => {\n  res.json({\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    idleSeconds: getIdleTime()\n  });\n});\n\n// POST /api/coordinator/activity - Update last activity timestamp (keep-alive)\napp.post('/api/coordinator/activity', (req, res) => {\n  updateLastActivity();\n  res.json({\n    success: true,\n    lastActivity: new Date(lastActivityTimestamp).toISOString()\n  });\n});\n\n// GET /api/coordinator/idle - Get detailed idle status for auto-shutdown (P19-02)\napp.get('/api/coordinator/idle', (req, res) => {\n  const autoShutdown = getAutoShutdownService();\n  const idleSeconds = getIdleTime();\n  const idleMinutes = Math.floor(idleSeconds / 60);\n\n  // Get auto-shutdown config if available\n  const autoShutdownStatus = autoShutdown.isInitialized() ? autoShutdown.getStatus() : null;\n\n  res.json({\n    idleSeconds,\n    idleMinutes,\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    autoShutdown: autoShutdownStatus ? {\n      enabled: autoShutdownStatus.enabled,\n      timeoutMinutes: autoShutdownStatus.idleTimeoutMinutes,\n      shutdownPending: autoShutdownStatus.shutdownPending,\n      timeUntilShutdown: autoShutdownStatus.enabled\n        ? Math.max(0, autoShutdownStatus.idleTimeoutMinutes - idleMinutes)\n        : null\n    } : null\n  });\n});\n\n// POST /api/coordinator/keep-alive - Reset activity and cancel pending shutdown (P19-02)\napp.post('/api/coordinator/keep-alive', (req, res) => {\n  // Update local activity timestamp\n  updateLastActivity();\n\n  // Also update auto-shutdown service if initialized\n  const autoShutdown = getAutoShutdownService();\n  if (autoShutdown.isInitialized()) {\n    autoShutdown.keepAlive();\n  }\n\n  res.json({\n    success: true,\n    lastActivity: new Date(lastActivityTimestamp).toISOString(),\n    message: 'Keep-alive received, activity timestamp updated'\n  });\n});\n\n/**\n * Format uptime seconds into human readable string\n * @param {number} seconds - Uptime in seconds\n * @returns {string} Formatted uptime\n */\nfunction formatUptime(seconds) {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n\n  const parts = [];\n  if (days > 0) parts.push(`${days}d`);\n  if (hours > 0) parts.push(`${hours}h`);\n  if (minutes > 0) parts.push(`${minutes}m`);\n  if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);\n\n  return parts.join(' ');\n}\n\n// CSV Upload endpoint\napp.post('/api/import-csv', upload.single('csv'), (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No CSV file uploaded' });\n    }\n\n    const csvContent = req.file.buffer.toString('utf-8');\n    const records = parse(csvContent, {\n      columns: true,\n      skip_empty_lines: true,\n      trim: true\n    });\n\n    if (records.length === 0) {\n      return res.status(400).json({ error: 'CSV file is empty' });\n    }\n\n    // Get show name from query param or first row or default\n    const showName = req.body.showName || req.query.showName || 'Imported Show';\n\n    // Convert CSV records to segments\n    const segments = records.map((row, index) => {\n      // Generate ID from name if not provided\n      const id = row.id || row.name?.toLowerCase().replace(/[^a-z0-9]+/g, '-') || `segment-${index}`;\n\n      // Parse duration (can be \"mm:ss\" format or just seconds)\n      let duration = null;\n      if (row.duration) {\n        if (row.duration.includes(':')) {\n          const [mins, secs] = row.duration.split(':').map(Number);\n          duration = mins * 60 + secs;\n        } else {\n          duration = parseInt(row.duration) || null;\n        }\n      }\n\n      // Parse autoAdvance (various true/false formats)\n      const autoAdvance = ['true', 'yes', '1', 'auto'].includes(\n        (row.autoAdvance || row.auto_advance || row.auto || '').toLowerCase()\n      );\n\n      // Build segment object\n      const segment = {\n        id,\n        name: row.name || row.segment_name || row.title || `Segment ${index + 1}`,\n        type: row.type || 'live',\n        obsScene: row.obsScene || row.obs_scene || row.scene || null,\n        duration,\n        autoAdvance,\n        notes: row.notes || row.description || null,\n        videoFile: row.videoFile || row.video_file || row.video || null\n      };\n\n      // Add graphic if specified\n      if (row.graphic) {\n        segment.graphic = row.graphic;\n\n        // Parse graphicData if provided as JSON string\n        if (row.graphicData || row.graphic_data) {\n          try {\n            segment.graphicData = JSON.parse(row.graphicData || row.graphic_data);\n          } catch (e) {\n            // If not valid JSON, try to parse as key=value pairs\n            const data = {};\n            const dataStr = row.graphicData || row.graphic_data;\n            if (dataStr.includes('=')) {\n              dataStr.split(';').forEach(pair => {\n                const [key, value] = pair.split('=');\n                if (key && value) data[key.trim()] = value.trim();\n              });\n              segment.graphicData = data;\n            }\n          }\n        }\n      }\n\n      return segment;\n    });\n\n    // Build the show config\n    const newConfig = {\n      showName,\n      segments,\n      sponsors: showConfig?.sponsors || {},\n      quickActions: showConfig?.quickActions || []\n    };\n\n    // Save to file\n    const configPath = join(__dirname, 'config', 'show-config.json');\n    writeFileSync(configPath, JSON.stringify(newConfig, null, 2));\n\n    // Reload config (the file watcher will also trigger this)\n    loadShowConfig();\n    broadcastState();\n\n    res.json({\n      success: true,\n      message: `Imported ${segments.length} segments`,\n      segments: segments.length,\n      showName\n    });\n\n  } catch (error) {\n    console.error('CSV import error:', error);\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Virtius API proxy (avoids CORS issues)\napp.get('/api/virtius/:sessionId', async (req, res) => {\n  try {\n    const response = await fetch(`https://api.virti.us/session/${req.params.sessionId}/json`);\n    if (!response.ok) {\n      return res.status(404).json({ error: 'Virtius session not found' });\n    }\n    const data = await response.json();\n    res.json(data);\n  } catch (error) {\n    console.error('Virtius API error:', error.message);\n    res.status(500).json({ error: 'Failed to fetch Virtius session' });\n  }\n});\n\n// Get CSV template\napp.get('/api/csv-template', (req, res) => {\n  const template = `id,name,type,obsScene,duration,autoAdvance,graphic,graphicData,videoFile,notes\nintro,Show Intro,video,Video Scene,0:45,true,,,/path/to/videos/intro.mp4,Intro video plays automatically\nwelcome,Welcome & Host Intro,live,Talent Camera,,,,,,Welcome viewers and introduce sponsors\nevent-intro,Event Introduction,graphic,Graphics,8,true,event-bar,,,\nteam1-stats,Team 1 Stats,graphic,Graphics,10,true,team1-stats,,,\nrotation1-floor,Floor Exercise Intro,graphic,Graphics,5,true,event-frame,frameTitle=FLOOR EXERCISE,,\nrotation1-floor-live,Floor Exercise,live,Competition Camera,,,,,,Floor exercise routines\nhalftime-video,Halftime Video,video,Video Scene,2:00,true,,,/path/to/videos/halftime.mp4,Plays sponsor video\nhalftime,Halftime Break,live,BRB,5:00,false,,,,5 minute break\nclosing,Closing Remarks,live,Talent Camera,,,,,,Thank viewers and recap\noutro,Thanks for Watching,video,Video Scene,0:15,false,,,/path/to/videos/outro.mp4,End card video`;\n\n  res.setHeader('Content-Type', 'text/csv');\n  res.setHeader('Content-Disposition', 'attachment; filename=\"show-template.csv\"');\n  res.send(template);\n});\n\n// Setup OBS Scene CRUD API routes (OBS-06)\n// Pass getter function for obsStateSync since it may be null until competition is activated\nsetupOBSRoutes(app, obs, () => obsStateSync);\n\n// Redirect Netlify function paths to API endpoints (for compatibility when not on Netlify)\napp.get('/.netlify/functions/coordinator-status', (req, res) => {\n  res.redirect(307, '/api/coordinator/status');\n});\napp.post('/.netlify/functions/wake-coordinator', (req, res) => {\n  res.redirect(307, '/api/coordinator/wake');\n});\napp.post('/.netlify/functions/stop-coordinator', (req, res) => {\n  res.redirect(307, '/api/coordinator/stop');\n});\n\n// Serve React app for all other routes (Express 5 syntax)\napp.get('/{*path}', (req, res) => {\n  res.sendFile(join(__dirname, '..', 'show-controller', 'dist', 'index.html'));\n});\n\n// Helper function to categorize scene by name (for coordinator)\n// Note: This function mirrors the categorization logic from obsStateSync.js\n// but operates independently since obsStateSync is only for local development\nfunction categorizeSceneByName(sceneName, templateScenes = []) {\n  if (!sceneName) {\n    return 'manual';\n  }\n\n  // Check if scene is in templateScenes list (from Firebase)\n  if (templateScenes && templateScenes.includes(sceneName)) {\n    return 'template';\n  }\n\n  const name = sceneName.toLowerCase();\n\n  // Generated single-camera scenes\n  // Template patterns: \"Full Screen - Camera X\", \"Replay - Camera X\"\n  // Legacy patterns: \"Single - Camera X\"\n  if (name.startsWith('full screen - ') ||\n      name.startsWith('replay - ') ||\n      name.startsWith('single - ')) {\n    return 'generated-single';\n  }\n\n  // Generated multi-camera scenes\n  // Template patterns: \"Dual View - ...\", \"Triple View - ...\", \"Quad View\"\n  // Legacy patterns: \"Dual - ...\", \"Triple - ...\", \"Quad - ...\"\n  if (name.startsWith('dual view') ||\n      name.startsWith('triple view') ||\n      name.startsWith('quad view') ||\n      name === 'quad view' ||\n      name.startsWith('dual - ') ||\n      name.startsWith('triple - ') ||\n      name.startsWith('quad - ')) {\n    return 'generated-multi';\n  }\n\n  // Static production scenes\n  // Template patterns: \"Stream Starting Soon\", \"End Stream\"\n  // Legacy patterns: \"Starting Soon\", \"BRB\", \"Thanks for Watching\", \"Be Right Back\"\n  const staticScenes = ['starting soon', 'brb', 'thanks for watching', 'be right back', 'end stream'];\n  if (staticScenes.some(s => name.includes(s))) {\n    return 'static';\n  }\n\n  // Graphics-only scenes\n  // Template pattern: \"Web-graphics-only-no-video\"\n  // Legacy pattern: \"Graphics Fullscreen\"\n  if (name.includes('graphics fullscreen') ||\n      name.includes('web-graphics-only') ||\n      name.includes('graphics-only')) {\n    return 'graphics';\n  }\n\n  // Everything else is manual\n  return 'manual';\n}\n\n// Helper function to fetch and broadcast OBS state for a competition\nasync function broadcastOBSState(compId, obsConnManager, io) {\n  const room = `competition:${compId}`;\n  const compObs = obsConnManager.getConnection(compId);\n\n  if (!compObs) {\n    console.log(`[broadcastOBSState] No OBS connection for ${compId}`);\n    return;\n  }\n\n  try {\n    // Fetch template scenes from Firebase for proper categorization\n    let templateScenes = [];\n    try {\n      const db = productionConfigService.getDb();\n      if (db) {\n        const snapshot = await db.ref(`competitions/${compId}/obs/templateScenes`).once('value');\n        templateScenes = snapshot.val() || [];\n        if (!Array.isArray(templateScenes)) {\n          templateScenes = [];\n        }\n      }\n    } catch (fbError) {\n      console.log(`[broadcastOBSState] Could not fetch template scenes: ${fbError.message}`);\n    }\n\n    // Fetch scene list\n    const sceneListResponse = await compObs.call('GetSceneList');\n    const currentScene = sceneListResponse.currentProgramSceneName || null;\n\n    // Fetch scene items for each scene\n    const scenes = await Promise.all((sceneListResponse.scenes || []).map(async (scene) => {\n      let items = [];\n      try {\n        const itemsResponse = await compObs.call('GetSceneItemList', { sceneName: scene.sceneName });\n        items = (itemsResponse.sceneItems || []).map(item => ({\n          id: item.sceneItemId,\n          sourceName: item.sourceName,\n          sourceType: item.sourceType,\n          inputKind: item.inputKind,\n          enabled: item.sceneItemEnabled,\n          locked: item.sceneItemLocked,\n          transform: item.sceneItemTransform\n        }));\n      } catch (itemError) {\n        console.log(`[broadcastOBSState] Could not fetch items for scene ${scene.sceneName}: ${itemError.message}`);\n      }\n      return {\n        name: scene.sceneName,\n        sceneName: scene.sceneName, // Include both for compatibility\n        uuid: scene.sceneUuid,\n        index: scene.sceneIndex,\n        items,\n        category: categorizeSceneByName(scene.sceneName, templateScenes)\n      };\n    }));\n\n    // Fetch ALL inputs (sources)\n    let inputs = [];\n    let audioSources = [];\n    try {\n      const inputsResponse = await compObs.call('GetInputList');\n      inputs = (inputsResponse.inputs || []).map(input => ({\n        name: input.inputName,\n        kind: input.inputKind,\n        uuid: input.inputUuid\n      }));\n      // Also filter for audio sources separately\n      // Include sources that can produce audio: dedicated audio, media sources, and browser sources\n      const audioInputs = inputs.filter(input =>\n        input.kind?.includes('audio') ||\n        input.kind?.includes('wasapi') ||\n        input.kind?.includes('pulse') ||\n        input.kind?.includes('coreaudio') ||\n        input.kind === 'ffmpeg_source' ||     // Media sources (video files, SRT streams)\n        input.kind === 'browser_source'        // Browser sources (VDO.Ninja talent)\n      );\n\n      // Fetch volume/mute/monitor status for each audio source\n      audioSources = await Promise.all(audioInputs.map(async (input) => {\n        try {\n          const [volumeRes, muteRes, monitorRes] = await Promise.all([\n            compObs.call('GetInputVolume', { inputName: input.name }),\n            compObs.call('GetInputMute', { inputName: input.name }),\n            compObs.call('GetInputAudioMonitorType', { inputName: input.name })\n          ]);\n          return {\n            inputName: input.name,\n            kind: input.kind,\n            uuid: input.uuid,\n            volumeDb: volumeRes.inputVolumeDb ?? 0,\n            volumeMul: volumeRes.inputVolumeMul ?? 1,\n            muted: muteRes.inputMuted ?? false,\n            monitorType: monitorRes.monitorType ?? 'OBS_MONITORING_TYPE_NONE'\n          };\n        } catch (e) {\n          // Source might not have audio capabilities - skip it\n          console.log(`[broadcastOBSState] Skipping audio source ${input.name}: ${e.message}`);\n          return null;\n        }\n      }));\n      // Filter out nulls (sources that don't have audio)\n      audioSources = audioSources.filter(s => s !== null);\n    } catch (audioError) {\n      console.log(`[broadcastOBSState] Could not fetch inputs for ${compId}: ${audioError.message}`);\n    }\n\n    // Fetch transitions (PRD-OBS-05: Transition Management)\n    let transitions = [];\n    let currentTransition = null;\n    let transitionDuration = 300;\n    try {\n      const transitionResponse = await compObs.call('GetSceneTransitionList');\n      transitions = (transitionResponse.transitions || []).map(t => ({\n        name: t.transitionName,\n        kind: t.transitionKind,\n        configurable: t.transitionConfigurable || false\n      }));\n      currentTransition = transitionResponse.currentSceneTransitionName;\n      transitionDuration = transitionResponse.currentSceneTransitionDuration || 300;\n    } catch (transitionError) {\n      console.log(`[broadcastOBSState] Could not fetch transitions for ${compId}: ${transitionError.message}`);\n    }\n\n    // Fetch studio mode state (PRD-OBS-11: Advanced Features)\n    let studioModeEnabled = false;\n    let previewScene = null;\n    try {\n      const studioModeResponse = await compObs.call('GetStudioModeEnabled');\n      studioModeEnabled = studioModeResponse.studioModeEnabled || false;\n\n      if (studioModeEnabled) {\n        const previewResponse = await compObs.call('GetCurrentPreviewScene');\n        previewScene = previewResponse.currentPreviewSceneName || null;\n      }\n    } catch (studioError) {\n      console.log(`[broadcastOBSState] Could not fetch studio mode state for ${compId}: ${studioError.message}`);\n    }\n\n    // Broadcast full state\n    const obsState = {\n      connected: true,\n      connectionError: null,\n      scenes,\n      currentScene,\n      previewScene,\n      studioModeEnabled,\n      inputs,\n      audioSources,\n      transitions,\n      currentTransition,\n      transitionDuration,\n      isStreaming: false,\n      isRecording: false\n    };\n\n    console.log(`[broadcastOBSState] Broadcasting for ${compId}: ${scenes.length} scenes, current: ${currentScene}, studioMode: ${studioModeEnabled}, inputs: ${inputs.length}`);\n    io.to(room).emit('obs:stateUpdated', obsState);\n  } catch (error) {\n    console.error(`[broadcastOBSState] Failed to fetch state for ${compId}:`, error.message);\n  }\n}\n\n// Socket.io connection handling\nio.on('connection', async (socket) => {\n  // Extract compId from connection query (sent by frontend)\n  const clientCompId = socket.handshake.query.compId;\n  console.log(`Client connected: ${socket.id} for competition: ${clientCompId || 'none'}`);\n\n  // Track activity on every socket event using socket.io middleware\n  socket.use((packet, next) => {\n    updateLastActivity();\n    const autoShutdown = getAutoShutdownService();\n    if (autoShutdown.isInitialized()) {\n      autoShutdown.resetActivity();\n    }\n    next();\n  });\n\n  // If client has a compId, try to connect to that competition's VM OBS\n  if (clientCompId && clientCompId !== 'local') {\n    try {\n      // Join a room for this competition to receive targeted broadcasts\n      socket.join(`competition:${clientCompId}`);\n\n      // Look up VM for this competition\n      const vmPoolManager = getVMPoolManager();\n      if (vmPoolManager.isInitialized()) {\n        const vm = vmPoolManager.getVMForCompetition(clientCompId);\n        if (vm && vm.publicIp) {\n          console.log(`[Socket] Competition ${clientCompId} has VM at ${vm.publicIp}`);\n\n          // Connect to OBS on that VM (if not already connected)\n          const obsConnManager = getOBSConnectionManager();\n          if (!obsConnManager.isConnected(clientCompId)) {\n            try {\n              await obsConnManager.connectToVM(clientCompId, vm.publicIp);\n              console.log(`[Socket] Connected to OBS for competition ${clientCompId}`);\n            } catch (obsError) {\n              console.warn(`[Socket] Failed to connect to OBS for ${clientCompId}: ${obsError.message}`);\n              // Continue without OBS - some features won't work\n            }\n          }\n        } else {\n          console.log(`[Socket] No VM assigned to competition ${clientCompId}`);\n        }\n      }\n\n      // Set active competition so REST API routes can access the competition ID\n      configLoader.setActiveCompetition(clientCompId);\n      console.log(`[Socket] Active competition set to ${clientCompId}`);\n\n      // Initialize OBS State Sync for this competition (enables REST API routes)\n      try {\n        await initializeOBSStateSync(clientCompId);\n        console.log(`[Socket] OBS State Sync initialized for competition ${clientCompId}`);\n      } catch (syncError) {\n        console.warn(`[Socket] Failed to initialize OBS State Sync for ${clientCompId}: ${syncError.message}`);\n        // Continue - Socket.io events will still work, but REST API endpoints won't\n      }\n    } catch (error) {\n      console.error(`[Socket] Error setting up competition ${clientCompId}:`, error.message);\n    }\n  }\n\n  // Add client to list\n  const clientInfo = {\n    id: socket.id,\n    role: 'unknown',\n    name: 'Unknown',\n    compId: clientCompId || null\n  };\n  showState.connectedClients.push(clientInfo);\n\n  // Send initial state\n  socket.emit('connected', {\n    clientId: socket.id,\n    state: {\n      ...showState,\n      showConfig: showConfig ? {\n        showName: showConfig.showName,\n        segments: showConfig.segments,\n        sponsors: showConfig.sponsors\n      } : null\n    }\n  });\n\n  // Send initial camera state if available\n  if (cameraHealthMonitor) {\n    socket.emit('cameraHealth', cameraHealthMonitor.getAllHealth());\n  }\n  if (cameraRuntimeState) {\n    socket.emit('cameraRuntimeState', cameraRuntimeState.getAllState());\n  }\n  if (cameraFallbackManager) {\n    socket.emit('activeFallbacks', cameraFallbackManager.getActiveFallbacks());\n  }\n\n  // Send initial timesheet state if available\n  if (timesheetEngine) {\n    socket.emit('timesheetState', timesheetEngine.getState());\n  }\n\n  // Send initial OBS state if available\n  // First, try to get OBS state from the competition's VM connection\n  if (clientCompId && clientCompId !== 'local') {\n    const obsConnManager = getOBSConnectionManager();\n    const connState = obsConnManager.getConnectionState(clientCompId);\n    if (connState) {\n      // Send basic connection info immediately\n      socket.emit('obs:stateUpdated', {\n        connected: connState.connected,\n        connectionError: connState.error\n      });\n      // If connected, also broadcast full OBS state (scenes, current scene, etc.)\n      if (connState.connected) {\n        broadcastOBSState(clientCompId, obsConnManager, io);\n      }\n    }\n  } else if (obsStateSync && obsStateSync.isInitialized()) {\n    // Fall back to local OBS state\n    socket.emit('obs:stateUpdated', obsStateSync.getState());\n  }\n\n  broadcastState();\n\n  // Client identifies themselves\n  socket.on('identify', ({ role, name }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client) {\n      client.role = role;\n      client.name = name;\n      console.log(`Client ${socket.id} identified as ${role}: ${name}`);\n      broadcastState();\n    }\n  });\n\n  // Advance to next segment\n  socket.on('advance', async () => {\n    const success = await advanceSegment(socket.id);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot advance' });\n    }\n  });\n\n  // Go to previous segment\n  socket.on('previous', async () => {\n    const success = await previousSegment();\n    if (!success) {\n      socket.emit('error', { message: 'Cannot go back' });\n    }\n  });\n\n  // Jump to specific segment\n  socket.on('jumpTo', async ({ segmentId }) => {\n    const success = await jumpToSegment(segmentId);\n    if (!success) {\n      socket.emit('error', { message: `Cannot jump to segment: ${segmentId}` });\n    }\n  });\n\n  // Override scene (producer only)\n  socket.on('overrideScene', async ({ sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override scenes' });\n      return;\n    }\n\n    const success = await switchScene(sceneName);\n    if (!success) {\n      socket.emit('error', { message: `Failed to switch to scene: ${sceneName}` });\n    }\n  });\n\n  // Switch scene (alias for overrideScene - used by OBS Manager UI)\n  socket.on('switchScene', async ({ sceneName }) => {\n    console.log(`[switchScene] Received request to switch to: ${sceneName}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    console.log(`[switchScene] Client:`, client ? { id: client.id, role: client.role, compId: client.compId } : 'not found');\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can switch scenes' });\n      return;\n    }\n\n    // Get the client's competition ID to use the per-competition OBS connection\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    // Use per-competition OBS connection\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentProgramScene', { sceneName });\n      console.log(`[switchScene] Switched to scene: ${sceneName} for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[switchScene] Failed to switch scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to switch to scene: ${sceneName}` });\n    }\n  });\n\n  // Create scene (producer only) - supports creating from template\n  socket.on('obs:createScene', async ({ sceneName, templateId }) => {\n    console.log(`[createScene] Received request to create: ${sceneName}${templateId ? ` from template ${templateId}` : ''}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can create scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Create the scene first\n      await compObs.call('CreateScene', { sceneName });\n      console.log(`[createScene] Created scene: ${sceneName} for ${clientCompId}`);\n\n      // If templateId is provided, copy sources from template to the new scene\n      if (templateId) {\n        try {\n          // Fetch the template from Firebase via productionConfigService\n          productionConfigService.initialize();\n          if (productionConfigService.isAvailable()) {\n            // Use Firebase Admin SDK directly to read template\n            const admin = await import('firebase-admin');\n            const database = admin.default.database();\n            const templateRef = database.ref(`templates/obs/${templateId}`);\n            const snapshot = await templateRef.once('value');\n            const template = snapshot.val();\n\n            if (template && template.scenes && template.scenes.length > 0) {\n              // Use the first scene from the template as the source configuration\n              const templateScene = template.scenes[0];\n              const items = templateScene.items || templateScene.sceneItems || [];\n\n              console.log(`[createScene] Copying ${items.length} items from template to ${sceneName}`);\n\n              // Add each item from the template to the new scene\n              for (const item of items) {\n                try {\n                  // CreateSceneItem adds an existing input to the scene\n                  await compObs.call('CreateSceneItem', {\n                    sceneName: sceneName,\n                    sourceName: item.sourceName,\n                    sceneItemEnabled: item.sceneItemEnabled !== undefined ? item.sceneItemEnabled : true\n                  });\n                  console.log(`[createScene] Added source ${item.sourceName} to ${sceneName}`);\n                } catch (itemError) {\n                  // Source might not exist - that's okay, just log and continue\n                  console.warn(`[createScene] Could not add source ${item.sourceName}: ${itemError.message}`);\n                }\n              }\n              console.log(`[createScene] Created scene from template: ${sceneName} for ${clientCompId}`);\n\n              // Store scene name in templateScenes list in Firebase for proper categorization\n              try {\n                const templateScenesRef = database.ref(`competitions/${clientCompId}/obs/templateScenes`);\n                const templateScenesSnapshot = await templateScenesRef.once('value');\n                let templateScenes = templateScenesSnapshot.val() || [];\n                if (!Array.isArray(templateScenes)) {\n                  templateScenes = [];\n                }\n                if (!templateScenes.includes(sceneName)) {\n                  templateScenes.push(sceneName);\n                  await templateScenesRef.set(templateScenes);\n                  console.log(`[createScene] Added ${sceneName} to templateScenes list`);\n                }\n              } catch (fbError) {\n                console.warn(`[createScene] Could not update templateScenes list: ${fbError.message}`);\n              }\n            } else {\n              console.warn(`[createScene] Template ${templateId} has no scenes, created empty scene`);\n            }\n          } else {\n            console.warn('[createScene] Firebase not available, created empty scene');\n          }\n        } catch (templateError) {\n          // Template copy failed but scene was created - log warning but don't fail\n          console.warn(`[createScene] Failed to copy template content: ${templateError.message}`);\n          socket.emit('obs:warning', { message: `Scene created but template copy failed: ${templateError.message}` });\n        }\n      }\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[createScene] Failed to create scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to create scene: ${sceneName}` });\n    }\n  });\n\n  // Delete scene (producer only)\n  socket.on('obs:deleteScene', async ({ sceneName }) => {\n    console.log(`[deleteScene] Received request to delete: ${sceneName}`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('RemoveScene', { sceneName });\n      console.log(`[deleteScene] Deleted scene: ${sceneName} for ${clientCompId}`);\n\n      // Remove scene from templateScenes list in Firebase if present\n      try {\n        const db = productionConfigService.getDb();\n        if (db) {\n          const templateScenesRef = db.ref(`competitions/${clientCompId}/obs/templateScenes`);\n          const templateScenesSnapshot = await templateScenesRef.once('value');\n          let templateScenes = templateScenesSnapshot.val() || [];\n          if (Array.isArray(templateScenes) && templateScenes.includes(sceneName)) {\n            templateScenes = templateScenes.filter(s => s !== sceneName);\n            await templateScenesRef.set(templateScenes);\n            console.log(`[deleteScene] Removed ${sceneName} from templateScenes list`);\n          }\n        }\n      } catch (fbError) {\n        console.warn(`[deleteScene] Could not update templateScenes list: ${fbError.message}`);\n      }\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteScene] Failed to delete scene: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete scene: ${sceneName}` });\n    }\n  });\n\n  // Delete all scenes (producer only)\n  socket.on('obs:deleteAllScenes', async () => {\n    console.log(`[deleteAllScenes] Received request to delete all scenes`);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get all scenes\n      const sceneListResponse = await compObs.call('GetSceneList');\n      const scenes = sceneListResponse.scenes || [];\n      const currentScene = sceneListResponse.currentProgramSceneName;\n\n      if (scenes.length === 0) {\n        socket.emit('obs:deleteAllScenesResult', { success: true, deletedCount: 0, message: 'No scenes to delete' });\n        return;\n      }\n\n      // OBS requires at least one scene, so we need to create a temporary scene first\n      // if we're deleting everything\n      const tempSceneName = '__temp_delete_all__';\n\n      // Check if temp scene already exists (from a previous failed attempt)\n      const tempSceneExists = scenes.some(s => (s.sceneName || s.name) === tempSceneName);\n\n      if (!tempSceneExists) {\n        await compObs.call('CreateScene', { sceneName: tempSceneName });\n      }\n\n      // Switch to the temp scene so we can delete all others\n      await compObs.call('SetCurrentProgramScene', { sceneName: tempSceneName });\n\n      let deletedCount = 0;\n      const errors = [];\n\n      // Delete all original scenes (skip the temp scene if it was pre-existing)\n      for (const scene of scenes) {\n        const sceneName = scene.sceneName || scene.name;\n        // Skip the temp scene - we'll rename it at the end\n        if (sceneName === tempSceneName) {\n          continue;\n        }\n        try {\n          await compObs.call('RemoveScene', { sceneName });\n          deletedCount++;\n          console.log(`[deleteAllScenes] Deleted scene: ${sceneName}`);\n        } catch (err) {\n          console.error(`[deleteAllScenes] Failed to delete scene ${sceneName}: ${err.message}`);\n          errors.push({ sceneName, error: err.message });\n        }\n      }\n\n      // Now delete the temp scene - this will fail because OBS requires at least one scene\n      // But that's actually what we want for a clean slate - one empty scene\n      // Rename the temp scene to something more user-friendly\n      try {\n        // Try \"Scene 1\", then \"Scene 2\", etc. until we find an available name\n        let renamed = false;\n        for (let i = 1; i <= 10 && !renamed; i++) {\n          try {\n            const newName = i === 1 ? 'Scene 1' : `Scene ${i}`;\n            await compObs.call('SetSceneName', { sceneName: tempSceneName, newSceneName: newName });\n            renamed = true;\n            console.log(`[deleteAllScenes] Renamed temp scene to: ${newName}`);\n          } catch (renameErr) {\n            // Scene name might already exist, try next number\n            if (i === 10) {\n              console.warn(`[deleteAllScenes] Could not rename temp scene after 10 attempts`);\n            }\n          }\n        }\n      } catch (err) {\n        // If rename fails, just leave it\n        console.warn(`[deleteAllScenes] Could not rename temp scene: ${err.message}`);\n      }\n\n      // Clear templateScenes list in Firebase\n      try {\n        const db = productionConfigService.getDb();\n        if (db) {\n          const templateScenesRef = db.ref(`competitions/${clientCompId}/obs/templateScenes`);\n          await templateScenesRef.set([]);\n          console.log(`[deleteAllScenes] Cleared templateScenes list`);\n        }\n      } catch (fbError) {\n        console.warn(`[deleteAllScenes] Could not clear templateScenes list: ${fbError.message}`);\n      }\n\n      console.log(`[deleteAllScenes] Deleted ${deletedCount} scenes for ${clientCompId}`);\n      socket.emit('obs:deleteAllScenesResult', {\n        success: errors.length === 0,\n        deletedCount,\n        errors: errors.length > 0 ? errors : undefined,\n        message: `Deleted ${deletedCount} scenes${errors.length > 0 ? ` with ${errors.length} errors` : ''}`\n      });\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteAllScenes] Failed to delete all scenes: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete all scenes: ${error.message}` });\n    }\n  });\n\n  // Reorder scenes in OBS\n  socket.on('obs:reorderScenes', async ({ sceneNames }) => {\n    console.log(`[reorderScenes] Received request to reorder scenes:`, sceneNames);\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reorder scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get current scene list to get UUIDs\n      const currentSceneList = await compObs.call('GetSceneList');\n      const sceneMap = {};\n      currentSceneList.scenes.forEach(scene => {\n        sceneMap[scene.sceneName] = scene.sceneUuid;\n      });\n\n      // Build new scene list with UUIDs in requested order\n      const newSceneList = sceneNames.map(name => ({\n        sceneName: name,\n        sceneUuid: sceneMap[name]\n      })).filter(s => s.sceneUuid); // Only include scenes that exist\n\n      // Note: OBS WebSocket expects scenes in reverse order (last = bottom of list in OBS)\n      // The SetSceneList API orders scenes from bottom to top\n      await compObs.call('SetSceneList', { scenes: newSceneList.reverse() });\n      console.log(`[reorderScenes] Reordered ${newSceneList.length} scenes for ${clientCompId}`);\n\n      // Broadcast updated state to all clients in this competition\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[reorderScenes] Failed to reorder scenes: ${error.message}`);\n      socket.emit('error', { message: `Failed to reorder scenes: ${error.message}` });\n    }\n  });\n\n  // Toggle scene item visibility\n  socket.on('obs:toggleItemVisibility', async ({ sceneName, sceneItemId, enabled }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can toggle item visibility' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemEnabled', { sceneName, sceneItemId, sceneItemEnabled: enabled });\n      console.log(`[toggleItemVisibility] Set item ${sceneItemId} in ${sceneName} to ${enabled ? 'visible' : 'hidden'} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[toggleItemVisibility] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to toggle visibility: ${error.message}` });\n    }\n  });\n\n  // Toggle scene item lock\n  socket.on('obs:toggleItemLock', async ({ sceneName, sceneItemId, locked }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can toggle item lock' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemLocked', { sceneName, sceneItemId, sceneItemLocked: locked });\n      console.log(`[toggleItemLock] Set item ${sceneItemId} in ${sceneName} to ${locked ? 'locked' : 'unlocked'} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[toggleItemLock] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to toggle lock: ${error.message}` });\n    }\n  });\n\n  // Delete scene item\n  socket.on('obs:deleteSceneItem', async ({ sceneName, sceneItemId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete scene items' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('RemoveSceneItem', { sceneName, sceneItemId });\n      console.log(`[deleteSceneItem] Removed item ${sceneItemId} from ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[deleteSceneItem] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete scene item: ${error.message}` });\n    }\n  });\n\n  // Reorder scene items\n  socket.on('obs:reorderSceneItems', async ({ sceneName, sceneItemId, newIndex }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reorder scene items' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemIndex', { sceneName, sceneItemId, sceneItemIndex: newIndex });\n      console.log(`[reorderSceneItems] Moved item ${sceneItemId} to index ${newIndex} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[reorderSceneItems] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to reorder scene items: ${error.message}` });\n    }\n  });\n\n  // Apply transform preset to scene item\n  socket.on('obs:applyTransformPreset', async ({ sceneName, sceneItemId, transform }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can apply transform presets' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemTransform', { sceneName, sceneItemId, sceneItemTransform: transform });\n      console.log(`[applyTransformPreset] Applied transform to item ${sceneItemId} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[applyTransformPreset] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to apply transform: ${error.message}` });\n    }\n  });\n\n  // Add source to scene\n  socket.on('obs:addSourceToScene', async ({ sceneName, sourceName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can add sources to scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('CreateSceneItem', { sceneName, sourceName });\n      console.log(`[addSourceToScene] Added source ${sourceName} to ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[addSourceToScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to add source: ${error.message}` });\n    }\n  });\n\n  // Create a new input/source in OBS\n  socket.on('obs:createInput', async ({ inputName, inputKind, inputSettings, sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can create inputs' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // CreateInput with sceneName will create the input AND add it to the scene\n      const params = {\n        inputName,\n        inputKind,\n        inputSettings: inputSettings || {}\n      };\n\n      if (sceneName) {\n        params.sceneName = sceneName;\n      }\n\n      const result = await compObs.call('CreateInput', params);\n      console.log(`[createInput] Created input ${inputName} (${inputKind})${sceneName ? ` in scene ${sceneName}` : ''} for ${clientCompId}`, result);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[createInput] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to create input: ${error.message}` });\n    }\n  });\n\n  // Remove an input entirely from OBS (PRD-OBS-03: Source Management)\n  socket.on('obs:removeInput', async ({ inputName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can remove inputs' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // RemoveInput removes the input from OBS entirely (from all scenes)\n      await compObs.call('RemoveInput', { inputName });\n      console.log(`[removeInput] Removed input ${inputName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[removeInput] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to remove input: ${error.message}` });\n    }\n  });\n\n  // Update input settings (PRD-OBS-03: Source Management)\n  socket.on('obs:updateInputSettings', async ({ inputName, inputSettings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can update input settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // SetInputSettings with overlay: true merges with existing settings\n      await compObs.call('SetInputSettings', { inputName, inputSettings, overlay: true });\n      console.log(`[updateInputSettings] Updated settings for ${inputName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[updateInputSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to update input settings: ${error.message}` });\n    }\n  });\n\n  // Get input settings (for SourceEditor to load current values)\n  socket.on('obs:getInputSettings', async ({ inputName }, callback) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      if (callback) callback({ error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      if (callback) callback({ error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetInputSettings', { inputName });\n      console.log(`[getInputSettings] Retrieved settings for ${inputName} for ${clientCompId}`);\n      if (callback) {\n        callback({\n          inputKind: response.inputKind,\n          inputSettings: response.inputSettings\n        });\n      }\n    } catch (error) {\n      console.error(`[getInputSettings] Failed: ${error.message}`);\n      if (callback) callback({ error: error.message });\n    }\n  });\n\n  // Set scene item transform (PRD-OBS-03: Source Management)\n  socket.on('obs:setSceneItemTransform', async ({ sceneName, sceneItemId, transform }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set scene item transforms' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetSceneItemTransform', { sceneName, sceneItemId, sceneItemTransform: transform });\n      console.log(`[setSceneItemTransform] Updated transform for item ${sceneItemId} in ${sceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setSceneItemTransform] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set scene item transform: ${error.message}` });\n    }\n  });\n\n  // Duplicate scene\n  socket.on('obs:duplicateScene', async ({ sceneName, newSceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can duplicate scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get items from source scene\n      const { sceneItems } = await compObs.call('GetSceneItemList', { sceneName });\n\n      // Create new scene\n      await compObs.call('CreateScene', { sceneName: newSceneName });\n\n      // Add each item to new scene (in reverse order to maintain z-order)\n      for (const item of sceneItems.reverse()) {\n        try {\n          const { sceneItemId } = await compObs.call('CreateSceneItem', {\n            sceneName: newSceneName,\n            sourceName: item.sourceName\n          });\n          // Apply original transform\n          if (item.sceneItemTransform) {\n            await compObs.call('SetSceneItemTransform', {\n              sceneName: newSceneName,\n              sceneItemId,\n              sceneItemTransform: item.sceneItemTransform\n            });\n          }\n          // Apply visibility\n          await compObs.call('SetSceneItemEnabled', {\n            sceneName: newSceneName,\n            sceneItemId,\n            sceneItemEnabled: item.sceneItemEnabled\n          });\n        } catch (itemError) {\n          console.warn(`[duplicateScene] Could not copy item ${item.sourceName}: ${itemError.message}`);\n        }\n      }\n\n      console.log(`[duplicateScene] Duplicated ${sceneName} to ${newSceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[duplicateScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to duplicate scene: ${error.message}` });\n    }\n  });\n\n  // Rename scene (OBS doesn't have native rename, so we duplicate and delete)\n  socket.on('obs:renameScene', async ({ sceneName, newSceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can rename scenes' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get items from source scene\n      const { sceneItems } = await compObs.call('GetSceneItemList', { sceneName });\n\n      // Create new scene with new name\n      await compObs.call('CreateScene', { sceneName: newSceneName });\n\n      // Copy each item to new scene\n      for (const item of sceneItems.reverse()) {\n        try {\n          const { sceneItemId } = await compObs.call('CreateSceneItem', {\n            sceneName: newSceneName,\n            sourceName: item.sourceName\n          });\n          if (item.sceneItemTransform) {\n            await compObs.call('SetSceneItemTransform', {\n              sceneName: newSceneName,\n              sceneItemId,\n              sceneItemTransform: item.sceneItemTransform\n            });\n          }\n          await compObs.call('SetSceneItemEnabled', {\n            sceneName: newSceneName,\n            sceneItemId,\n            sceneItemEnabled: item.sceneItemEnabled\n          });\n        } catch (itemError) {\n          console.warn(`[renameScene] Could not copy item ${item.sourceName}: ${itemError.message}`);\n        }\n      }\n\n      // Delete original scene\n      await compObs.call('RemoveScene', { sceneName });\n\n      console.log(`[renameScene] Renamed ${sceneName} to ${newSceneName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[renameScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to rename scene: ${error.message}` });\n    }\n  });\n\n  // Set audio input volume (PRD-OBS-04: Audio Management)\n  socket.on('obs:setVolume', async ({ inputName, volumeDb, volumeMul }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change volume' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Build payload - prefer volumeDb if provided, otherwise use volumeMul\n      const payload = { inputName };\n      if (volumeDb !== undefined) {\n        payload.inputVolumeDb = volumeDb;\n      } else if (volumeMul !== undefined) {\n        payload.inputVolumeMul = volumeMul;\n      } else {\n        socket.emit('error', { message: 'Must provide volumeDb or volumeMul' });\n        return;\n      }\n\n      await compObs.call('SetInputVolume', payload);\n      console.log(`[setVolume] Set ${inputName} volume to ${volumeDb !== undefined ? volumeDb + 'dB' : volumeMul} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setVolume] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set volume: ${error.message}` });\n    }\n  });\n\n  // Set audio input mute state (PRD-OBS-04: Audio Management)\n  socket.on('obs:setMute', async ({ inputName, muted }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can mute/unmute audio' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetInputMute', { inputName, inputMuted: muted });\n      console.log(`[setMute] Set ${inputName} muted=${muted} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setMute] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set mute: ${error.message}` });\n    }\n  });\n\n  // Set audio monitor type\n  socket.on('obs:setMonitorType', async ({ inputName, monitorType }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change monitor type' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetInputAudioMonitorType', { inputName, monitorType });\n      console.log(`[setMonitorType] Set ${inputName} monitor type to ${monitorType} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setMonitorType] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set monitor type: ${error.message}` });\n    }\n  });\n\n  // Subscribe/unsubscribe from real-time audio level updates (Phase 2)\n  socket.on('obs:subscribeAudioLevels', ({ enabled }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      console.log(`[subscribeAudioLevels] No compId for socket ${socket.id}`);\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n\n    if (enabled) {\n      obsConnManager.subscribeAudioLevels(clientCompId, socket.id);\n      console.log(`[subscribeAudioLevels] ${socket.id} subscribed to audio levels for ${clientCompId}`);\n    } else {\n      obsConnManager.unsubscribeAudioLevels(clientCompId, socket.id);\n      console.log(`[subscribeAudioLevels] ${socket.id} unsubscribed from audio levels for ${clientCompId}`);\n    }\n  });\n\n  // ============================================================================\n  // Audio Preset Management (PRD-OBS-04 Phase 1.5)\n  // ============================================================================\n\n  // Apply an audio preset (default or user-created)\n  socket.on('obs:applyPreset', async ({ presetId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const connection = obsConnManager.getConnection(clientCompId);\n\n    if (!connection || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      console.log(`[applyPreset] Applying preset ${presetId} for ${clientCompId}`);\n\n      // 1. Check default presets first\n      let preset = DEFAULT_PRESETS[presetId];\n\n      // 2. If not default, load from Firebase\n      if (!preset && productionConfigService.isAvailable()) {\n        const db = productionConfigService.getDb();\n        const snapshot = await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).once('value');\n        preset = snapshot.val();\n      }\n\n      if (!preset) {\n        socket.emit('obs:error', { message: `Preset not found: ${presetId}` });\n        return;\n      }\n\n      // 3. Apply each source setting via OBS WebSocket\n      const sources = Array.isArray(preset.sources) ? preset.sources : Object.values(preset.sources || {});\n      let applied = 0;\n      const errors = [];\n\n      for (const source of sources) {\n        try {\n          if (source.volumeDb !== undefined) {\n            await connection.call('SetInputVolume', {\n              inputName: source.inputName,\n              inputVolumeDb: source.volumeDb\n            });\n          }\n          if (source.muted !== undefined) {\n            await connection.call('SetInputMute', {\n              inputName: source.inputName,\n              inputMuted: source.muted\n            });\n          }\n          applied++;\n        } catch (err) {\n          console.warn(`[applyPreset] Failed to apply to ${source.inputName}: ${err.message}`);\n          errors.push({ inputName: source.inputName, error: err.message });\n        }\n      }\n\n      // 4. Broadcast state update to all clients\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n\n      // 5. Send success response\n      socket.emit('obs:presetApplied', {\n        presetId,\n        presetName: preset.name,\n        applied,\n        total: sources.length,\n        errors\n      });\n\n      console.log(`[applyPreset] Applied preset \"${preset.name}\": ${applied}/${sources.length} sources for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[applyPreset] Error applying preset ${presetId}:`, error.message);\n      socket.emit('obs:error', { message: `Failed to apply preset: ${error.message}` });\n    }\n  });\n\n  // List all audio presets (default + user-created)\n  socket.on('obs:listPresets', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    try {\n      console.log(`[listPresets] Listing presets for ${clientCompId}`);\n\n      // Get default presets\n      const defaultPresets = Object.values(DEFAULT_PRESETS).map(p => ({\n        ...p,\n        isDefault: true\n      }));\n\n      // Get user presets from Firebase\n      let userPresets = [];\n      if (productionConfigService.isAvailable()) {\n        const db = productionConfigService.getDb();\n        const snapshot = await db.ref(`competitions/${clientCompId}/obs/presets`).once('value');\n        const presetsData = snapshot.val();\n        if (presetsData) {\n          userPresets = Object.entries(presetsData).map(([id, preset]) => ({\n            ...preset,\n            id,\n            isDefault: false\n          }));\n        }\n      }\n\n      const allPresets = [...defaultPresets, ...userPresets];\n      socket.emit('obs:presetsList', { presets: allPresets });\n\n      console.log(`[listPresets] Sent ${allPresets.length} presets (${defaultPresets.length} default, ${userPresets.length} user) for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[listPresets] Error listing presets:`, error.message);\n      socket.emit('obs:error', { message: `Failed to list presets: ${error.message}` });\n    }\n  });\n\n  // Save current audio mix as a new preset\n  socket.on('obs:savePreset', async ({ name, description, sources }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('obs:error', { message: 'Firebase not available' });\n      return;\n    }\n\n    if (!name || !sources || Object.keys(sources).length === 0) {\n      socket.emit('obs:error', { message: 'Name and sources are required' });\n      return;\n    }\n\n    try {\n      console.log(`[savePreset] Saving preset \"${name}\" for ${clientCompId}`);\n\n      const db = productionConfigService.getDb();\n      const presetId = `user-${Date.now()}`;\n\n      // Convert sources object to array format\n      const sourcesArray = Object.entries(sources).map(([inputName, settings]) => ({\n        inputName,\n        ...settings\n      }));\n\n      const preset = {\n        id: presetId,\n        name,\n        description: description || '',\n        sources: sourcesArray,\n        createdAt: new Date().toISOString(),\n        isDefault: false\n      };\n\n      await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).set(preset);\n\n      socket.emit('obs:presetSaved', { preset });\n      console.log(`[savePreset] Saved preset \"${name}\" (${presetId}) for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[savePreset] Error saving preset:`, error.message);\n      socket.emit('obs:error', { message: `Failed to save preset: ${error.message}` });\n    }\n  });\n\n  // Delete a user-created preset\n  socket.on('obs:deletePreset', async ({ presetId }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('obs:error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('obs:error', { message: 'Firebase not available' });\n      return;\n    }\n\n    // Prevent deletion of default presets\n    if (DEFAULT_PRESETS[presetId]) {\n      socket.emit('obs:error', { message: 'Cannot delete default presets' });\n      return;\n    }\n\n    try {\n      console.log(`[deletePreset] Deleting preset ${presetId} for ${clientCompId}`);\n\n      const db = productionConfigService.getDb();\n      await db.ref(`competitions/${clientCompId}/obs/presets/${presetId}`).remove();\n\n      socket.emit('obs:presetDeleted', { presetId });\n      console.log(`[deletePreset] Deleted preset ${presetId} for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[deletePreset] Error deleting preset:`, error.message);\n      socket.emit('obs:error', { message: `Failed to delete preset: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Transition Management (PRD-OBS-05)\n  // ============================================================================\n\n  // Get available transitions\n  socket.on('obs:getTransitions', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetSceneTransitionList');\n      const transitions = (response.transitions || []).map(t => ({\n        name: t.transitionName,\n        kind: t.transitionKind,\n        configurable: t.transitionConfigurable || false\n      }));\n      socket.emit('obs:transitionsList', {\n        transitions,\n        currentTransition: response.currentSceneTransitionName,\n        transitionDuration: response.currentSceneTransitionDuration || 300\n      });\n      console.log(`[getTransitions] Sent ${transitions.length} transitions for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[getTransitions] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get transitions: ${error.message}` });\n    }\n  });\n\n  // Set current transition (PRD-OBS-05)\n  socket.on('obs:setCurrentTransition', async ({ transitionName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transitions' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransition', { transitionName });\n      console.log(`[setCurrentTransition] Set transition to ${transitionName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setCurrentTransition] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition: ${error.message}` });\n    }\n  });\n\n  // Set transition duration (PRD-OBS-05)\n  socket.on('obs:setTransitionDuration', async ({ transitionDuration }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transition duration' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransitionDuration', { transitionDuration });\n      console.log(`[setTransitionDuration] Set duration to ${transitionDuration}ms for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setTransitionDuration] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition duration: ${error.message}` });\n    }\n  });\n\n  // Set transition settings (PRD-OBS-05)\n  socket.on('obs:setTransitionSettings', async ({ transitionName, transitionSettings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change transition settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentSceneTransitionSettings', {\n        transitionSettings,\n        overlay: true\n      });\n      console.log(`[setTransitionSettings] Updated settings for ${transitionName} for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setTransitionSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set transition settings: ${error.message}` });\n    }\n  });\n\n  // Get transition settings (PRD-OBS-11: Stinger Transitions)\n  socket.on('obs:getTransitionSettings', async ({ transitionName }, callback) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      if (callback) callback({ error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      if (callback) callback({ error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetCurrentSceneTransitionSettings');\n      console.log(`[getTransitionSettings] Retrieved settings for ${transitionName} for ${clientCompId}`);\n      if (callback) {\n        callback({\n          transitionName: response.transitionName,\n          transitionSettings: response.transitionSettings,\n          transitionKind: response.transitionKind\n        });\n      }\n    } catch (error) {\n      console.error(`[getTransitionSettings] Failed: ${error.message}`);\n      if (callback) callback({ error: `Failed to get transition settings: ${error.message}` });\n    }\n  });\n\n  // Take screenshot of current output\n  socket.on('obs:takeScreenshot', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can take screenshots' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get current program scene name\n      const { currentProgramSceneName } = await compObs.call('GetCurrentProgramScene');\n\n      // Take screenshot of the current program scene\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: currentProgramSceneName,\n        imageFormat: 'png',\n        imageWidth: 1920,\n        imageHeight: 1080\n      });\n\n      console.log(`[takeScreenshot] Captured screenshot of ${currentProgramSceneName} for ${clientCompId}`);\n\n      // Emit screenshot data back to the client (base64 encoded PNG)\n      socket.emit('obs:screenshotCaptured', {\n        imageData: response.imageData,\n        sceneName: currentProgramSceneName,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error(`[takeScreenshot] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to take screenshot: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Preview System (PRD-OBS-09)\n  // ============================================================================\n\n  // Request screenshot for preview (with configurable options)\n  socket.on('obs:requestScreenshot', async (options = {}) => {\n    const { sceneName = null, imageWidth = 640, imageHeight = 360, imageFormat = 'jpg' } = options;\n\n    // Get compId from socket handshake query (same as other handlers)\n    const clientCompId = socket.handshake?.query?.compId;\n    if (!clientCompId) {\n      socket.emit('obs:screenshotError', { error: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:screenshotError', { error: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      // Get target scene name - use provided sceneName or get current program scene\n      let targetScene = sceneName;\n      if (!targetScene) {\n        const { currentProgramSceneName } = await compObs.call('GetCurrentProgramScene');\n        targetScene = currentProgramSceneName;\n      }\n\n      // Take screenshot with specified options\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: targetScene,\n        imageFormat: imageFormat === 'jpg' ? 'jpeg' : imageFormat,\n        imageWidth,\n        imageHeight\n      });\n\n      console.log(`[requestScreenshot] Captured ${imageWidth}x${imageHeight} ${imageFormat} of ${targetScene} for ${clientCompId}`);\n\n      // Emit screenshot data back to the requesting client\n      socket.emit('obs:screenshotData', {\n        success: true,\n        imageData: response.imageData,\n        sceneName: targetScene,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error(`[requestScreenshot] Failed: ${error.message}`);\n      socket.emit('obs:screenshotError', {\n        error: error.message,\n        sceneName\n      });\n    }\n  });\n\n  // Request scene thumbnail (PRD-OBS-11: Scene Thumbnails)\n  socket.on('obs:requestSceneThumbnail', async (options = {}) => {\n    const { sceneName, imageWidth = 80, imageHeight = 45, isHoverPreview = false } = options;\n\n    if (!sceneName) {\n      socket.emit('obs:sceneThumbnailError', { error: 'Scene name required', sceneName, isHoverPreview });\n      return;\n    }\n\n    // Get compId from socket handshake query\n    const clientCompId = socket.handshake?.query?.compId;\n    if (!clientCompId) {\n      socket.emit('obs:sceneThumbnailError', { error: 'No competition ID', sceneName, isHoverPreview });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('obs:sceneThumbnailError', { error: 'OBS not connected', sceneName, isHoverPreview });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetSourceScreenshot', {\n        sourceName: sceneName,\n        imageFormat: 'jpeg',\n        imageWidth,\n        imageHeight\n      });\n\n      socket.emit('obs:sceneThumbnailData', {\n        success: true,\n        imageData: response.imageData,\n        sceneName,\n        isHoverPreview,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error(`[requestSceneThumbnail] Failed for ${sceneName}: ${error.message}`);\n      socket.emit('obs:sceneThumbnailError', {\n        error: error.message,\n        sceneName,\n        isHoverPreview\n      });\n    }\n  });\n\n  // ============================================================================\n  // Studio Mode (PRD-OBS-11: Advanced Features)\n  // ============================================================================\n\n  // Enable studio mode\n  socket.on('obs:enableStudioMode', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can enable studio mode' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStudioModeEnabled', { studioModeEnabled: true });\n      console.log(`[enableStudioMode] Studio mode enabled for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[enableStudioMode] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to enable studio mode: ${error.message}` });\n    }\n  });\n\n  // Disable studio mode\n  socket.on('obs:disableStudioMode', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can disable studio mode' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStudioModeEnabled', { studioModeEnabled: false });\n      console.log(`[disableStudioMode] Studio mode disabled for ${clientCompId}`);\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[disableStudioMode] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to disable studio mode: ${error.message}` });\n    }\n  });\n\n  // Set preview scene (only works in studio mode)\n  socket.on('obs:setPreviewScene', async ({ sceneName }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set preview scene' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetCurrentPreviewScene', { sceneName });\n      console.log(`[setPreviewScene] Preview scene set to ${sceneName} for ${clientCompId}`);\n      // Broadcast updated state (will include new previewScene)\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[setPreviewScene] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set preview scene: ${error.message}` });\n    }\n  });\n\n  // Transition preview to program (only works in studio mode)\n  socket.on('obs:transitionToProgram', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can transition to program' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('TriggerStudioModeTransition');\n      console.log(`[transitionToProgram] Triggered transition for ${clientCompId}`);\n      // State will be updated by OBS events (CurrentProgramSceneChanged, etc.)\n    } catch (error) {\n      console.error(`[transitionToProgram] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to transition: ${error.message}` });\n    }\n  });\n\n  // ============================================================================\n  // Template Auto-Loading (PRD-OBS-11)\n  // ============================================================================\n\n  // Set a template as default for specific meet types\n  socket.on('obs:setTemplateDefault', async ({ templateId, meetTypes }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can set template defaults' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!templateId || !Array.isArray(meetTypes) || meetTypes.length === 0) {\n      socket.emit('error', { message: 'Template ID and meet types array are required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        socket.emit('error', { message: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n\n      // Get the template to verify it exists\n      const templateRef = database.ref(`templates/obs/${templateId}`);\n      const templateSnapshot = await templateRef.once('value');\n      const template = templateSnapshot.val();\n\n      if (!template) {\n        socket.emit('error', { message: `Template not found: ${templateId}` });\n        return;\n      }\n\n      // Clear this default from any other templates for the same meet types\n      const allTemplatesRef = database.ref('templates/obs');\n      const allTemplatesSnapshot = await allTemplatesRef.once('value');\n      const allTemplates = allTemplatesSnapshot.val() || {};\n\n      for (const [otherTemplateId, otherTemplate] of Object.entries(allTemplates)) {\n        if (otherTemplateId !== templateId && otherTemplate.isDefaultFor) {\n          // Remove overlapping meet types from other templates\n          const updatedIsDefaultFor = otherTemplate.isDefaultFor.filter(mt => !meetTypes.includes(mt));\n          if (updatedIsDefaultFor.length !== otherTemplate.isDefaultFor.length) {\n            await database.ref(`templates/obs/${otherTemplateId}/isDefaultFor`).set(\n              updatedIsDefaultFor.length > 0 ? updatedIsDefaultFor : null\n            );\n            console.log(`[setTemplateDefault] Cleared ${meetTypes.filter(mt => otherTemplate.isDefaultFor.includes(mt)).join(', ')} from ${otherTemplateId}`);\n          }\n        }\n      }\n\n      // Set the new default\n      const currentIsDefaultFor = template.isDefaultFor || [];\n      const newIsDefaultFor = [...new Set([...currentIsDefaultFor, ...meetTypes])];\n      await templateRef.update({\n        isDefaultFor: newIsDefaultFor,\n        updatedAt: new Date().toISOString()\n      });\n\n      console.log(`[setTemplateDefault] Set ${templateId} as default for ${meetTypes.join(', ')}`);\n\n      // Notify all clients in this competition room\n      io.to(`competition:${clientCompId}`).emit('obs:templateDefaultChanged', {\n        templateId,\n        meetTypes: newIsDefaultFor,\n        action: 'set'\n      });\n\n      socket.emit('obs:templateDefaultSet', { templateId, meetTypes: newIsDefaultFor });\n    } catch (error) {\n      console.error(`[setTemplateDefault] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set template default: ${error.message}` });\n    }\n  });\n\n  // Clear a template's default status for specific meet types\n  socket.on('obs:clearTemplateDefault', async ({ templateId, meetTypes }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can clear template defaults' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!templateId || !Array.isArray(meetTypes) || meetTypes.length === 0) {\n      socket.emit('error', { message: 'Template ID and meet types array are required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        socket.emit('error', { message: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n      const templateRef = database.ref(`templates/obs/${templateId}`);\n      const templateSnapshot = await templateRef.once('value');\n      const template = templateSnapshot.val();\n\n      if (!template) {\n        socket.emit('error', { message: `Template not found: ${templateId}` });\n        return;\n      }\n\n      // Remove the specified meet types from isDefaultFor\n      const currentIsDefaultFor = template.isDefaultFor || [];\n      const newIsDefaultFor = currentIsDefaultFor.filter(mt => !meetTypes.includes(mt));\n\n      await templateRef.update({\n        isDefaultFor: newIsDefaultFor.length > 0 ? newIsDefaultFor : null,\n        updatedAt: new Date().toISOString()\n      });\n\n      console.log(`[clearTemplateDefault] Cleared ${meetTypes.join(', ')} from ${templateId}`);\n\n      // Notify all clients in this competition room\n      io.to(`competition:${clientCompId}`).emit('obs:templateDefaultChanged', {\n        templateId,\n        meetTypes: newIsDefaultFor,\n        action: 'clear'\n      });\n\n      socket.emit('obs:templateDefaultCleared', { templateId, meetTypes: newIsDefaultFor });\n    } catch (error) {\n      console.error(`[clearTemplateDefault] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to clear template default: ${error.message}` });\n    }\n  });\n\n  // Get the default template for a specific meet type\n  socket.on('obs:getDefaultTemplate', async ({ meetType }, callback) => {\n    if (!meetType) {\n      if (callback) callback({ error: 'Meet type is required' });\n      return;\n    }\n\n    try {\n      productionConfigService.initialize();\n      if (!productionConfigService.isAvailable()) {\n        if (callback) callback({ error: 'Firebase not available' });\n        return;\n      }\n\n      const database = productionConfigService.getDb();\n      const templatesRef = database.ref('templates/obs');\n      const templatesSnapshot = await templatesRef.once('value');\n      const templates = templatesSnapshot.val() || {};\n\n      // Find templates that are default for this meet type\n      const defaultTemplates = Object.values(templates).filter(\n        t => t.isDefaultFor && t.isDefaultFor.includes(meetType)\n      );\n\n      if (defaultTemplates.length === 0) {\n        console.log(`[getDefaultTemplate] No default template for ${meetType}`);\n        if (callback) callback({ template: null });\n        return;\n      }\n\n      // If multiple defaults, use the most recently updated one\n      const defaultTemplate = defaultTemplates.sort((a, b) =>\n        new Date(b.updatedAt || b.createdAt) - new Date(a.updatedAt || a.createdAt)\n      )[0];\n\n      console.log(`[getDefaultTemplate] Found default template \"${defaultTemplate.name}\" for ${meetType}`);\n      if (callback) callback({ template: defaultTemplate });\n    } catch (error) {\n      console.error(`[getDefaultTemplate] Failed: ${error.message}`);\n      if (callback) callback({ error: error.message });\n    }\n  });\n\n  // ============================================================================\n  // Stream & Recording Control (PRD-OBS-06)\n  // ============================================================================\n\n  // Start streaming\n  socket.on('obs:startStream', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can start streaming' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StartStream');\n      console.log(`[startStream] Started streaming for ${clientCompId}`);\n      socket.emit('obs:streamStarted');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[startStream] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to start stream: ${error.message}` });\n    }\n  });\n\n  // Stop streaming\n  socket.on('obs:stopStream', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can stop streaming' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StopStream');\n      console.log(`[stopStream] Stopped streaming for ${clientCompId}`);\n      socket.emit('obs:streamStopped');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[stopStream] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to stop stream: ${error.message}` });\n    }\n  });\n\n  // Get stream status\n  socket.on('obs:getStreamStatus', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetStreamStatus');\n      socket.emit('obs:streamStatus', {\n        active: response.outputActive,\n        reconnecting: response.outputReconnecting || false,\n        timecode: response.outputTimecode || '00:00:00.000',\n        duration: response.outputDuration || 0,\n        bytes: response.outputBytes || 0,\n        skippedFrames: response.outputSkippedFrames || 0,\n        totalFrames: response.outputTotalFrames || 0\n      });\n      console.log(`[getStreamStatus] Sent stream status for ${clientCompId} (active: ${response.outputActive})`);\n    } catch (error) {\n      console.error(`[getStreamStatus] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get stream status: ${error.message}` });\n    }\n  });\n\n  // Get stream settings\n  socket.on('obs:getStreamSettings', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetStreamServiceSettings');\n      // Mask the stream key\n      const settings = { ...response.streamServiceSettings };\n      if (settings.key) {\n        settings.key = '****' + settings.key.slice(-4);\n      }\n      socket.emit('obs:streamSettings', {\n        serviceType: response.streamServiceType,\n        settings\n      });\n      console.log(`[getStreamSettings] Sent stream settings for ${clientCompId}`);\n    } catch (error) {\n      console.error(`[getStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get stream settings: ${error.message}` });\n    }\n  });\n\n  // Set stream settings\n  socket.on('obs:setStreamSettings', async ({ serviceType, settings }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can change stream settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('SetStreamServiceSettings', {\n        streamServiceType: serviceType,\n        streamServiceSettings: settings\n      });\n      console.log(`[setStreamSettings] Updated stream settings for ${clientCompId} (type: ${serviceType})`);\n\n      // Store encrypted stream key in Firebase for backup/recovery\n      if (settings?.key && productionConfigService.isAvailable()) {\n        try {\n          const encryptedKey = encryptStreamKey(settings.key);\n          const db = productionConfigService.getDb();\n          if (db) {\n            await db.ref(`competitions/${clientCompId}/obs/streamConfig`).update({\n              streamKeyEncrypted: encryptedKey,\n              serviceType: serviceType,\n              server: settings.server || null,\n              lastUpdated: new Date().toISOString()\n            });\n            console.log(`[setStreamSettings] Stored encrypted stream key in Firebase for ${clientCompId}`);\n          }\n        } catch (fbError) {\n          // Don't fail the request if Firebase storage fails - OBS was still updated\n          console.warn(`[setStreamSettings] Failed to store encrypted key in Firebase: ${fbError.message}`);\n        }\n      }\n\n      socket.emit('obs:streamSettingsUpdated', { success: true });\n    } catch (error) {\n      console.error(`[setStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to set stream settings: ${error.message}` });\n    }\n  });\n\n  // Restore stream settings from Firebase backup\n  socket.on('obs:restoreStreamSettings', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can restore stream settings' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('error', { message: 'Firebase not available' });\n      return;\n    }\n\n    try {\n      const db = productionConfigService.getDb();\n      const snapshot = await db.ref(`competitions/${clientCompId}/obs/streamConfig`).once('value');\n      const config = snapshot.val();\n\n      if (!config || !config.streamKeyEncrypted) {\n        socket.emit('error', { message: 'No stored stream configuration found' });\n        return;\n      }\n\n      // Decrypt the stream key\n      const decryptedKey = decryptStreamKey(config.streamKeyEncrypted);\n\n      // Build settings object\n      const settings = { key: decryptedKey };\n      if (config.server) {\n        settings.server = config.server;\n      }\n\n      // Apply to OBS\n      await compObs.call('SetStreamServiceSettings', {\n        streamServiceType: config.serviceType || 'rtmp_common',\n        streamServiceSettings: settings\n      });\n\n      console.log(`[restoreStreamSettings] Restored stream settings from Firebase for ${clientCompId}`);\n      socket.emit('obs:streamSettingsRestored', { success: true, lastUpdated: config.lastUpdated });\n    } catch (error) {\n      console.error(`[restoreStreamSettings] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to restore stream settings: ${error.message}` });\n    }\n  });\n\n  // Delete stored stream key from Firebase\n  socket.on('obs:deleteStoredStreamKey', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can delete stream keys' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    if (!productionConfigService.isAvailable()) {\n      socket.emit('error', { message: 'Firebase not available' });\n      return;\n    }\n\n    try {\n      const db = productionConfigService.getDb();\n      await db.ref(`competitions/${clientCompId}/obs/streamConfig/streamKeyEncrypted`).remove();\n      console.log(`[deleteStoredStreamKey] Deleted stored stream key for ${clientCompId}`);\n      socket.emit('obs:storedStreamKeyDeleted', { success: true });\n    } catch (error) {\n      console.error(`[deleteStoredStreamKey] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to delete stored stream key: ${error.message}` });\n    }\n  });\n\n  // Start recording\n  socket.on('obs:startRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can start recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('StartRecord');\n      console.log(`[startRecording] Started recording for ${clientCompId}`);\n      socket.emit('obs:recordingStarted');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[startRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to start recording: ${error.message}` });\n    }\n  });\n\n  // Stop recording\n  socket.on('obs:stopRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can stop recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const result = await compObs.call('StopRecord');\n      console.log(`[stopRecording] Stopped recording for ${clientCompId}, file: ${result.outputPath}`);\n      socket.emit('obs:recordingStopped', { path: result.outputPath });\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[stopRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to stop recording: ${error.message}` });\n    }\n  });\n\n  // Pause recording\n  socket.on('obs:pauseRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can pause recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('PauseRecord');\n      console.log(`[pauseRecording] Paused recording for ${clientCompId}`);\n      socket.emit('obs:recordingPaused');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[pauseRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to pause recording: ${error.message}` });\n    }\n  });\n\n  // Resume recording\n  socket.on('obs:resumeRecording', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can resume recording' });\n      return;\n    }\n\n    const clientCompId = client?.compId;\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      await compObs.call('ResumeRecord');\n      console.log(`[resumeRecording] Resumed recording for ${clientCompId}`);\n      socket.emit('obs:recordingResumed');\n      await broadcastOBSState(clientCompId, obsConnManager, io);\n    } catch (error) {\n      console.error(`[resumeRecording] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to resume recording: ${error.message}` });\n    }\n  });\n\n  // Get recording status\n  socket.on('obs:getRecordingStatus', async () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const clientCompId = client?.compId;\n\n    if (!clientCompId) {\n      socket.emit('error', { message: 'No competition ID for client' });\n      return;\n    }\n\n    const obsConnManager = getOBSConnectionManager();\n    const compObs = obsConnManager.getConnection(clientCompId);\n\n    if (!compObs || !obsConnManager.isConnected(clientCompId)) {\n      socket.emit('error', { message: 'OBS not connected for this competition' });\n      return;\n    }\n\n    try {\n      const response = await compObs.call('GetRecordStatus');\n      socket.emit('obs:recordingStatus', {\n        active: response.outputActive,\n        paused: response.outputPaused || false,\n        timecode: response.outputTimecode || '00:00:00.000',\n        duration: response.outputDuration || 0,\n        bytes: response.outputBytes || 0\n      });\n      console.log(`[getRecordingStatus] Sent recording status for ${clientCompId} (active: ${response.outputActive}, paused: ${response.outputPaused})`);\n    } catch (error) {\n      console.error(`[getRecordingStatus] Failed: ${error.message}`);\n      socket.emit('error', { message: `Failed to get recording status: ${error.message}` });\n    }\n  });\n\n  // Toggle talent lock\n  socket.on('lockTalent', ({ locked }) => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can lock talent controls' });\n      return;\n    }\n\n    showState.talentLocked = locked;\n    console.log(`Talent controls ${locked ? 'locked' : 'unlocked'}`);\n    broadcastState();\n  });\n\n  // Toggle pause\n  socket.on('togglePause', () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can pause the show' });\n      return;\n    }\n\n    showState.isPaused = !showState.isPaused;\n\n    if (showState.isPaused) {\n      clearAutoAdvance();\n    } else if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n      // Resume auto-advance with remaining time\n      const elapsed = (Date.now() - showState.segmentStartTime) / 1000;\n      const remaining = showState.currentSegment.duration - elapsed;\n      if (remaining > 0) {\n        setupAutoAdvance(remaining);\n      }\n    }\n\n    console.log(`Show ${showState.isPaused ? 'paused' : 'resumed'}`);\n    broadcastState();\n  });\n\n  // Trigger graphic manually\n  socket.on('triggerGraphic', ({ graphic, data }) => {\n    io.emit('triggerGraphic', { graphic, data });\n    console.log(`Triggered graphic: ${graphic}`);\n  });\n\n  // Clear graphic\n  socket.on('clearGraphic', () => {\n    io.emit('clearGraphic');\n    console.log('Cleared graphic');\n  });\n\n  // OBS State Sync: Refresh full state from OBS\n  socket.on('obs:refreshState', async () => {\n    console.log(`[obs:refreshState] Request from client, compId: ${clientCompId || 'none'}`);\n\n    // First, try competition-based OBS connection (via obsConnectionManager)\n    if (clientCompId && clientCompId !== 'local') {\n      const obsConnManager = getOBSConnectionManager();\n      const connState = obsConnManager.getConnectionState(clientCompId);\n      console.log(`[obs:refreshState] Connection state for ${clientCompId}:`, connState ? { connected: connState.connected, error: connState.error } : 'null');\n\n      if (connState && connState.connected) {\n        try {\n          console.log(`[obs:refreshState] Broadcasting full state for competition ${clientCompId}`);\n          await broadcastOBSState(clientCompId, obsConnManager, io);\n          return;\n        } catch (error) {\n          console.error(`[obs:refreshState] Failed to refresh OBS state for ${clientCompId}:`, error);\n          socket.emit('error', { message: 'Failed to refresh OBS state' });\n          return;\n        }\n      } else {\n        console.log(`[obs:refreshState] OBS not connected for ${clientCompId}, falling back to local`);\n      }\n    }\n\n    // Fall back to local obsStateSync\n    if (obsStateSync && obsStateSync.isInitialized()) {\n      try {\n        console.log('Client requested OBS state refresh (local)');\n        await obsStateSync.refreshFullState();\n      } catch (error) {\n        console.error('Failed to refresh OBS state:', error);\n        socket.emit('error', { message: 'Failed to refresh OBS state' });\n      }\n    } else {\n      console.warn('OBS State Sync not initialized, cannot refresh state');\n      socket.emit('error', { message: 'OBS State Sync not initialized' });\n    }\n  });\n\n  // ============================================\n  // Camera Management Socket Events\n  // ============================================\n\n  // Reassign apparatus to a camera\n  socket.on('reassignApparatus', ({ cameraId, apparatus, assignedBy }) => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    if (!apparatus || !Array.isArray(apparatus)) {\n      socket.emit('error', { message: 'apparatus must be an array of apparatus codes' });\n      return;\n    }\n    const result = cameraRuntimeState.reassignApparatus(cameraId, apparatus, assignedBy || socket.id);\n    if (!result) {\n      socket.emit('error', { message: `Camera not found: ${cameraId}` });\n      return;\n    }\n    console.log(`Socket: Apparatus reassigned for camera ${cameraId} to [${apparatus.join(', ')}]`);\n  });\n\n  // Verify a camera\n  socket.on('verifyCamera', ({ cameraId, verifiedBy }) => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    const result = cameraRuntimeState.verifyCamera(cameraId, verifiedBy || socket.id);\n    if (!result) {\n      socket.emit('error', { message: `Camera not found: ${cameraId}` });\n      return;\n    }\n    console.log(`Socket: Camera ${cameraId} verified by ${verifiedBy || socket.id}`);\n  });\n\n  // Clear fallback for a camera\n  socket.on('clearFallback', ({ cameraId }) => {\n    if (!cameraFallbackManager) {\n      socket.emit('error', { message: 'Camera fallback manager not initialized' });\n      return;\n    }\n    const result = cameraFallbackManager.clearFallback(cameraId);\n    if (!result.success) {\n      socket.emit('error', { message: result.error });\n      return;\n    }\n    console.log(`Socket: Fallback cleared for camera ${cameraId}`);\n  });\n\n  // Reset all camera verifications\n  socket.on('resetVerifications', () => {\n    if (!cameraRuntimeState) {\n      socket.emit('error', { message: 'Camera runtime state not initialized' });\n      return;\n    }\n    cameraRuntimeState.resetAllVerifications();\n    console.log('Socket: All camera verifications reset');\n  });\n\n  // ============================================\n  // Timesheet Engine Socket Events\n  // ============================================\n\n  // Start show via timesheet engine\n  socket.on('startTimesheetShow', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    await timesheetEngine.start();\n    console.log('Socket: Timesheet show started');\n  });\n\n  // Stop show via timesheet engine\n  socket.on('stopTimesheetShow', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    timesheetEngine.stop();\n    console.log('Socket: Timesheet show stopped');\n  });\n\n  // Advance to next segment via timesheet engine\n  socket.on('advanceSegment', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const advancedBy = client?.name || socket.id;\n    const success = await timesheetEngine.advance(advancedBy);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot advance segment' });\n    }\n    console.log(`Socket: Segment advanced by ${advancedBy}`);\n  });\n\n  // Go to previous segment via timesheet engine\n  socket.on('previousSegment', async () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.previous(triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: 'Cannot go to previous segment' });\n    }\n    console.log(`Socket: Previous segment triggered by ${triggeredBy}`);\n  });\n\n  // Jump to specific segment via timesheet engine\n  socket.on('goToSegment', async ({ segmentId }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    if (!segmentId) {\n      socket.emit('error', { message: 'segmentId is required' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.goToSegment(segmentId, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Cannot jump to segment: ${segmentId}` });\n    }\n    console.log(`Socket: Jump to segment ${segmentId} by ${triggeredBy}`);\n  });\n\n  // Override scene via timesheet engine (producer only)\n  socket.on('timesheetOverrideScene', async ({ sceneName }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override scenes' });\n      return;\n    }\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.overrideScene(sceneName, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Failed to override scene: ${sceneName}` });\n    }\n    console.log(`Socket: Scene overridden to ${sceneName} by ${triggeredBy}`);\n  });\n\n  // Override camera via timesheet engine (producer only)\n  socket.on('overrideCamera', async ({ cameraId }) => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can override cameras' });\n      return;\n    }\n    const triggeredBy = client?.name || socket.id;\n    const success = await timesheetEngine.overrideCamera(cameraId, triggeredBy);\n    if (!success) {\n      socket.emit('error', { message: `Failed to override camera: ${cameraId}` });\n    }\n    console.log(`Socket: Camera overridden to ${cameraId} by ${triggeredBy}`);\n  });\n\n  // Get current timesheet state\n  socket.on('getTimesheetState', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetState', timesheetEngine.getState());\n  });\n\n  // Get timesheet overrides history\n  socket.on('getTimesheetOverrides', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetOverrides', timesheetEngine.getOverrides());\n  });\n\n  // Get timesheet segment history\n  socket.on('getTimesheetHistory', () => {\n    if (!timesheetEngine) {\n      socket.emit('error', { message: 'Timesheet engine not initialized' });\n      return;\n    }\n    socket.emit('timesheetHistory', timesheetEngine.getHistory());\n  });\n\n  // Start the show\n  socket.on('startShow', async () => {\n    showState.isPlaying = true;\n    showState.isPaused = false;\n    showState.currentSegmentIndex = 0;\n    updateCurrentSegment();\n    showState.segmentStartTime = Date.now();\n\n    if (showState.currentSegment?.obsScene) {\n      await switchScene(showState.currentSegment.obsScene);\n    }\n\n    if (showState.currentSegment?.graphic) {\n      io.emit('triggerGraphic', {\n        graphic: showState.currentSegment.graphic,\n        data: showState.currentSegment.graphicData || {}\n      });\n    }\n\n    if (showState.currentSegment?.autoAdvance && showState.currentSegment?.duration) {\n      setupAutoAdvance(showState.currentSegment.duration);\n    }\n\n    console.log('Show started');\n    broadcastState();\n  });\n\n  // Reset show\n  socket.on('resetShow', () => {\n    const client = showState.connectedClients.find(c => c.id === socket.id);\n    if (client?.role !== 'producer') {\n      socket.emit('error', { message: 'Only producers can reset the show' });\n      return;\n    }\n\n    clearAutoAdvance();\n    showState.isPlaying = false;\n    showState.isPaused = false;\n    showState.currentSegmentIndex = 0;\n    showState.segmentStartTime = null;\n    showState.segmentElapsed = 0;\n    updateCurrentSegment();\n\n    console.log('Show reset');\n    broadcastState();\n  });\n\n  // =====================================================\n  // VM Pool Socket Events (P15-03)\n  // =====================================================\n\n  // Assign a VM to a competition\n  socket.on('assignVM', async ({ competitionId, preferredVmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.assignVM(competitionId, preferredVmId);\n      // vmAssigned event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmAssignmentResult', result);\n    } catch (error) {\n      console.error(`[Socket] assignVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        competitionId\n      });\n    }\n  });\n\n  // Release a VM from a competition\n  socket.on('releaseVM', async ({ competitionId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.releaseVM(competitionId);\n      // vmReleased event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmReleaseResult', result);\n    } catch (error) {\n      console.error(`[Socket] releaseVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        competitionId\n      });\n    }\n  });\n\n  // Start a stopped VM\n  socket.on('startVM', async ({ vmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.startVM(vmId);\n      // vmStarting event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmStartResult', result);\n    } catch (error) {\n      console.error(`[Socket] startVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        vmId\n      });\n    }\n  });\n\n  // Stop a VM\n  socket.on('stopVM', async ({ vmId }) => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmError', { error: 'VM pool not initialized' });\n        return;\n      }\n\n      const result = await vmPoolManager.stopVM(vmId);\n      // vmStopping event is emitted by the pool manager and will be broadcast via event listener\n      socket.emit('vmStopResult', result);\n    } catch (error) {\n      console.error(`[Socket] stopVM failed:`, error.message);\n      socket.emit('vmError', {\n        error: error.message,\n        vmId\n      });\n    }\n  });\n\n  // Acknowledge an alert (placeholder for P17)\n  socket.on('acknowledgeAlert', ({ competitionId, alertId }) => {\n    console.log(`[Socket] acknowledgeAlert: competition=${competitionId}, alert=${alertId}`);\n    // Alert service will be implemented in P17-01\n    // For now, just acknowledge receipt\n    socket.emit('alertAcknowledged', { competitionId, alertId });\n  });\n\n  // Request current VM pool status\n  socket.on('getVMPoolStatus', () => {\n    try {\n      const vmPoolManager = getVMPoolManager();\n      if (!vmPoolManager.isInitialized()) {\n        socket.emit('vmPoolStatus', {\n          initialized: false,\n          vms: [],\n          counts: { total: 0 }\n        });\n        return;\n      }\n\n      socket.emit('vmPoolStatus', vmPoolManager.getPoolStatus());\n    } catch (error) {\n      console.error(`[Socket] getVMPoolStatus failed:`, error.message);\n      socket.emit('vmError', { error: error.message });\n    }\n  });\n\n  // Disconnect handling\n  socket.on('disconnect', () => {\n    console.log(`Client disconnected: ${socket.id}`);\n\n    // Clean up audio level subscriptions\n    const obsConnManager = getOBSConnectionManager();\n    obsConnManager.unsubscribeAudioLevelsAll(socket.id);\n\n    showState.connectedClients = showState.connectedClients.filter(c => c.id !== socket.id);\n    broadcastState();\n  });\n});\n\n// Update segment elapsed time every second\nsetInterval(() => {\n  if (showState.isPlaying && !showState.isPaused && showState.segmentStartTime) {\n    showState.segmentElapsed = Math.floor((Date.now() - showState.segmentStartTime) / 1000);\n    io.emit('timeUpdate', { elapsed: showState.segmentElapsed });\n  }\n}, 1000);\n\n// Initialize OBS Connection Manager event forwarding\nfunction initializeOBSConnectionManager() {\n  const obsConnManager = getOBSConnectionManager();\n\n  // Forward OBS events to the appropriate competition room\n  obsConnManager.on('obsEvent', ({ compId, eventName, data }) => {\n    const room = `competition:${compId}`;\n    console.log(`[OBSConnManager] Forwarding ${eventName} to room ${room}`);\n\n    // Map OBS events to Socket.io events\n    switch (eventName) {\n      case 'CurrentProgramSceneChanged':\n        io.to(room).emit('sceneChanged', data.sceneName);\n        io.to(room).emit('obs:currentSceneChanged', { sceneName: data.sceneName });\n        break;\n      case 'SceneListChanged':\n        io.to(room).emit('obs:sceneListChanged', data);\n        break;\n      case 'InputVolumeChanged':\n        io.to(room).emit('obs:volumeChanged', {\n          inputName: data.inputName,\n          volumeDb: data.inputVolumeDb,\n          volumeMul: data.inputVolumeMul\n        });\n        break;\n      case 'InputMuteStateChanged':\n        io.to(room).emit('obs:muteChanged', {\n          inputName: data.inputName,\n          muted: data.inputMuted\n        });\n        break;\n      case 'StreamStateChanged':\n        io.to(room).emit('obs:streamStateChanged', {\n          active: data.outputActive,\n          state: data.outputState\n        });\n        break;\n      case 'RecordStateChanged':\n        io.to(room).emit('obs:recordStateChanged', {\n          active: data.outputActive,\n          state: data.outputState\n        });\n        break;\n      case 'StudioModeStateChanged':\n        io.to(room).emit('obs:studioModeChanged', {\n          studioModeEnabled: data.studioModeEnabled\n        });\n        break;\n      case 'CurrentPreviewSceneChanged':\n        io.to(room).emit('obs:previewSceneChanged', {\n          sceneName: data.sceneName\n        });\n        break;\n      default:\n        // Forward unknown events generically\n        io.to(room).emit(`obs:${eventName}`, data);\n    }\n  });\n\n  // Handle connection events\n  obsConnManager.on('connected', async ({ compId, vmAddress }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:connected', { connected: true, vmAddress });\n\n    // Fetch and broadcast OBS state when connected\n    await broadcastOBSState(compId, obsConnManager, io);\n  });\n\n  obsConnManager.on('disconnected', ({ compId }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:disconnected', { connected: false });\n  });\n\n  // Handle unexpected connection loss (TCP close or heartbeat failure)\n  obsConnManager.on('connectionClosed', ({ compId }) => {\n    const room = `competition:${compId}`;\n    console.log(`[OBS] Connection closed for ${compId}, notifying clients`);\n    io.to(room).emit('obs:disconnected', { connected: false });\n  });\n\n  obsConnManager.on('connectionError', ({ compId, error }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:error', { error });\n  });\n\n  // Forward audio levels to competition room (Phase 2 - Real-time audio meters)\n  obsConnManager.on('audioLevels', ({ compId, levels }) => {\n    const room = `competition:${compId}`;\n    io.to(room).emit('obs:audioLevels', levels);\n  });\n\n  console.log('[Server] OBS Connection Manager initialized');\n}\n\n// Start server\nhttpServer.listen(PORT, () => {\n  console.log(`Show Controller Server running on port ${PORT}`);\n  console.log(`Talent View: http://localhost:${PORT}/talent`);\n  console.log(`Producer View: http://localhost:${PORT}/producer`);\n\n  // Load and validate show config (exit if invalid on startup)\n  loadShowConfig(true);\n\n  // Initialize camera management modules\n  initializeCameraModules();\n\n  // Initialize OBS scene generator\n  initializeSceneGenerator();\n\n  // Initialize timesheet engine\n  initializeTimesheetEngine();\n\n  // Initialize VM pool manager (for VM management features)\n  initializeVMPoolManager();\n\n  // Initialize auto-shutdown service (for coordinator mode)\n  initializeAutoShutdown();\n\n  // Initialize OBS Connection Manager for per-competition OBS connections\n  initializeOBSConnectionManager();\n\n  // Connect to OBS (for local/default OBS)\n  connectToOBS();\n});\n","structuredPatch":[{"oldStart":344,"oldLines":6,"newStart":344,"newLines":155,"lines":["   console.log('Timesheet engine initialized');"," }"," ","+/**","+ * Get or create a TimesheetEngine for a specific competition","+ * This is the new multi-competition approach - each competition gets its own engine instance","+ *","+ * @param {string} compId - Competition ID","+ * @param {Object} obsConnectionManager - OBS connection manager for per-competition OBS connections","+ * @param {Object} firebase - Firebase Admin instance for graphics","+ * @param {Object} socketIo - Socket.io server for broadcasting","+ * @returns {TimesheetEngine} The engine instance for this competition","+ */","+function getOrCreateEngine(compId, obsConnectionManager, firebase, socketIo) {","+  if (!compId) {","+    throw new Error('compId is required to get or create a TimesheetEngine');","+  }","+","+  if (timesheetEngines.has(compId)) {","+    return timesheetEngines.get(compId);","+  }","+","+  console.log(`[Timesheet] Creating new engine for competition: ${compId}`);","+","+  const engine = new TimesheetEngine({","+    compId,","+    obsConnectionManager,","+    firebase,","+    io: socketIo,","+    showConfig: { segments: [] } // Start with empty config - segments loaded via loadRundown","+  });","+","+  // Wire up timesheet events to broadcast to competition room only","+  const roomName = `competition:${compId}`;","+","+  engine.on('tick', (data) => {","+    socketIo.to(roomName).emit('timesheetTick', data);","+  });","+","+  engine.on('segmentActivated', (data) => {","+    console.log(`[Timesheet:${compId}] Segment activated - ${data.segment.name} (${data.reason})`);","+    socketIo.to(roomName).emit('timesheetSegmentActivated', data);","+    socketIo.to(roomName).emit('timesheetState', engine.getState());","+  });","+","+  engine.on('segmentCompleted', (data) => {","+    console.log(`[Timesheet:${compId}] Segment completed - ${data.segmentId} (${data.endReason})`);","+    socketIo.to(roomName).emit('timesheetSegmentCompleted', data);","+  });","+","+  engine.on('showStarted', (data) => {","+    console.log(`[Timesheet:${compId}] Show started`);","+    socketIo.to(roomName).emit('timesheetShowStarted', data);","+    socketIo.to(roomName).emit('timesheetState', engine.getState());","+  });","+","+  engine.on('showStopped', (data) => {","+    console.log(`[Timesheet:${compId}] Show stopped`);","+    socketIo.to(roomName).emit('timesheetShowStopped', data);","+    socketIo.to(roomName).emit('timesheetState', engine.getState());","+  });","+","+  engine.on('stateChanged', (data) => {","+    socketIo.to(roomName).emit('timesheetStateChanged', data);","+    socketIo.to(roomName).emit('timesheetState', engine.getState());","+  });","+","+  engine.on('holdStarted', (data) => {","+    console.log(`[Timesheet:${compId}] Hold started - ${data.segmentId}`);","+    socketIo.to(roomName).emit('timesheetHoldStarted', data);","+  });","+","+  engine.on('holdMaxReached', (data) => {","+    console.log(`[Timesheet:${compId}] Hold max reached - ${data.segmentId}`);","+    socketIo.to(roomName).emit('timesheetHoldMaxReached', data);","+  });","+","+  engine.on('autoAdvancing', (data) => {","+    console.log(`[Timesheet:${compId}] Auto-advancing from ${data.fromSegmentId} to segment ${data.toSegmentIndex}`);","+    socketIo.to(roomName).emit('timesheetAutoAdvancing', data);","+  });","+","+  engine.on('overrideRecorded', (data) => {","+    console.log(`[Timesheet:${compId}] Override recorded - ${data.type}`);","+    socketIo.to(roomName).emit('timesheetOverrideRecorded', data);","+  });","+","+  engine.on('sceneChanged', (data) => {","+    socketIo.to(roomName).emit('timesheetSceneChanged', data);","+  });","+","+  engine.on('sceneOverridden', (data) => {","+    console.log(`[Timesheet:${compId}] Scene overridden to ${data.sceneName}`);","+    socketIo.to(roomName).emit('timesheetSceneOverridden', data);","+  });","+","+  engine.on('cameraOverridden', (data) => {","+    console.log(`[Timesheet:${compId}] Camera overridden to ${data.cameraName}`);","+    socketIo.to(roomName).emit('timesheetCameraOverridden', data);","+  });","+","+  engine.on('graphicTriggered', (data) => {","+    socketIo.to(roomName).emit('timesheetGraphicTriggered', data);","+  });","+","+  engine.on('videoStarted', (data) => {","+    socketIo.to(roomName).emit('timesheetVideoStarted', data);","+  });","+","+  engine.on('breakStarted', (data) => {","+    console.log(`[Timesheet:${compId}] Break started - ${data.segmentId}`);","+    socketIo.to(roomName).emit('timesheetBreakStarted', data);","+  });","+","+  engine.on('error', (data) => {","+    console.error(`[Timesheet:${compId}] Error: ${data.message}`);","+    socketIo.to(roomName).emit('timesheetError', data);","+  });","+","+  timesheetEngines.set(compId, engine);","+  console.log(`[Timesheet] Engine created for competition: ${compId} (total engines: ${timesheetEngines.size})`);","+","+  return engine;","+}","+","+/**","+ * Get an existing TimesheetEngine for a competition (does not create)","+ * @param {string} compId - Competition ID","+ * @returns {TimesheetEngine|null} The engine instance or null if not found","+ */","+function getEngine(compId) {","+  return timesheetEngines.get(compId) || null;","+}","+","+/**","+ * Remove a TimesheetEngine for a competition","+ * @param {string} compId - Competition ID","+ */","+function removeEngine(compId) {","+  const engine = timesheetEngines.get(compId);","+  if (engine) {","+    // Stop the engine if running","+    if (engine.isRunning) {","+      engine.stop();","+    }","+    // Remove all listeners to prevent memory leaks","+    engine.removeAllListeners();","+    timesheetEngines.delete(compId);","+    console.log(`[Timesheet] Engine removed for competition: ${compId} (remaining engines: ${timesheetEngines.size})`);","+  }","+}","+"," // Initialize OBS State Sync"," async function initializeOBSStateSync(competitionId) {","   if (!competitionId) {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01495ry49nz9appyvpGM2obg","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the Implementation Plan to mark Task 2 as complete:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1975,"cache_read_input_tokens":75261,"cache_creation":{"ephemeral_5m_input_tokens":1975,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"31ad668b-c2c2-4010-81d1-e2443ba32b73"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01495ry49nz9appyvpGM2obg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ub7trzusY1xt83TphzNZkv","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","old_string":"| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |","new_string":"| Task 2 | Create `timesheetEngines` Map in server/index.js | COMPLETE | Added Map, getOrCreateEngine, getEngine, removeEngine functions |"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":1975,"cache_read_input_tokens":75261,"cache_creation":{"ephemeral_5m_input_tokens":1975,"ephemeral_1h_input_tokens":0},"output_tokens":211,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"b285f372-87ba-4291-a0ca-018dfab07034"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ub7trzusY1xt83TphzNZkv","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"895005e8-7f9a-40f7-825f-8590a4a21fa9","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","oldString":"| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |","newString":"| Task 2 | Create `timesheetEngines` Map in server/index.js | COMPLETE | Added Map, getOrCreateEngine, getEngine, removeEngine functions |","originalFile":"# PLAN-Rundown-System-Implementation\n\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n**Status:** NOT STARTED\n**Created:** 2026-01-23\n**Last Updated:** 2026-01-23\n\n---\n\n## Overview\n\nThis implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n\n---\n\n## IMPORTANT: Task Execution Rules\n\n**ONE TASK = ONE ITERATION**\n\nEach row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n\n1. Pick the first NOT STARTED or IN PROGRESS task\n2. Implement that ONE task\n3. Commit, deploy, verify\n4. STOP - the next iteration will handle the next task\n\n**Do NOT:**\n- Complete multiple tasks in one iteration\n- Batch \"related\" tasks together\n- Complete an entire phase in one iteration\n\n**Task Numbering:**\n- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n- Each task number is unique and independent\n- Example: \"Task 8\" is ONE task, not a subtask\n\n---\n\n## Phase Summary\n\n| Phase | Name | Priority | Status | Tasks |\n|-------|------|----------|--------|-------|\n| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n| B | Talent View | P1 | NOT STARTED | 22-27 |\n| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n\n---\n\n## Task Summary by Phase\n\n### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |\n| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |\n| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n\n### Phase H: Rehearsal Mode (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n\n### Phase B: Talent View (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n| Task 24 | Scene switching buttons | NOT STARTED | |\n| Task 25 | Next segment preview | NOT STARTED | |\n| Task 26 | Notes display | NOT STARTED | |\n| Task 27 | Add `/talent` route | NOT STARTED | |\n\n### Phase I: Live Rundown Sync (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n| Task 35 | Handle deleted current segment | NOT STARTED | |\n| Task 36 | Handle reordered past segments | NOT STARTED | |\n| Task 37 | Handle ID conflicts | NOT STARTED | |\n\n### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 38 | Log actual segment durations during show | NOT STARTED | |\n| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n\n### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n\n### Phase E: Script & Talent Flow (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 49 | Add script field to segment data model | NOT STARTED | |\n| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n| Task 53 | Create talent schedule view | NOT STARTED | |\n| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n\n### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 55 | Create AIContextService stub | NOT STARTED | |\n| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n| Task 59 | Generate talking points in real-time | NOT STARTED | |\n| Task 60 | Detect career highs, records during show | NOT STARTED | |\n| Task 61 | Display AI context in Talent View | NOT STARTED | |\n| Task 62 | Display AI context in Producer View | NOT STARTED | |\n\n### Phase F: Audio Cue Integration (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n| Task 66 | Add audio control to Producer View | NOT STARTED | |\n\n### Phase G: Production Tracking (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n| Task 68 | Generate equipment schedule report | NOT STARTED | |\n| Task 69 | Detect equipment conflicts | NOT STARTED | |\n| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n\n---\n\n## Detailed Tasks - Phase A (P0)\n\n### Task 1: Update TimesheetEngine constructor\n\n**Status:** COMPLETE (Commit 9d0267c)\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n\n**Checklist:**\n- [ ] Add `compId` parameter to constructor\n- [ ] Add `obsConnectionManager` parameter to constructor\n- [ ] Store both as instance properties\n- [ ] Remove dependency on global `obs` singleton\n\n---\n\n### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic\n\n---\n\n### Task 3: Update _applyTransitionAndSwitchScene()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the scene switching method to use per-competition OBS connection via obsConnectionManager.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n- [ ] Add error handling for disconnected state\n\n---\n\n### Task 4: Update _playVideo()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the video playback method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 5: Update _applyAudioOverrides()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the audio override method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 6: Update socket event broadcasts\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate all socket.io event emissions to target the competition-specific room.\n\n**Checklist:**\n- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n- [ ] Verify room naming matches existing convention\n\n---\n\n### Task 7: Pass Firebase Admin to engine\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n\n**Description:**\nPass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n\n**Checklist:**\n- [ ] Add `firebase` parameter to constructor\n- [ ] Export `db` from productionConfigService.js\n- [ ] Pass Firebase instance when creating engine\n- [ ] Update `_triggerGraphic()` to use `this.firebase`\n\n---\n\n### Task 8: Add loadRundown socket handler\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nAdd socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n\n**Checklist:**\n- [ ] Add `socket.on('loadRundown', ...)` handler\n- [ ] Extract `compId` from payload\n- [ ] Call `getOrCreateEngine()` to get engine instance\n- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n- [ ] Call engine's load method with segments\n- [ ] Emit `timesheetState` with loaded segments\n\n---\n\n### Task 9: Add loadRundown action in ShowContext\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/context/ShowContext.jsx`\n\n**Description:**\nAdd `loadRundown` action to emit the socket event from client.\n\n**Checklist:**\n- [ ] Add `loadRundown` function that emits `loadRundown` event\n- [ ] Pass `compId` from context\n- [ ] Export function from context\n\n---\n\n### Task 10: Add \"Load Rundown\" button\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd \"Load Rundown\" button in Producer View header/toolbar.\n\n**Checklist:**\n- [ ] Add \"Load Rundown\" button to Producer View\n- [ ] Wire button to `loadRundown` action from ShowContext\n- [ ] Show loading state while loading\n- [ ] Show toast on success/failure\n\n---\n\n### Task 11: Create segment mapper\n\n**Status:** NOT STARTED\n**File:** `server/lib/segmentMapper.js` (new file)\n\n**Description:**\nCreate utility to map Rundown Editor segment format to Timesheet Engine format.\n\n**Checklist:**\n- [ ] Create `server/lib/segmentMapper.js`\n- [ ] Map `scene` → `obsScene`\n- [ ] Map `graphic.graphicId` → `graphic`\n- [ ] Map `graphic.params` → `graphicData`\n- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n- [ ] Preserve all other fields\n\n---\n\n### Task 12: Verify Firebase passed to engine\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nVerify Firebase Admin is correctly passed and usable in engine.\n\n**Checklist:**\n- [ ] Add logging to confirm Firebase instance received\n- [ ] Test that `_triggerGraphic()` can write to Firebase\n- [ ] Handle missing Firebase gracefully\n\n---\n\n### Task 13: Show rundown status indicator\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd status indicator showing rundown state (idle, loaded, modified).\n\n**Checklist:**\n- [ ] Add status badge component\n- [ ] Show \"No Rundown\" when state is IDLE\n- [ ] Show \"Rundown Loaded\" when state is LOADED\n- [ ] Show segment count in badge\n\n---\n\n### Task 14: Verify scene picker uses OBS state\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n\n**Checklist:**\n- [ ] Check current implementation of scene picker\n- [ ] If hardcoded, plan integration with OBS scene list\n- [ ] Document current state\n\n---\n\n### Task 15: Verify graphics picker uses Registry\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the graphics picker dropdown uses graphicsRegistry.js.\n\n**Checklist:**\n- [ ] Check current implementation of graphics picker\n- [ ] Verify graphicsRegistry.js is imported and used\n- [ ] Confirm graphics filtered by competition type\n\n---\n\n### Task 16: Fix hardcoded picker data\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nReplace any hardcoded picker data with live data sources.\n\n**Checklist:**\n- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n- [ ] Verify graphics come from registry\n- [ ] Test with actual competition data\n\n---\n\n## Bugs & Issues\n\n| Bug ID | Description | Status | Task |\n|--------|-------------|--------|------|\n\n---\n\n## Notes\n\n### Dependencies\n- **Phase A** is the prerequisite for all other phases\n- **Phase H** and **Phase B** can run in parallel after Phase A\n- **Phase I-G** depend on Phase A completion\n\n### Architecture Considerations\n- Multi-competition support requires Map-based engine instances\n- Socket.io rooms isolate competition events\n- Firebase Admin must be passed to engine (not just client SDK)\n- OBS connections managed by existing obsConnectionManager\n\n### Critical Gap Identified\nCurrent `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n\n### Key Files Reference\nSee [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n\n---\n\n## Completion Criteria\n\n**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n\n**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n\n**Full System:** All phases complete.\n","structuredPatch":[{"oldStart":69,"oldLines":7,"newStart":69,"newLines":7,"lines":[" | Task | Description | Status | Notes |"," |------|-------------|--------|-------|"," | Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |","-| Task 2 | Create `timesheetEngines` Map in server/index.js | NOT STARTED | |","+| Task 2 | Create `timesheetEngines` Map in server/index.js | COMPLETE | Added Map, getOrCreateEngine, getEngine, removeEngine functions |"," | Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |"," | Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |"," | Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XpnYrBzkk7f3Yv8A5cBaD8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WGg13ZBEsbdRVopnDf1zgi","name":"Edit","input":{"file_path":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","old_string":"### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic","new_string":"### Task 2: Create timesheetEngines Map\n\n**Status:** COMPLETE\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [x] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [x] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [x] Update existing engine initialization logic\n\n**Implementation Notes:**\n- Added `const timesheetEngines = new Map()` to store per-competition engines\n- Kept legacy `let timesheetEngine = null` for backward compatibility during transition\n- Created `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function that:\n  - Creates new engine with compId, obsConnectionManager, firebase, and io\n  - Wires up all events to broadcast to competition-specific room (`competition:${compId}`)\n  - Stores engine in the Map for reuse\n- Created `getEngine(compId)` helper to retrieve existing engines\n- Created `removeEngine(compId)` helper to clean up engines when competitions end"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":430,"cache_read_input_tokens":77236,"cache_creation":{"ephemeral_5m_input_tokens":430,"ephemeral_1h_input_tokens":0},"output_tokens":525,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"13631851-df9a-4db7-a380-3efafead4a54"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WGg13ZBEsbdRVopnDf1zgi","type":"tool_result","content":"The file /Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"adc27607-3582-4b59-b626-4374f9b6bb14","tool_use_result":{"filePath":"/Users/juliacosmiano/code/gymnastics-graphics/docs/PRD-Rundown-System/PLAN-Rundown-System-Implementation.md","oldString":"### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic","newString":"### Task 2: Create timesheetEngines Map\n\n**Status:** COMPLETE\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [x] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [x] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [x] Update existing engine initialization logic\n\n**Implementation Notes:**\n- Added `const timesheetEngines = new Map()` to store per-competition engines\n- Kept legacy `let timesheetEngine = null` for backward compatibility during transition\n- Created `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function that:\n  - Creates new engine with compId, obsConnectionManager, firebase, and io\n  - Wires up all events to broadcast to competition-specific room (`competition:${compId}`)\n  - Stores engine in the Map for reuse\n- Created `getEngine(compId)` helper to retrieve existing engines\n- Created `removeEngine(compId)` helper to clean up engines when competitions end","originalFile":"# PLAN-Rundown-System-Implementation\n\n**PRD:** [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md)\n**Status:** NOT STARTED\n**Created:** 2026-01-23\n**Last Updated:** 2026-01-23\n\n---\n\n## Overview\n\nThis implementation plan covers all phases of the Rundown System from planning to live execution. Phase A connects the existing Rundown Editor to the Timesheet Engine for live show execution. Subsequent phases add rehearsal mode, talent view, live sync, analytics, and AI features.\n\n---\n\n## Related Documents\n\n| Document | Purpose |\n|----------|---------|\n| [PRD-Rundown-System-2026-01-23.md](./PRD-Rundown-System-2026-01-23.md) | Product requirements |\n| [PLAN-Rundown-System-2026-01-23.md](./PLAN-Rundown-System-2026-01-23.md) | Technical reference (architecture, state machine, socket events, error handling, testing) |\n\n---\n\n## IMPORTANT: Task Execution Rules\n\n**ONE TASK = ONE ITERATION**\n\nEach row in the task tables below is ONE task. Complete exactly ONE task per iteration:\n\n1. Pick the first NOT STARTED or IN PROGRESS task\n2. Implement that ONE task\n3. Commit, deploy, verify\n4. STOP - the next iteration will handle the next task\n\n**Do NOT:**\n- Complete multiple tasks in one iteration\n- Batch \"related\" tasks together\n- Complete an entire phase in one iteration\n\n**Task Numbering:**\n- Tasks are numbered sequentially: Task 1, Task 2, ... Task 71\n- Each task number is unique and independent\n- Example: \"Task 8\" is ONE task, not a subtask\n\n---\n\n## Phase Summary\n\n| Phase | Name | Priority | Status | Tasks |\n|-------|------|----------|--------|-------|\n| A | Connect Editor to Engine | P0 | NOT STARTED | 1-16 |\n| H | Rehearsal Mode | P1 | NOT STARTED | 17-21 |\n| B | Talent View | P1 | NOT STARTED | 22-27 |\n| I | Live Rundown Sync | P2 | NOT STARTED | 28-37 |\n| J | Segment Timing Analytics | P2 | NOT STARTED | 38-42 |\n| D | AI Suggestions - Planning | P2 | NOT STARTED | 43-48 |\n| E | Script & Talent Flow | P2 | NOT STARTED | 49-54 |\n| C | AI Context - Live Execution | P3 | NOT STARTED | 55-62 |\n| F | Audio Cue Integration | P3 | NOT STARTED | 63-66 |\n| G | Production Tracking | P3 | NOT STARTED | 67-71 |\n\n---\n\n## Task Summary by Phase\n\n### Phase A: Connect Editor to Engine (P0) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 1 | Update TimesheetEngine constructor to accept `compId` and `obsConnectionManager` | COMPLETE | Commit 9d0267c |\n| Task 2 | Create `timesheetEngines` Map in server/index.js | COMPLETE | Added Map, getOrCreateEngine, getEngine, removeEngine functions |\n| Task 3 | Update `_applyTransitionAndSwitchScene()` to use `obsConnectionManager.getConnection(this.compId)` | NOT STARTED | |\n| Task 4 | Update `_playVideo()` to use per-competition OBS connection | NOT STARTED | |\n| Task 5 | Update `_applyAudioOverrides()` to use per-competition OBS connection | NOT STARTED | |\n| Task 6 | Update all socket event broadcasts to target competition room | NOT STARTED | |\n| Task 7 | Pass Firebase Admin instance to engine for `_triggerGraphic()` | NOT STARTED | |\n| Task 8 | Add `loadRundown` socket handler on server | NOT STARTED | |\n| Task 9 | Add `loadRundown` action in ShowContext | NOT STARTED | |\n| Task 10 | Add \"Load Rundown\" button in Producer View | NOT STARTED | |\n| Task 11 | Create segment mapper (Editor format → Engine format) | NOT STARTED | |\n| Task 12 | Verify Firebase is passed to engine | NOT STARTED | |\n| Task 13 | Show rundown status indicator (loaded, modified, etc.) | NOT STARTED | |\n| Task 14 | Verify Rundown Editor scene picker uses OBS state | NOT STARTED | |\n| Task 15 | Verify Rundown Editor graphics picker uses Graphics Registry | NOT STARTED | |\n| Task 16 | Fix any hardcoded picker data | NOT STARTED | |\n\n### Phase H: Rehearsal Mode (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 17 | Add rehearsal mode toggle to Timesheet Engine | NOT STARTED | |\n| Task 18 | Skip OBS scene changes in rehearsal mode | NOT STARTED | |\n| Task 19 | Skip graphics firing in rehearsal mode | NOT STARTED | |\n| Task 20 | Show \"REHEARSAL\" indicator in all views | NOT STARTED | |\n| Task 21 | Log timing data for post-rehearsal analysis | NOT STARTED | |\n\n### Phase B: Talent View (P1) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 22 | Create `TalentView.jsx` page | NOT STARTED | |\n| Task 23 | Current segment with prominent time remaining | NOT STARTED | |\n| Task 24 | Scene switching buttons | NOT STARTED | |\n| Task 25 | Next segment preview | NOT STARTED | |\n| Task 26 | Notes display | NOT STARTED | |\n| Task 27 | Add `/talent` route | NOT STARTED | |\n\n### Phase I: Live Rundown Sync (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 28 | Subscribe to Firebase `rundown/segments` changes on server | NOT STARTED | |\n| Task 29 | Compare incoming segments to loaded segments (deep diff) | NOT STARTED | |\n| Task 30 | Emit `rundownModified` socket event with change summary | NOT STARTED | |\n| Task 31 | Add `rundownModified` state to `useTimesheet` hook | NOT STARTED | |\n| Task 32 | Show \"Rundown Modified\" warning badge in Producer View | NOT STARTED | |\n| Task 33 | Add \"Reload Rundown\" button (appears when modified) | NOT STARTED | |\n| Task 34 | Confirmation dialog with change summary | NOT STARTED | |\n| Task 35 | Handle deleted current segment | NOT STARTED | |\n| Task 36 | Handle reordered past segments | NOT STARTED | |\n| Task 37 | Handle ID conflicts | NOT STARTED | |\n\n### Phase J: Segment Timing Analytics (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 38 | Log actual segment durations during show | NOT STARTED | |\n| Task 39 | Store timing data in Firebase post-show | NOT STARTED | |\n| Task 40 | Create timing analytics dashboard | NOT STARTED | |\n| Task 41 | Show historical average in Rundown Editor | NOT STARTED | |\n| Task 42 | AI-powered timing predictions based on history | NOT STARTED | |\n\n### Phase D: AI Suggestions - Planning (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 43 | Create AI suggestion service on server | NOT STARTED | |\n| Task 44 | Analyze competition metadata (type, teams, date) | NOT STARTED | |\n| Task 45 | Query roster data for seniors, All-Americans, milestones | NOT STARTED | |\n| Task 46 | Generate segment suggestions with confidence scores | NOT STARTED | |\n| Task 47 | Add `getAISuggestions` API endpoint | NOT STARTED | |\n| Task 48 | Wire Rundown Editor to display suggestions | NOT STARTED | |\n\n### Phase E: Script & Talent Flow (P2) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 49 | Add script field to segment data model | NOT STARTED | |\n| Task 50 | Pipe script field through Timesheet Engine | NOT STARTED | |\n| Task 51 | Display script in Talent View (teleprompter-style) | NOT STARTED | |\n| Task 52 | Add talent assignment to segment data model | NOT STARTED | |\n| Task 53 | Create talent schedule view | NOT STARTED | |\n| Task 54 | Show \"you're on camera\" indicator in Talent View | NOT STARTED | |\n\n### Phase C: AI Context - Live Execution (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 55 | Create AIContextService stub | NOT STARTED | |\n| Task 56 | Add `aiContextUpdated` socket event | NOT STARTED | |\n| Task 57 | Create `useAIContext` hook | NOT STARTED | |\n| Task 58 | Integrate with Virtius API for live stats | NOT STARTED | |\n| Task 59 | Generate talking points in real-time | NOT STARTED | |\n| Task 60 | Detect career highs, records during show | NOT STARTED | |\n| Task 61 | Display AI context in Talent View | NOT STARTED | |\n| Task 62 | Display AI context in Producer View | NOT STARTED | |\n\n### Phase F: Audio Cue Integration (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 63 | Add audio cue fields to segment data model | NOT STARTED | |\n| Task 64 | Pipe audio cues through Timesheet Engine | NOT STARTED | |\n| Task 65 | Trigger audio playback on segment start | NOT STARTED | |\n| Task 66 | Add audio control to Producer View | NOT STARTED | |\n\n### Phase G: Production Tracking (P3) - NOT STARTED\n\n| Task | Description | Status | Notes |\n|------|-------------|--------|-------|\n| Task 67 | Add equipment fields to segment data model | NOT STARTED | |\n| Task 68 | Generate equipment schedule report | NOT STARTED | |\n| Task 69 | Detect equipment conflicts | NOT STARTED | |\n| Task 70 | Add sponsor fields to segment data model | NOT STARTED | |\n| Task 71 | Generate sponsor fulfillment report | NOT STARTED | |\n\n---\n\n## Detailed Tasks - Phase A (P0)\n\n### Task 1: Update TimesheetEngine constructor\n\n**Status:** COMPLETE (Commit 9d0267c)\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the TimesheetEngine constructor to accept `compId` and `obsConnectionManager` parameters for multi-competition support.\n\n**Checklist:**\n- [ ] Add `compId` parameter to constructor\n- [ ] Add `obsConnectionManager` parameter to constructor\n- [ ] Store both as instance properties\n- [ ] Remove dependency on global `obs` singleton\n\n---\n\n### Task 2: Create timesheetEngines Map\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nCreate a Map to store per-competition TimesheetEngine instances, replacing the single global instance.\n\n**Checklist:**\n- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`\n- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function\n- [ ] Update existing engine initialization logic\n\n---\n\n### Task 3: Update _applyTransitionAndSwitchScene()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the scene switching method to use per-competition OBS connection via obsConnectionManager.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n- [ ] Add error handling for disconnected state\n\n---\n\n### Task 4: Update _playVideo()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the video playback method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 5: Update _applyAudioOverrides()\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate the audio override method to use per-competition OBS connection.\n\n**Checklist:**\n- [ ] Replace `this.obs.call(...)` with `this.obsConnectionManager.getConnection(this.compId).call(...)`\n- [ ] Handle case when connection doesn't exist\n\n---\n\n### Task 6: Update socket event broadcasts\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`\n\n**Description:**\nUpdate all socket.io event emissions to target the competition-specific room.\n\n**Checklist:**\n- [ ] Replace `this.io.emit(...)` with `this.io.to('competition:${this.compId}').emit(...)`\n- [ ] Update all event emissions: `timesheetState`, `timesheetTick`, `timesheetSegmentActivated`, etc.\n- [ ] Verify room naming matches existing convention\n\n---\n\n### Task 7: Pass Firebase Admin to engine\n\n**Status:** NOT STARTED\n**File:** `server/lib/timesheetEngine.js`, `server/index.js`\n\n**Description:**\nPass Firebase Admin instance to engine constructor for `_triggerGraphic()` functionality.\n\n**Checklist:**\n- [ ] Add `firebase` parameter to constructor\n- [ ] Export `db` from productionConfigService.js\n- [ ] Pass Firebase instance when creating engine\n- [ ] Update `_triggerGraphic()` to use `this.firebase`\n\n---\n\n### Task 8: Add loadRundown socket handler\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nAdd socket handler for `loadRundown` event that creates/retrieves engine and loads segments from Firebase.\n\n**Checklist:**\n- [ ] Add `socket.on('loadRundown', ...)` handler\n- [ ] Extract `compId` from payload\n- [ ] Call `getOrCreateEngine()` to get engine instance\n- [ ] Fetch segments from Firebase path: `competitions/{compId}/production/rundown/segments`\n- [ ] Call engine's load method with segments\n- [ ] Emit `timesheetState` with loaded segments\n\n---\n\n### Task 9: Add loadRundown action in ShowContext\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/context/ShowContext.jsx`\n\n**Description:**\nAdd `loadRundown` action to emit the socket event from client.\n\n**Checklist:**\n- [ ] Add `loadRundown` function that emits `loadRundown` event\n- [ ] Pass `compId` from context\n- [ ] Export function from context\n\n---\n\n### Task 10: Add \"Load Rundown\" button\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd \"Load Rundown\" button in Producer View header/toolbar.\n\n**Checklist:**\n- [ ] Add \"Load Rundown\" button to Producer View\n- [ ] Wire button to `loadRundown` action from ShowContext\n- [ ] Show loading state while loading\n- [ ] Show toast on success/failure\n\n---\n\n### Task 11: Create segment mapper\n\n**Status:** NOT STARTED\n**File:** `server/lib/segmentMapper.js` (new file)\n\n**Description:**\nCreate utility to map Rundown Editor segment format to Timesheet Engine format.\n\n**Checklist:**\n- [ ] Create `server/lib/segmentMapper.js`\n- [ ] Map `scene` → `obsScene`\n- [ ] Map `graphic.graphicId` → `graphic`\n- [ ] Map `graphic.params` → `graphicData`\n- [ ] Map `timingMode` → `autoAdvance` (fixed=true, manual=false)\n- [ ] Preserve all other fields\n\n---\n\n### Task 12: Verify Firebase passed to engine\n\n**Status:** NOT STARTED\n**File:** `server/index.js`\n\n**Description:**\nVerify Firebase Admin is correctly passed and usable in engine.\n\n**Checklist:**\n- [ ] Add logging to confirm Firebase instance received\n- [ ] Test that `_triggerGraphic()` can write to Firebase\n- [ ] Handle missing Firebase gracefully\n\n---\n\n### Task 13: Show rundown status indicator\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/views/ProducerView.jsx`\n\n**Description:**\nAdd status indicator showing rundown state (idle, loaded, modified).\n\n**Checklist:**\n- [ ] Add status badge component\n- [ ] Show \"No Rundown\" when state is IDLE\n- [ ] Show \"Rundown Loaded\" when state is LOADED\n- [ ] Show segment count in badge\n\n---\n\n### Task 14: Verify scene picker uses OBS state\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the scene picker dropdown loads scenes from OBS connection state rather than hardcoded data.\n\n**Checklist:**\n- [ ] Check current implementation of scene picker\n- [ ] If hardcoded, plan integration with OBS scene list\n- [ ] Document current state\n\n---\n\n### Task 15: Verify graphics picker uses Registry\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nVerify that the graphics picker dropdown uses graphicsRegistry.js.\n\n**Checklist:**\n- [ ] Check current implementation of graphics picker\n- [ ] Verify graphicsRegistry.js is imported and used\n- [ ] Confirm graphics filtered by competition type\n\n---\n\n### Task 16: Fix hardcoded picker data\n\n**Status:** NOT STARTED\n**File:** `show-controller/src/pages/RundownEditorPage.jsx`\n\n**Description:**\nReplace any hardcoded picker data with live data sources.\n\n**Checklist:**\n- [ ] Replace DUMMY_SCENES with OBS scene list (if hardcoded)\n- [ ] Verify graphics come from registry\n- [ ] Test with actual competition data\n\n---\n\n## Bugs & Issues\n\n| Bug ID | Description | Status | Task |\n|--------|-------------|--------|------|\n\n---\n\n## Notes\n\n### Dependencies\n- **Phase A** is the prerequisite for all other phases\n- **Phase H** and **Phase B** can run in parallel after Phase A\n- **Phase I-G** depend on Phase A completion\n\n### Architecture Considerations\n- Multi-competition support requires Map-based engine instances\n- Socket.io rooms isolate competition events\n- Firebase Admin must be passed to engine (not just client SDK)\n- OBS connections managed by existing obsConnectionManager\n\n### Critical Gap Identified\nCurrent `server/index.js` uses single global `timesheetEngine` instance. Must refactor to per-competition Map before any Phase A work can proceed. See [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 5.2 for details.\n\n### Key Files Reference\nSee [Technical Reference](./PLAN-Rundown-System-2026-01-23.md) Section 4 for complete file listing.\n\n---\n\n## Completion Criteria\n\n**Phase A Complete:** Producer can load rundown from Firebase, start show, and see segments execute with OBS scene changes.\n\n**MVP Complete:** Phases A + H + B (producer can run rehearsals, talent has dedicated view).\n\n**Full System:** All phases complete.\n","structuredPatch":[{"oldStart":207,"oldLines":17,"newStart":207,"newLines":27,"lines":[" "," ### Task 2: Create timesheetEngines Map"," ","-**Status:** NOT STARTED","+**Status:** COMPLETE"," **File:** `server/index.js`"," "," **Description:**"," Create a Map to store per-competition TimesheetEngine instances, replacing the single global instance."," "," **Checklist:**","-- [ ] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`","-- [ ] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function","-- [ ] Update existing engine initialization logic","+- [x] Replace `let timesheetEngine` with `const timesheetEngines = new Map()`","+- [x] Create `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function","+- [x] Update existing engine initialization logic"," ","+**Implementation Notes:**","+- Added `const timesheetEngines = new Map()` to store per-competition engines","+- Kept legacy `let timesheetEngine = null` for backward compatibility during transition","+- Created `getOrCreateEngine(compId, obsConnectionManager, firebase, io)` function that:","+  - Creates new engine with compId, obsConnectionManager, firebase, and io","+  - Wires up all events to broadcast to competition-specific room (`competition:${compId}`)","+  - Stores engine in the Map for reuse","+- Created `getEngine(compId)` helper to retrieve existing engines","+- Created `removeEngine(compId)` helper to clean up engines when competitions end","+"," ---"," "," ### Task 3: Update _applyTransitionAndSwitchScene()"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013DixddV2EGW7gA3Ff2HdAS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TG7Zp9CaY8VCx75Jd5wuQn","name":"TodoWrite","input":{"todos":[{"content":"Update Implementation Plan to mark Task 1 as COMPLETE","status":"completed","activeForm":"Updating Implementation Plan to mark Task 1 as COMPLETE"},{"content":"Implement Task 2: Create timesheetEngines Map in server/index.js","status":"completed","activeForm":"Implementing Task 2: Creating timesheetEngines Map in server/index.js"},{"content":"Commit, deploy, and verify changes","status":"in_progress","activeForm":"Committing, deploying, and verifying changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":582,"cache_read_input_tokens":77666,"cache_creation":{"ephemeral_5m_input_tokens":582,"ephemeral_1h_input_tokens":0},"output_tokens":190,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"bfbd758f-1d53-4a04-b258-bdd25624027f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TG7Zp9CaY8VCx75Jd5wuQn","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"b4d5a051-574a-4a9f-942e-87dd726a3d05","tool_use_result":{"oldTodos":[{"content":"Update Implementation Plan to mark Task 1 as COMPLETE","status":"completed","activeForm":"Updating Implementation Plan to mark Task 1 as COMPLETE"},{"content":"Implement Task 2: Create timesheetEngines Map in server/index.js","status":"in_progress","activeForm":"Implementing Task 2: Creating timesheetEngines Map in server/index.js"}],"newTodos":[{"content":"Update Implementation Plan to mark Task 1 as COMPLETE","status":"completed","activeForm":"Updating Implementation Plan to mark Task 1 as COMPLETE"},{"content":"Implement Task 2: Create timesheetEngines Map in server/index.js","status":"completed","activeForm":"Implementing Task 2: Creating timesheetEngines Map in server/index.js"},{"content":"Commit, deploy, and verify changes","status":"in_progress","activeForm":"Committing, deploying, and verifying changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NDmgiVQDGssn6efmBE5o6a","type":"message","role":"assistant","content":[{"type":"text","text":"```\n3.3 ONE Task Implementation Complete\n- Task completed: Task 2\n- Changes made: Added timesheetEngines Map, getOrCreateEngine(), getEngine(), removeEngine() functions with competition-specific room broadcasting\n- Bugs found: none\n- Next task: will be handled in NEXT iteration\n```\n\n---\n\n## Phase 4: Commit & Push"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":78248,"cache_creation":{"ephemeral_5m_input_tokens":232,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"ac910d68-2521-4a5d-b074-3c3657e0f119"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NDmgiVQDGssn6efmBE5o6a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S7XfJMsW28XMDupeT9cYAQ","name":"Bash","input":{"command":"git add -A && git status","description":"Stage all changes and check status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":0,"cache_creation_input_tokens":232,"cache_read_input_tokens":78248,"cache_creation":{"ephemeral_5m_input_tokens":232,"ephemeral_1h_input_tokens":0},"output_tokens":180,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"1c34a855-09cf-42a5-9449-a36a1943df18","uuid":"0147bf12-e8a8-4430-8052-3a1d5b574a3a"}
